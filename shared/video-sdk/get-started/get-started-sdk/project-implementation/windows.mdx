<PlatformWrapper platform="windows">

<ProductWrapper product="{['interactive-live-streaming', 'broadcast-streaming']}">
![image](/images/video-sdk/ils-call-logic-android.svg)
</ProductWrapper>

<ProductWrapper product="video-calling">
![image](/images/video-sdk/video-call-logic-android.svg)
</ProductWrapper>

Best practice is to separate the <Vpd k="NAME" /> workflows from your UI implementation. The <Vpd  k="SDK" />
  sample project implements <Vpd k="PRODUCT" /> logic in the
  [`AgoraManager`](https://github.com/AgoraIO/video-sdk-samples-android/blob/main/agora-manager/src/main/java/io/agora/agora_manager/AgoraManager.kt) class.
  This class encapsulates the `RTCEngine` instance and core functionality as illustrated by the excerpts below:

1. **Import the <Vpd k="SDK" /> classes, interfaces and libraries**:

    ```cpp
    #ifndef PCH_H
    #define PCH_H
    #define _AFX_ALL_WARNINGS
    #include <string>
    // For handling config.json for user input
    #include <json/json.h>
    #include <IAgoraRtcEngine.h>
    #include <IAgoraMediaEngine.h>
    #pragma comment(lib, "agora_rtc_sdk.dll.lib")
    #pragma comment(lib, "libagora_segmentation_extension.dll.lib")
    #pragma comment(lib, "libagora-ffmpeg.dll.lib")
    using namespace agora;
    using namespace agora::rtc;
    using namespace agora::media;
    #define WM_MSGID(code) (WM_USER+0x200+code)
    #define EID_USER_JOINED					0x00000003
    #define EID_TOKEN_PRIVILEGE_WILL_EXPIRE	0x00000023
    #endif //PCH_H
    ```

2.  **Declare variables and methods to create an <Vg k="ENGINE" /> instance and join a channel**:

    ```cpp
    class AgoraManager : public IGuiHandler
    {
      public:
      -------
      -------
      void Run();
      virtual void setupVideoSDKEngine();

      virtual void createvideoCanvasAndJoin();
      virtual void join();
      virtual void leave();
      -----
      -----
      public:

      IRtcEngine* agoraEngine = nullptr;
      std::string appId = "";
      std::string channelName = "";
      std::string token = "";
      u_int remoteUId;
      std::shared_ptr<AgoraManagerEventHandler> AgoraEventStrategy;
      int tokenRole = 1; // The token role: Broadcaster or Audience
      std::string serverUrl = "";//"<The base URL to your token server>"; //For example, "https://agora-token-service-production-92ff.up.railway.app"
      int expireTime; //Expire time in Seconds.
      uid_t uid = 1; // An integer that identifies the user
      ------
      ------
    };
    ```

1.  **Configure an <Vg k="ENGINE" /> instance**

        ```cpp
        void AgoraManager::setupVideoSDKEngine()
        {
            // Check if the engine initialized successfully.
            agoraEngine = createAgoraRtcEngine();
            if (!agoraEngine)
            {
                return;
            }
            AgoraEventStrategy->SetMsgReceiver(gui->getGuiWindowReference());

            // Create an instance of RtcEngineContext to initialize the engine.
            RtcEngineContext context;
            // Pass your app ID to the context.
            context.appId = appId.c_str();
            // Pass an object of agoraEventHandler class to receive callbacks.
            context.eventHandler = AgoraEventStrategy.get();
            // Set channel profile in the engine to the CHANNEL_PROFILE_LIVE_BROADCASTING.
            context.channelProfile = CHANNEL_PROFILE_LIVE_BROADCASTING;
            // Initialize the engine using the context variable.
            agoraEngine->initialize(context);
            // Set the user role to Host.
            agoraEngine->setClientRole(CLIENT_ROLE_TYPE::CLIENT_ROLE_BROADCASTER);
        }
        ```


1. **Setup an event handler to receive callbacks**

   You use `IRtcEngineEventHandler` to implement callback functions. You:

        1. Declare an event handler.

            ```cpp
           class AgoraManagerEventHandler : public IRtcEngineEventHandler
            {
            public:
                // Set the message notify window handler
                void SetMsgReceiver(HWND hWnd) { m_hMsgHandler = hWnd; }
                
                virtual HWND getMsgEventHandler() { return m_hMsgHandler; }
                virtual void onJoinChannelSuccess(const char* channel, uid_t uid, int elapsed) override;
                virtual void onUserJoined(uid_t uid, int elapsed) override;
                virtual void onUserOffline(uid_t uid, USER_OFFLINE_REASON_TYPE reason) override;
                virtual void onLeaveChannel(const RtcStats& stats) override;
                virtual void onTokenPrivilegeWillExpire(const char* token) override;
            public:
                HWND m_hMsgHandler;
            };
            ```

        2. Provide definitions for the callbacks you declared in `AgoraManagerEventHandler`:

            ```cpp
            
            void AgoraManagerEventHandler::onJoinChannelSuccess(const char* channel, uid_t uid, int elapsed)
            {
                // Occurs when you join a channel.
            }
            void AgoraManagerEventHandler::onUserOffline(uid_t uid, USER_OFFLINE_REASON_TYPE reason)
            {
                // Occurs when the remote user drops offline or leave the channel.
                MessageBox(NULL, L"Remote user Leave the channel", L"Notification", NULL);

            }
            void AgoraManagerEventHandler::onLeaveChannel(const RtcStats& stats)
            {
                // Occurs when you leave a channel.
                MessageBox(NULL, L"You left the channel", L"Notification", NULL);
            }
            void AgoraManagerEventHandler::onTokenPrivilegeWillExpire(const char* token)
            {
                // Occurs on requesting new token
                MessageBox(NULL, L"Token is about to expire.", L"Notification", NULL);
                HWND MsgEventHandler = getMsgEventHandler();
                if (MsgEventHandler)
                {
                    ::PostMessage(MsgEventHandler, WM_MSGID(EID_TOKEN_PRIVILEGE_WILL_EXPIRE), (WPARAM)token, NULL);
                }
            }
            void AgoraManagerEventHandler::onUserJoined(uid_t uid, int elapsed)
                {
                    HWND MsgEventHandler = getMsgEventHandler();
                    // Send a notification to AgoraManager class to setup a remote video view.
                    if (MsgEventHandler)
                    {
                        ::PostMessage(MsgEventHandler, WM_MSGID(EID_USER_JOINED), (WPARAM)uid, (LPARAM)elapsed);
                    }

                }
            ```

1.  **Render video from a remote user in the channel**:
   
     When a remote user joins the channel, <Vg k = "VSDK"/> triggers `onUserJoined`. You catch this callback and
    retrieve the remote user ID and display the remote video:

        ```cpp
        LRESULT AgoraManager::OnEIDUserJoined(WPARAM wParam, LPARAM lParam)
        {
            // Setup a video canvas to render the remote video.
            VideoCanvas canvas;
            // Choose a video render mode.
            canvas.renderMode = media::base::RENDER_MODE_FIT;
            // Assign the remote user ID to the canvas for identification.
            canvas.uid = wParam;
            // Pass the remote view window handle to canvas to render the remote video.
            canvas.view = gui->remoteView;
            // Render the remote video.
            agoraEngine->setupRemoteVideo(canvas);
            // Save the remote user ID for reuse.
            remoteUId = wParam;
            // Notify the parent window
            HWND hwndParent = GetParent(gui->getGuiWindowReference());

            if (hwndParent != NULL)
            {
                PostMessage(hwndParent, WM_MSGID(EID_USER_JOINED), TRUE, 0);
            }

            return 0;
        }
        ```

7.  **Join a channel to start <Vpd k="PRODUCT" />**:


    ```cpp
    void AgoraManager::createvideoCanvasAndJoin()
    {
        // Check if the engine is successfully initialized.
        if (agoraEngine == NULL)
        {
            MessageBox(NULL, L"Agora SDK Engine is not initialized", L"Error!", MB_ICONEXCLAMATION | MB_OK);
            return;
        }
        // Enable the microphone to create the local audio stream.
        agoraEngine->enableAudio();
        // Enable the local video capturer.
        agoraEngine->enableVideo();
        // Setup a video canvas to render the local video.
        VideoCanvas canvas;
        // Assign the local user ID to canvas for identification.
        canvas.uid = 1;
        // Pass the local view window handle to canvas to render the local video.
        canvas.view = gui->localView;
        // Select a local video source.
        canvas.sourceType = VIDEO_SOURCE_CAMERA;
        // Render the local video.
        agoraEngine->setupLocalVideo(canvas);
        //agora::rtc::uid_t uid = this->uid;
        // Preview the local video.
        agoraEngine->startPreview();
        // Join a channel to start video calling.
        join();
    }
    
    void AgoraManager::join()
    {
        expireTime = config["tokenExpiryTime"].asInt() ? config["tokenExpiryTime"].asInt() : 0;
        serverUrl = config["tokenUrl"].asString();

        if (token == "")
        {
            // Fetch new token 
            token = fetchToken(serverUrl, channelName, tokenRole, uid, expireTime);
            if (token == "")
            {
                MessageBox(NULL, L"Invalid Token : token server fetch failed.", L"Error!", MB_ICONEXCLAMATION | MB_OK);
                return;
            }
        }

        if (0 != agoraEngine->joinChannel(token.c_str(), channelName.c_str(), 0, NULL))
        {
            MessageBox(NULL, L"AgoraManager::joinChannel() error.", L"Error!", MB_ICONEXCLAMATION | MB_OK);
            return;

        }
    }
    ```

1.  **Leave the channel when the local user ends the call**:

    ```cpp
    void AgoraManager::leave()
    {
        // Leave the channel to end the call.
        agoraEngine->leaveChannel();
        // Stop the local video preview.
        agoraEngine->stopPreview();
        // Disable the local video capturer.
        agoraEngine->disableVideo();
        // Disable the local microphone.
        agoraEngine->disableAudio();
    }
    ```


</PlatformWrapper>