<PlatformWrapper platform="android">

<ProductWrapper product="{['interactive-live-streaming', 'broadcast-streaming']}">
![image](/images/video-sdk/ils-call-logic-android.svg)
</ProductWrapper>

<ProductWrapper product="video-calling">
![image](/images/video-sdk/video-call-logic-android.svg)
</ProductWrapper>

Best practice is to separate the <Vpd k="NAME" /> workflows from your UI implementation. The <Vpd  k="SDK" />
  sample project implements <Vpd k="PRODUCT" /> logic in the
  [`AgoraManager`](https://github.com/AgoraIO/video-sdk-samples-android/blob/main/agora-manager/src/main/java/io/agora/agora_manager/AgoraManager.kt) class.
  This class encapsulates the `RTCEngine` instance and core functionality as illustrated by the excerpts below:

1. **Import the <Vpd k="SDK" /> classes and interfaces**

    ``` kotlin
    import io.agora.rtc2.video.VideoCanvas
    import io.agora.rtc2.*
    ```

2.  **Declare variables to create an <Vg k="ENGINE" /> instance and join a channel**

    ``` kotlin
    protected var agoraEngine: RtcEngine? = null // The RTCEngine instance
    protected var mListener: AgoraManagerListener? = null // The event handler for AgoraEngine events
    protected var config: JSONObject? // Configuration parameters from the config.json file
    protected val appId: String // Your App ID from Agora console
    var currentProduct = ProductName.VIDEO_CALLING // The Agora product to test
    var channelName: String // The name of the channel to join
    var localUid: Int // UID of the local user
    var remoteUids = HashSet<Int>() // An object to store uids of remote users
    var isJoined = false // Status of the video call
        private set
    var isBroadcaster = true // Local user role
    ```

3.  **Configure an <Vg k="ENGINE" /> instance and set up an event handler**

    ``` kotlin
    protected open fun setupAgoraEngine(): Boolean {
        try {
            // Set the engine configuration
            val config = RtcEngineConfig()
            config.mContext = mContext
            config.mAppId = appId
            // Assign an event handler to receive engine callbacks
            config.mEventHandler = iRtcEngineEventHandler
            // Create an RtcEngine instance
            agoraEngine = RtcEngine.create(config)
            // By default, the video module is disabled, call enableVideo to enable it.
            agoraEngine!!.enableVideo()
        } catch (e: Exception) {
            sendMessage(e.toString())
            return false
        }
        return true
    }
    ```

4.  **Handle and respond to  <Vg k="ENGINE" /> events**

    ``` kotlin
    protected open val iRtcEngineEventHandler: IRtcEngineEventHandler?
        get() = object : IRtcEngineEventHandler() {
            // Listen for a remote user joining the channel.
            override fun onUserJoined(uid: Int, elapsed: Int) {
                sendMessage("Remote user joined $uid")
                // Save the uid of the remote user.
                remoteUids.add(uid)
                if (isBroadcaster && (currentProduct == ProductName.INTERACTIVE_LIVE_STREAMING
                            || currentProduct == ProductName.BROADCAST_STREAMING)
                ) {
                    // Remote video does not need to be rendered
                } else {
                    // Set up and return a SurfaceView for the new user
                    setupRemoteVideo(uid)
                }
            }

            override fun onJoinChannelSuccess(channel: String, uid: Int, elapsed: Int) {
                // Set the joined status to true.
                isJoined = true
                sendMessage("Joined Channel $channel")
                // Save the uid of the local user.
                localUid = uid
                mListener!!.onJoinChannelSuccess(channel, uid, elapsed)
            }

            override fun onUserOffline(uid: Int, reason: Int) {
                sendMessage("Remote user offline $uid $reason")
                // Update the list of remote Uids
                remoteUids.remove(uid)
                // Notify the UI
                mListener!!.onRemoteUserLeft(uid)
            }

            override fun onError(err: Int) {
                when (err) {
                    ErrorCode.ERR_TOKEN_EXPIRED -> sendMessage("Your token has expired")
                    ErrorCode.ERR_INVALID_TOKEN -> sendMessage("Your token is invalid")
                    else -> sendMessage("Error code: $err")
                }
            }
        }
    ```

5.  **Render video from a remote user in the channel**

    ``` kotlin
    protected fun setupRemoteVideo(remoteUid: Int) {
        // Create a new SurfaceView
        val remoteSurfaceView = SurfaceView(mContext)
        remoteSurfaceView.setZOrderMediaOverlay(true)
        // Create a VideoCanvas using the remoteSurfaceView
        val videoCanvas = VideoCanvas(
            remoteSurfaceView,
            VideoCanvas.RENDER_MODE_FIT, remoteUid
        )
        agoraEngine!!.setupRemoteVideo(videoCanvas)
        // Set the visibility
        remoteSurfaceView.visibility = View.VISIBLE
        // Notify the UI to display the video
        mListener!!.onRemoteUserJoined(remoteUid, remoteSurfaceView)
    }
    ```

6.  **Render video from the local user in the channel**

    ``` kotlin
    val localVideo: SurfaceView
        get() {
            // Create a SurfaceView object for the local video
            val localSurfaceView = SurfaceView(mContext)
            localSurfaceView.visibility = View.VISIBLE
            // Call setupLocalVideo with a VideoCanvas having uid set to 0.
            agoraEngine!!.setupLocalVideo(
                VideoCanvas(
                    localSurfaceView,
                    VideoCanvas.RENDER_MODE_HIDDEN,
                    0
                )
            )
            return localSurfaceView
        }
    ```

7.  **Join a channel to start <Vpd k="PRODUCT" />**

    ``` kotlin
    fun joinChannel(channelName: String, token: String?): Int {
        // Ensure that necessary Android permissions have been granted
        if (!checkSelfPermission()) {
            sendMessage("Permissions were not granted")
            return -1
        }
        this.channelName = channelName

        // Create an RTCEngine instance
        if (agoraEngine == null) setupAgoraEngine()
        val options = ChannelMediaOptions()
        if (currentProduct == ProductName.VIDEO_CALLING || currentProduct == ProductName.VOICE_CALLING) {
            // For a Video/Voice call, set the channel profile as COMMUNICATION.
            options.channelProfile = Constants.CHANNEL_PROFILE_COMMUNICATION
            isBroadcaster = true
        } else {
            // For Live Streaming and Broadcast streaming,
            // set the channel profile as LIVE_BROADCASTING.
            options.channelProfile = Constants.CHANNEL_PROFILE_LIVE_BROADCASTING
            if (currentProduct == ProductName.BROADCAST_STREAMING) {
                // Set Low latency for Broadcast streaming
                if (!isBroadcaster) options.audienceLatencyLevel =
                    Constants.AUDIENCE_LATENCY_LEVEL_LOW_LATENCY
            }
        }

        // Set the client role as BROADCASTER or AUDIENCE according to the scenario.
        if (isBroadcaster) { // Broadcasting Host or Video-calling client
            options.clientRoleType = Constants.CLIENT_ROLE_BROADCASTER
            // Start local preview.
            agoraEngine!!.startPreview()
        } else { // Audience
            options.clientRoleType = Constants.CLIENT_ROLE_AUDIENCE
        }

        // Join the channel with a token.
        agoraEngine!!.joinChannel(token, channelName, localUid, options)
        return 0
    }
    ```

8.  **Leave the channel when the local user ends the call**

    ``` kotlin
    fun leaveChannel() {
        if (!isJoined) {
            sendMessage("Join a channel first")
        } else {
            // To leave a channel, call the `leaveChannel` method
            agoraEngine!!.leaveChannel()
            sendMessage("You left the channel")

            // Set the `joined` status to false
            isJoined = false
            // Destroy the engine instance
            destroyAgoraEngine()
        }
    } 
    ```

1.  **Clean up the resources used by the app**

    ``` kotlin
    protected fun destroyAgoraEngine() {
        // Release the RtcEngine instance to free up resources
        RtcEngine.destroy()
        agoraEngine = null
    }
    ```
</PlatformWrapper>
