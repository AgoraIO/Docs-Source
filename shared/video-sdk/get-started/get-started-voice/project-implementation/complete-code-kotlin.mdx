import CodeBlock from '@theme/CodeBlock';

<CodeBlock language="kotlin" showLineNumbers>
{`import android.Manifest
import android.content.pm.PackageManager
import android.os.Bundle
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import io.agora.rtc2.ChannelMediaOptions
import io.agora.rtc2.Constants
import io.agora.rtc2.IRtcEngineEventHandler
import io.agora.rtc2.RtcEngine
import io.agora.rtc2.RtcEngineConfig

class MainActivity : AppCompatActivity() {

    // Fill in the App ID obtained from the Agora Console
    private val appId = "<#Your App ID#>"
    // Fill in the channel name
    private val channelName = "<#Your channel name#>"
    // Fill in the temporary Token generated from the Agora Console
    private val token = "<#Your Token#>"

    private var mRtcEngine: RtcEngine? = null

    private val mRtcEventHandler = object : IRtcEngineEventHandler() {
        // Callback for successfully joining the channel
        override fun onJoinChannelSuccess(channel: String?, uid: Int, elapsed: Int) {
            super.onJoinChannelSuccess(channel, uid, elapsed)
            runOnUiThread {
                Toast.makeText(this@MainActivity, "Join channel success", Toast.LENGTH_SHORT).show()
            }
        }

        // Callback for when a remote user or host joins the current channel
        override fun onUserJoined(uid: Int, elapsed: Int) {
            super.onUserJoined(uid, elapsed)
            runOnUiThread {
                Toast.makeText(this@MainActivity, "User joined: $uid", Toast.LENGTH_SHORT).show()
            }
        }

        // Callback for when a remote user or host leaves the current channel
        override fun onUserOffline(uid: Int, reason: Int) {
            super.onUserOffline(uid, reason)
            runOnUiThread {
                Toast.makeText(this@MainActivity, "User offline: $uid", Toast.LENGTH_SHORT).show()
            }
        }
    }

    private fun initializeAndJoinChannel() {
        try {
            // Create and configure RtcEngineConfig object
            val config = RtcEngineConfig()
            config.mContext = baseContext
            config.mAppId = appId
            config.mEventHandler = mRtcEventHandler
            // Create and initialize RtcEngine
            mRtcEngine = RtcEngine.create(config)
        } catch (e: Exception) {
            throw RuntimeException("Check the error.")
        }

        // Create and configure ChannelMediaOptions object
        val options = ChannelMediaOptions()
        // Set user role to BROADCASTER (host) or AUDIENCE (audience)
        options.clientRoleType = Constants.CLIENT_ROLE_BROADCASTER
        // Set channel profile to BROADCASTING (live broadcasting scenario)
        options.channelProfile = Constants.CHANNEL_PROFILE_LIVE_BROADCASTING
        // Publish audio captured by the microphone
        options.publishMicrophoneTrack = true
        // Automatically subscribe to all audio streams
        options.autoSubscribeAudio = true
        // Join the channel using temporary Token and channel name, uid of 0 means the engine randomly generates a user ID internally
        // The onJoinChannelSuccess callback will be triggered upon success
        mRtcEngine?.joinChannel(token, channelName, 0, options)
    }

    companion object {
        private const val PERMISSION_REQ_ID = 22
    }

    // Get the permissions required for real-time audio interaction experience
    private fun getRequiredPermissions(): Array<String> {
        // Determine the permissions required when targetSDKVersion is 31 and above
        return if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.S) {
            arrayOf(
                Manifest.permission.RECORD_AUDIO, // Audio recording permission
                Manifest.permission.READ_PHONE_STATE, // Read phone state permission
                Manifest.permission.BLUETOOTH_CONNECT // Bluetooth connection permission
            )
        } else {
            arrayOf(
                Manifest.permission.RECORD_AUDIO
            )
        }
    }

    private fun checkPermissions(): Boolean {
        for (permission in getRequiredPermissions()) {
            val permissionCheck = ContextCompat.checkSelfPermission(this, permission)
            if (permissionCheck != PackageManager.PERMISSION_GRANTED) {
                return false
            }
        }
        return true
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        // If permissions are already granted, initialize RtcEngine and join the channel
        if (checkPermissions()) {
            initializeAndJoinChannel()
        } else {
            ActivityCompat.requestPermissions(this, getRequiredPermissions(), PERMISSION_REQ_ID)
        }
    }

    // System permission request callback
    override fun onRequestPermissionsResult(
        requestCode: Int,
        permissions: Array<out String>,
        grantResults: IntArray
    ) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults)
        if (checkPermissions()) {
            initializeAndJoinChannel()
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        mRtcEngine?.let {
            // Leave the channel
            it.leaveChannel()
            mRtcEngine = null
            // Destroy the engine
            RtcEngine.destroy()
        }
    }
}`}
</CodeBlock>
