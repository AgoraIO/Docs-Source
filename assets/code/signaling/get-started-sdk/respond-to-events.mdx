<PlatformWrapper platform='android'>

    ```kotlin
    protected open val eventListener: RtmEventListener = object : RtmEventListener {
        override fun onMessageEvent(eventArgs: MessageEvent) {
            // Receives Message Events
            mListener?.onSignalingEvent("Message", eventArgs) // notify the UI
        }

        override fun onPresenceEvent(eventArgs: PresenceEvent) {
            // Receives Presence Events
            if (eventArgs.eventType == RtmConstants.RtmPresenceEventType.SNAPSHOT) {
                channelType = eventArgs.channelType
            }
            mListener?.onSignalingEvent("Presence", eventArgs) 
        }

        override fun onTopicEvent(eventArgs: TopicEvent) {
            // Receives Topic Events
            mListener?.onSignalingEvent("Topic", eventArgs) 
        }

        override fun onLockEvent(eventArgs: LockEvent) {
            // Receives Lock Events
            mListener?.onSignalingEvent("Lock", eventArgs) 
        }

        override fun onStorageEvent(eventArgs: StorageEvent) {
            // Receives Storage Events
            mListener?.onSignalingEvent("Storage", eventArgs) 
        }

        override fun onConnectionStateChanged(
            channelName: String?,
            state: RtmConstants.RtmConnectionState?,
            reason: RtmConstants.RtmConnectionChangeReason?
        ) {
            super.onConnectionStateChanged(channelName, state, reason)
        }

        override fun onTokenPrivilegeWillExpire(channelName: String) {
            // Receives Token Privilege Will Expire events
        }
    }
    ```

</PlatformWrapper>

<PlatformWrapper platform={['ios','macos']}>

    ```swift
    extension SignalingManager: RtmClientDelegate {
        public func rtmKit(_ rtmClient: RtmClientKit, didReceiveMessageEvent event: RtmMessageEvent) {
            // received message
        }
        public func rtmKit(_ rtmClient: RtmClientKit, didReceiveTopicEvent event: RtmTopicEvent) {
            // received topic event
        }
        public func rtmKit(_ rtmClient: RtmClientKit, didReceivePresenceEvent event: RtmPresenceEvent) {
            // received presence event
        }
        public func rtmKit(_ rtmClient: RtmClientKit, didReceiveStorageEvent event: RtmStorageEvent) {
            // received storage event
        }
        public func rtmKit(_ rtmClient: RtmClientKit, didReceiveLockEvent event: RtmLockEvent) {
            // received lock event
        }
        public func rtmKit(_ rtmClient: RtmClientKit, tokenPrivilegeWillExpire channel: String?) {
            // current token will expire soon
        }
        public func rtmKit(
            _ rtmClient: RtmClientKit,
            channel: String,
            connectionChangedToState
            state: RtmClientConnectionState,
            reason: RtmClientConnectionChangeReason
        ) {
            // connection state changed
        }
    }
    ```
</PlatformWrapper>

<PlatformWrapper platform='web'>
    The following event listeners handle notification events for <Vg k="SIG" /> features:
    - [Messages](/en/signaling/reference/api#messages): send and receive messages between users
    - [Presence](/en/signaling/reference/api#presence): monitor user online, offline, subscription and user historical  status change
    - [Storage](/en/signaling/reference/api#storage): dynamically set, store, update, and delete channel and user metadata
    - [Topics](/en/signaling/reference/api#topics): subscribe and distribute data streams
    - [Lock](/en/signaling/reference/api#lock): lock a resource when it is shared between different processes
    - [Status](en/signaling/reference/api?platform=web#setstate): add custom statuses such as scores, game status, location, mood, and hosting status for themselves.
    - [token expiration](/en/signaling/reference/api#event-listeners): ensure the users is always connected to <Vg k="SIG" />

    The following code sets up event handlers for <Vg k="SIG" /> events:

    ``` typescript
    // Add listeners to handle event notifications
    // Message event handler
    signalingEngine.addEventListener("message", eventArgs => {
      eventsCallback("message", eventArgs);
      messageCallback(
        "Received message from " +
          eventArgs.publisher +
          ": " +
          eventArgs.message
      );
    });
    // State event handler
    signalingEngine.addEventListener("status", eventArgs => {
      eventsCallback("status", eventArgs);
      messageCallback(
        "Connection state changed to: " +
          eventArgs.state +
          ", Reason: " +
          eventArgs.reason
      );
    });
    // Presence event handler
    signalingEngine.addEventListener("presence", eventArgs => {
      eventsCallback("presence", eventArgs);
      if (eventArgs.eventType === "SNAPSHOT") {
        messageCallback(
          `User ${eventArgs.snapshot[0].userId} joined channel ${eventArgs.channelName}`
        );
      } else {
        messageCallback(
          "Presence event: " +
            eventArgs.eventType +
            ", User: " +
            eventArgs.publisher
        );
      }
    });
    // Storage event handler
    signalingEngine.addEventListener("storage", eventArgs => {
      eventsCallback("storage", eventArgs);
    });
    // Topic event handler
    signalingEngine.addEventListener("topic", eventArgs => {
      eventsCallback("topic", eventArgs);
    });
    // Lock event handler
    signalingEngine.addEventListener("lock", eventArgs => {
      eventsCallback("lock", eventArgs);
    });
    // TokenPrivilegeWillExpire event handler
    signalingEngine.addEventListener("TokenPrivilegeWillExpire", eventArgs => {
      eventsCallback("TokenPrivilegeWillExpire ", eventArgs);
    });  
    ```

</PlatformWrapper>

