<PlatformWrapper platform="react-native">

1. **Implement a client for Video Call**
    
    1. Create the UI

        Create the user interface (UI) for <Vpd k="NAME"/> in the layout file of your project. For <Vpd k="NAME"/>, we recommend adding the following elements into the UI:

        1. The start-call button
        1. The end-call button
        1. The local video view
        1. The remote video view

        You can create a `components` folder under the root directory of your project, add a `Style.ts` file under that folder, and add the code that defines the styles of the UI elements as follows to the file:

        ```typescript
        import {Dimensions, StyleSheet} from 'react-native';

        const dimensions = {
        width: Dimensions.get('window').width,
        height: Dimensions.get('window').height,
        };

        export default StyleSheet.create({
        max: {
            flex: 1,
        },
        buttonHolder: {
            height: 100,
            alignItems: 'center',
            flex: 1,
            flexDirection: 'row',
            justifyContent: 'space-evenly',
        },
        button: {
            paddingHorizontal: 20,
            paddingVertical: 10,
            backgroundColor: '#0093E9',
            borderRadius: 25,
        },
        buttonText: {
            color: '#fff',
        },
        fullView: {
            width: dimensions.width,
            height: dimensions.height - 100,
        },
        remoteContainer: {
            width: '100%',
            height: 150,
            position: 'absolute',
            top: 5,
        },
        remote: {
            width: 150,
            height: 150,
            marginHorizontal: 2.5,
        },
        noUserText: {
            paddingHorizontal: 10,
            paddingVertical: 5,
            color: '#0093E9',
        },
        });
        ```

    1. Import classes

        Open the `App.tsx` file, and delete all code. Add the following code to the beginning of the `App.tsx` file:

        ```typescript
        import React, {Component} from 'react';

        // Import the React Native classes into your project.
        import {
        Platform,
        Text,
        TouchableOpacity,
        View,
        PermissionsAndroid,
        ScrollView,
        } from 'react-native';

        // Import the Agora SDK classes into your project.
        import {
        ClientRoleType,
        createAgoraRtcEngine,
        IRtcEngine,
        RtcConnection,
        RtcEngineContext,
        RtcStats,
        RtcSurfaceView,
        UserOfflineReasonType,
        } from 'react-native-agora-rtc-ng';

        // Import the UI styles.
        import styles from './components/Style';
        ```

    1. Add project permissions
    
        1. Android
            Add the following code to the `App.tsx` file to set a prompt box for getting permissions to use the microphone and camera on an Android device:

            ```typescript
            const requestCameraAndAudioPermission = async () => {
            try {
                const granted = await PermissionsAndroid.requestMultiple([
                PermissionsAndroid.PERMISSIONS.CAMERA,
                PermissionsAndroid.PERMISSIONS.RECORD_AUDIO,
                ]);
                if (
                granted['android.permission.RECORD_AUDIO'] ===
                    PermissionsAndroid.RESULTS.GRANTED &&
                granted['android.permission.CAMERA'] ===
                    PermissionsAndroid.RESULTS.GRANTED
                ) {
                console.log('You can use the cameras & mic');
                } else {
                console.log('Permission denied');
                }
            } catch (err) {
                console.warn(err);
            }
            };
            ```
        1. iOS
            In Xcode, open the info.plist file. Add the following contents to add permissions for your device:

            | Key 	                                 | Type   | Value                                                                                       |
            |----------------------------------------|--------|---------------------------------------------------------------------------------------------|
            | Privacy - Microphone Usage Description | String | The purpose for accessing the microphone, such as for a call or interactive live streaming. |
            | Privacy - Camera Usage Description     | String | The purpose for accessing the camera, such as for a call or interactive live streaming.     |

    1. Create an App Component

        When creating an App component, you need to define your `App ID`, `token`, and `channel name`, which will be used for initializing the RtcEngine object and joining the channel.

        - appId: The App ID of your Agora project. See [Get an App ID](../reference/manage-agora-account#get-the-app-id) for details.

        - channelName: The unique channel name for the AgoraRTC session. Users with the same App ID and channel name can join the same channel.

        - token: Pass a token that identifies the role and privilege of the user. The token must be generated using the preceding App ID and channel name. You can set it to one of the following values:
            A temporary token generated in Console. A temporary token is valid for 24 hours. For details, see [Get a Temporary Token](../reference/manage-agora-account#generate-a-temporary-token).
            A token generated at the server. This applies to scenarios with high-security requirements. For details, see Generate a token from Your Server.

        If your project has enabled the app certificate, ensure that you provide a token.

        Add the following code to the `App.tsx` file to create variables for initializing RtcEngine and joining a channel.

        ```typescript
        // Define a Props interface.
        interface Props {}

        // Define a State interface.
        interface State {
        appId: string;
        channelName: string;
        token: string;
        joinSucceed: boolean;
        peerIds: number[];
        }

        // Create an App component, which extends the properties of the Pros and State interfaces.
        export default class App extends Component<Props, State> {
            _engine?: IRtcEngine;
            _rtcContext?: RtcEngineContext;

            // Add a constructorï¼Œand initialize this.state. You need:
            // Replace yourAppId with the App ID of your Agora project.
            // Replace yourChannel with the channel name that you want to join.
            // Replace yourToken with the token that you generated using the App ID and channel name above.
            constructor(props: Props | Readonly<Props>) {
                super(props);
                this.state = {
                appId: '<app-id>',
                channelName: '<channel-name>',
                token: '<token>',
                joinSucceed: false,
                peerIds: [],
                };
                if (Platform.OS === 'android') {
                requestCameraAndAudioPermission().then(() => {
                    console.log('requested!');
                });
                }
            }
            // Other code. See next steps.
        }
        ```

    1. Initialize RtcEngine

        Create and initialize the RtcEngine object before calling any other Agora APIs. Add the following code after the `// Other code line` in `App.tsx`:
        <ProductWrapper product="video-calling">
            ```typescript
            // Mount the App component into the DOM.
            componentDidMount() {
                this.init();
            }

            // When the component is being uninstalled
            componentWillUnmount() {
                this._engine?.unregisterEventHandler(this);
                this._engine?.release();
            }

            // Pass in your App ID through this.state, create and initialize an RtcEngine object.
            init = async () => {
                const {appId} = this.state;
                this._engine = await createAgoraRtcEngine();
                this._rtcContext = new RtcEngineContext();
                this._rtcContext.appId = appId;
                this._engine?.initialize(this._rtcContext);
                // Enable the video module.
                await this._engine.enableVideo();
                // Enable the local video preview.
                await this._engine.startPreview();
            };

            //Listens for the joining channel event of the local user
            onJoinChannelSuccess(connection: RtcConnection, elapsed: number) {
                console.info(
                'onJoinChannelSuccess',
                'connection',
                connection,
                'elapsed',
                elapsed,
                );
                this.setState({joinSucceed: true});
            }

            //Listens for the leaving channel event of the local user
            onLeaveChannel(connection: RtcConnection, stats: RtcStats) {
                console.info('onLeaveChannel', 'connection', connection, 'stats', stats);
                this.setState({joinSucceed: false, peerIds: []});
            }

            //Listens for the joining channel event of the remote user
            onUserJoined(connection: RtcConnection, remoteUid: number, elapsed: number) {
                console.info(
                'onUserJoined',
                'connection',
                connection,
                'remoteUid',
                remoteUid,
                'elapsed',
                elapsed,
                );
                const {peerIds} = this.state;
                this.setState({
                peerIds: [...peerIds, remoteUid],
                });
            }

            //Listens for the leaving channel event of the remote user
            onUserOffline(
                connection: RtcConnection,
                remoteUid: number,
                reason: UserOfflineReasonType,
            ) {
                console.info(
                'onUserOffline',
                'connection',
                connection,
                'remoteUid',
                remoteUid,
                'reason',
                reason,
                );
                const {peerIds} = this.state;
                this.setState({
                peerIds: peerIds.filter(value => value !== remoteUid),
                });
            }
            ```
        </ProductWrapper>

        <ProductWrapper product="interactive-live-streaming">
            ```typescript
            // Mount the App component into the DOM.
            componentDidMount() {
                this.init()
            }
            // Pass in your App ID through this.state, create and initialize an RtcEngine object.
            init = async () => {
                const {appId} = this.state
                this._engine = await RtcEngine.create(appId)
                // Enable the video module.
                await this._engine.enableVideo()
                // Enable the local video preview.
                await this._engine.startPreview()
                // Set the channel profile as live streaming.
                await this._engine.setChannelProfile(ChannelProfile.LiveBroadcasting)
                // Set the usr role as host.
                await this._engine.setClientRole(ClientRole.Broadcaster)

                // Listen for the UserJoined callback.
                // This callback occurs when the remote user successfully joins the channel.
                this._engine.addListener('UserJoined', (uid, elapsed) => {
                    console.log('UserJoined', uid, elapsed)
                    const {peerIds} = this.state
                    if (peerIds.indexOf(uid) === -1) {
                        this.setState({
                            peerIds: [...peerIds, uid]
                        })
                    }
                })

                // Listen for the UserOffline callback.
                // This callback occurs when the remote user leaves the channel or drops offline.
                this._engine.addListener('UserOffline', (uid, reason) => {
                    console.log('UserOffline', uid, reason)
                    const {peerIds} = this.state
                    this.setState({
                        // Remove peer ID from state array
                        peerIds: peerIds.filter(id => id !== uid)
                    })
                })

                // Listen for the JoinChannelSuccess callback.
                // This callback occurs when the local user successfully joins the channel.
                this._engine.addListener('JoinChannelSuccess', (channel, uid, elapsed) => {
                    console.log('JoinChannelSuccess', channel, uid, elapsed)
                    this.setState({
                        joinSucceed: true
                    })
                })
            }
            ```
        </ProductWrapper>

    1. Join a channel

        After initializing the `RtcEngine` object, you can call `joinChannel` to join a channel. Add this after the `init = async () => {` code block:

        ```typescript
        // Pass in your token and channel name through this.state.token and this.state.channelName.
        // Set the ID of the local user, which is an integer and should be unique. If you set uid as 0,
        // the SDK assigns a user ID for the local user and returns it in the JoinChannelSuccess callback.
        // Sets the client role to host and pass in your token, channel name and user ID to join a channel.
        // You need to specify the uid of the local user and ensure it's unique in the channel.
        startCall = () => {
            const {channelName, token} = this.state;
            this._engine?.joinChannelWithOptions(token, channelName, 0, {
            clientRoleType: ClientRoleType.ClientRoleBroadcaster,
            });
        };
        ```

    1. Render UI elements

        Call the `render()` method in the App component to render the UI elements and handle the button click event. Add the following code after `startCall` to the `App.tsx` file.

        ```typescript
        render() {
            return (
            <View style={styles.max}>
                <View style={styles.max}>
                <View style={styles.buttonHolder}>
                    <TouchableOpacity onPress={this.startCall} style={styles.button}>
                    <Text style={styles.buttonText}> Start Call </Text>
                    </TouchableOpacity>
                    <TouchableOpacity onPress={this.endCall} style={styles.button}>
                    <Text style={styles.buttonText}> End Call </Text>
                    </TouchableOpacity>
                </View>
                {this._renderVideos()}
                </View>
            </View>
            );
        }
        ```
    
    1. Render the local video view

        Configure the video view of the local user. After joining the channel, the user can see themselves. You can also call `startPreview` to start the local video preview before joining the channel. Add the following code after `render()` in `App.tsx`:
        ```typescript
        _renderVideos = () => {
            const {joinSucceed} = this.state;
            return joinSucceed ? (
            <View style={styles.fullView}>
                <RtcSurfaceView style={styles.max} canvas={{uid: 0}} />
            </View>
            ) : null;
        };
        ```

    1. Render the remote video view

        In a <Vpd k="NAME"/>, you should be able to see other users. After joining the channel, pass in the uid of the remote user sending the video, and set the video view of the remote user. Add the following code after `_renderVideos()` in `App.tsx`:

        ```typescript
        _renderRemoteVideos = () => {
            const {peerIds} = this.state;
            return (
            <ScrollView
                style={styles.remoteContainer}
                contentContainerStyle={{paddingHorizontal: 2.5}}
                horizontal={true}>
                {peerIds.map((value, index, _array) => {
                return (
                    <RtcSurfaceView
                    key={`${value}-${index}`}
                    style={styles.remote}
                    zOrderMediaOverlay={true}
                    canvas={{uid: value}}
                    />
                );
                })}
            </ScrollView>
            );
        };
        ```
    
    1. Leave the channel

        Call `leaveChannel` to leave the current channel according to your scenario. For example, when the <Vpd k="NAME"/> ends, when you need to close the app, or when your app runs in the background. Add the following code after `_renderRemoteVideos()` in `App.tsx`:

        ```typescript
        endCall = () => {
            this._engine?.leaveChannel();
        };
        ```

    1. Release resources

        When the user closes the <Vpl k="CLIENT" />, release all resources used by the Agora SDK. Add the following code after `componentDidMount()` in the `App.tsx` file.

        ```typescript
        // When the component is being uninstalled
        componentWillUnmount() {
            this._engine?.unregisterEventHandler(this);
            this._engine?.release();
        }
        ```
</PlatformWrapper>