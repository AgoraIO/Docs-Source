<PlatformWrapper platform="web">

1. **Import the <Vpd k="SDK" /> classes and interfaces**:

    ```javascript
    import AgoraRTCManager from "../agora_manager/agora_manager.js";
    ```

1.  **Add the required variables**

    In `agora_manager_channel_encryption.js`, add the following after `const AgoraRTCChannelEncryption = async (eventsCallback) => {`:

    ``` javascript
    // In a production environment, you retrieve the key and salt from
    // an authentication server. For this code example you generate locally.

    var encryptionKey = "";
    var encryptionSaltBase64 = "";
    var encryptionMode = "";
    ```

2.  **Add a method to convert a string from `Base64` to `Uint8Array`**

    In `agora_manager_channel_encryption.js`, add the following code after variable declarations in `AgoraRTCChannelEncryption`:

    ``` javascript
    function base64ToUint8Array(base64Str)
    {
      const raw = window.atob(base64Str);
      const result = new Uint8Array(new ArrayBuffer(raw.length));
      for (let i = 0; i < raw.length; i += 1)
      {
        result[i] = raw.charCodeAt(i);
      }
      return result;
    }
    ```

3.  **Add a method to convert a string from `Hex` to `ASCII`**

    In `agora_manager_channel_encryption.js`, add the following code before `base64ToUint8Array`:

    ``` javascript
    function hex2ascii(hexx)
    {
      const hex = hexx.toString();//force conversion
      let str = '';
      for (let i = 0; i < hex.length; i += 2)
        str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
      return str;
    }
    ```

4.  **Call the channel encryption methods to enable channel encryption**

    To enable channel encryption in your <Vpl k="CLIENT" />, you need to:

    1.  Convert `encryptionSaltBase64` to `base64ToUint8Array`.

    2.  Convert `encryptionKey` to `hex2ascii`.

    3.  Set the `encryptionMode` variable to a encryption mode.

    4.  Call `setEncryptionConfig` and pass `encryptionMode`, `encryptionKey`, and `encryptionSaltBase64` as parameters.

    In `agora_manager_channel_encryption.js`, add the following code after `hex2ascii`:

    ``` javascript
    // Convert the encryptionSaltBase64 string to base64ToUint8Array.
    encryptionSaltBase64 = base64ToUint8Array(config.salt);
    // Convert the encryptionKey string to hex2ascii.
    encryptionKey = hex2ascii(config.cipherKey);
    // Set an encryption mode.
    encryptionMode = config.encryptionMode;

    agoraManager
      .getAgoraEngine()
      .setEncryptionConfig(encryptionMode, encryptionKey, encryptionSaltBase64);
    ```

## Add End-to-End encryption

1. **Enable end-to-end encryption**

    - Add a new joining method called `joinWithE2EEncryption`.
    - Enable the encoded transform function by setting the `ENABLE_ENCODED_TRANSFORM` parameter to `true`.
    - Obtain an `RTCRtpTransceiver` object and establish a WebRTC Encoded Transform processing pipeline on the streaming end using `setEncryptionStream`.
    - In the UI, add an input for user to put in a `password`.

    The implement the above, add the following code in the `AgoraRTCChannelEncryption` function in `agora_manager_channel_encryption.js`:

    ```javascript
    const joinWithE2EEncryption = async (
      localPlayerContainer,
      channelParameters,
      password
    ) => {
      AgoraRTC.setParameter("ENABLE_ENCODED_TRANSFORM", true);
      await agoraManager
        .getAgoraEngine()
        .join(config.appId, config.channelName, config.token, config.uid);
      // Create a local audio track from the audio sampled by a microphone.
      channelParameters.localAudioTrack =
        await AgoraRTC.createMicrophoneAudioTrack();
      // Create a local video track from the video captured by a camera.
      channelParameters.localVideoTrack = await AgoraRTC.createCameraVideoTrack();
      // Append the local video container to the page body.
      document.body.append(localPlayerContainer);
      // Publish the local audio and video tracks in the channel.
      await agoraManager
        .getAgoraEngine()
        .publish([
          channelParameters.localAudioTrack,
          channelParameters.localVideoTrack,
        ]);
      const transceiver =
        channelParameters.localVideoTrack.getRTCRtpTransceiver();
      if (!transceiver || !transceiver.sender) {
        return;
      }
      const sender = transceiver.sender;

      var browserName = (function (agent) {
        switch (true) {
          case agent.indexOf("chrome") > -1 && !!window.chrome:
            return "Chrome";
          default:
            return "other";
        }
      })(window.navigator.userAgent.toLowerCase());

      if (browserName === "Chrome") {
        setEncryptionStream(sender, password);
      }
      // Play the local video track.
      channelParameters.localVideoTrack.play(localPlayerContainer);
    };

    async function setEncryptionStream(sender, password) {
      const streams = sender.createEncodedStreams();
      const transformer = new TransformStream({
        async transform(chunk, controller) {
          // controller.enqueue(chunk);
          //   return;

          const originView = new Uint8Array(chunk.data);

          let reservedSize = 40;

          const naluType = originView[4] & 0x1f;
          console.log(naluType);
          if (naluType !== 7) {
            reservedSize = 5;
          }

          const payload = originView.subarray(reservedSize, originView.length);
          const hashKey = await grindKey(password, 10);
          const key = await window.crypto.subtle.importKey(
            "raw",
            hashKey,
            {
              name: "AES-GCM",
            },
            false,
            ["encrypt"]
          );

          const iv = await getIv(password);

          const ciphertext = await window.crypto.subtle.encrypt(
            {
              name: "AES-GCM",
              iv: iv,
              tagLength: 128,
            },
            key,
            payload
          );

          const encryptedView = new Uint8Array(
            ciphertext.byteLength + reservedSize + 12
          );
          encryptedView.set(originView.subarray(0, reservedSize));
          encryptedView.set(iv, reservedSize);
          encryptedView.set(new Uint8Array(ciphertext), reservedSize + 12);
          chunk.data = encryptedView.buffer;

          controller.enqueue(chunk);
        },
      });

      streams.readable.pipeThrough(transformer).pipeTo(streams.writable);
    }
    ```

2. **Enable end-to-end decryption**

    - Obtain an `RTCRtpTransceiver` object and establish a WebRTC Encoded Transform processing pipeline on the receiver end using `setDecryptionStream`.
    - On `user-published` callback, call `setDecryptionStream` before calling `play()`.
    - Have the same password input in UI that was used from the streamer's end for encryption.

    The implement the above, add the following code in the `AgoraRTCChannelEncryption` function in `agora_manager_channel_encryption.js`:

    ```javascript
    async function setDecryptionStream(receiver, password) {
      const streams = receiver.createEncodedStreams();
      const transformer = new TransformStream({
        async transform(chunk, controller) {
          // controller.enqueue(chunk);
          //   return;

          const originView = new Uint8Array(chunk.data);

          let reservedSize = 40;

          const naluType = originView[4] & 0x1f;
          if (naluType !== 7) {
            // controller.enqueue(chunk);
            // return;
            reservedSize = 5;
          }

          const hashKey = await grindKey(password, 10);
          const key = await window.crypto.subtle.importKey(
            "raw",
            hashKey,
            {
              name: "AES-GCM",
            },
            false,
            ["decrypt"]
          );

          const header = originView.subarray(0, reservedSize);
          const iv = originView.subarray(reservedSize, reservedSize + 12);
          const payload = originView.subarray(
            reservedSize + 12,
            chunk.data.byteLength
          );

          let decrypted = null;
          try {
            decrypted = await window.crypto.subtle.decrypt(
              {
                name: "AES-GCM",
                iv: iv,
                tagLength: 128,
              },
              key,
              payload
            );
          } catch (e) {
            console.log(e);
            controller.enqueue(chunk);
            return;
          }

          const decryptedView = new Uint8Array(
            decrypted.byteLength + reservedSize
          );
          decryptedView.set(header);
          decryptedView.set(new Uint8Array(decrypted), reservedSize);
          chunk.data = decryptedView.buffer;

          controller.enqueue(chunk);
        },
      });

      streams.readable.pipeThrough(transformer).pipeTo(streams.writable);
    }
    ```

    In `channel_encryption.js`, add the following code after `setupProjectSelector();`:

    ```javascript
    const handleVSDKEvents = (eventName, ...args) => {
      switch (eventName) {
        case "user-published":
          var browserName = (function (agent) {
            switch (true) {
              case agent.indexOf("chrome") > -1 && !!window.chrome:
                return "Chrome";
              default:
                return "other";
            }
          })(window.navigator.userAgent.toLowerCase());

          if (browserName === "Chrome") {
            const transceiver =
              channelParameters.remoteVideoTrack.getRTCRtpTransceiver();
            if (!transceiver || !transceiver.receiver) {
              return;
            }
            password = document.getElementById("password").value.toString();
            setDecryptionStream(transceiver.receiver, password);
          }
          if (args[1] == "video") {
            // Retrieve the remote video track.
            channelParameters.remoteVideoTrack = args[0].videoTrack;
            // Retrieve the remote audio track.
            channelParameters.remoteAudioTrack = args[0].audioTrack;
            // Save the remote user id for reuse.
            channelParameters.remoteUid = args[0].uid.toString();
            // Specify the ID of the DIV container. You can use the uid of the remote user.
            remotePlayerContainer.id = args[0].uid.toString();
            channelParameters.remoteUid = args[0].uid.toString();
            remotePlayerContainer.textContent =
              "Remote user " + args[0].uid.toString();
            // Append the remote container to the page body.
            document.body.append(remotePlayerContainer);
            // Play the remote video track.
            channelParameters.remoteVideoTrack.play(remotePlayerContainer);
          }
          // Subscribe and play the remote audio track If the remote user publishes the audio track only.
          if (args[1] == "audio") {
            // Get the RemoteAudioTrack object in the AgoraRTCRemoteUser object.
            channelParameters.remoteAudioTrack = args[0].audioTrack;
            // Play the remote audio track. No need to pass any DOM element.
            channelParameters.remoteAudioTrack.play();
          }
      }
    };
    ```

</PlatformWrapper>
