    You persist the existing session by retrieving a fresh token and calling `renewToken`.
<PlatformWrapper platform='android'>

    ```kotlin
    protected fun handleTokenExpiry() {
        notify("Token is about to expire")
        // Fetch a new token
        fetchToken(object : TokenCallback {
            override fun onTokenReceived(token: String?) {
                // Use the token to renew authentication
                signalingEngine!!.renewToken(token, object: ResultCallback<Void?> {
                    override fun onFailure(errorInfo: ErrorInfo?) {
                        notify("Failed to renew token")
                    }

                    override fun onSuccess(responseInfo: Void?) {
                        notify("Token renewed")
                    }
                })
            }

            override fun onError(errorMessage: String) {
                // Handle the error
                notify("Error fetching token: $errorMessage")
            }
        })
    }
    ```

</PlatformWrapper>

<PlatformWrapper platform={['ios','macos']}>

    ```swift
    public func rtmKit(_ rtmClient: RtmClientKit, tokenPrivilegeWillExpire channel: String?) {
        Task {
            let token = try await self.fetchToken(from: self.tokenUrl, username: self.userId)
            try await signalingEngine.renewToken(token)
        }
    }
    ```
</PlatformWrapper>

<PlatformWrapper platform = 'web'>

    ``` javascript
      const renewToken = async (uid) => {
        const token = await fetchToken(uid);
        const result = await signalingManager
          .getSignalingEngine()
          .renewToken(token);
        messageCallback("Token was about to expire so it was renewed...");
      };
    ```
      
</PlatformWrapper>

