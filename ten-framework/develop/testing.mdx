---
title: 'Testing'
sidebar_position: 13
type: docs
description: >
  Profile your TEN app and analyze the performance data.
---


## For Developers of TEN framework

The TEN framework includes the following types of test suites:

- Unit tests
- Smoke tests
- Integration tests

The framework uses `gtest` for unit and smoke tests, and `pytest` for integration tests.

### Unit Tests

The source directory for unit tests is `tests/ten_runtime/unit`. To add new unit test cases, place them in the `tests/ten_runtime/unit` directory.

For C++ projects, after the build completes, go to the output directory based on your target operating system and CPU. For example, use `out/linux/x64/tests/standalone`. Then run the following command:

```shell
./ten_runtime_unit_test
```

### Smoke Tests

The source directory for smoke tests is `tests/ten_runtime/smoke`. To add new test cases, place them in the same directory.

After the build completes, go to the output directory based on your target operating system and CPU. For example, use `out/linux/x64/tests/standalone`. Then run the following command:

```shell
./ten_runtime_smoke_test
```

### Loop Testing

You can perform multiple rounds of testing using the following commands.

To run only unit tests:

```shell
failed=0; for i in {1..100}; do if [ ${failed} != 0 ]; then echo "error occurred:" ${failed}; break; fi; ./ten_runtime_unit_test; failed=$?; done;
```

To run only smoke tests:

```shell
failed=0; for i in {1..100}; do if [ ${failed} != 0 ]; then echo "error occurred:" ${failed}; break; fi; ./ten_runtime_smoke_test; failed=$?; done;
```

To run both unit tests and smoke tests:

```shell
failed=0; for i in {1..100}; do if [ ${failed} != 0 ]; then echo "error occurred:" ${failed}; break; fi; ./ten_runtime_unit_test; failed=$?; if [ ${failed} != 0 ]; then echo "error occurred:" ${failed}; break; fi; ./ten_runtime_smoke_test; failed=$?; done;
```

### Integration Tests

Integration tests are black-box tests for the TEN framework. The source directory is `tests/ten_runtime/integration`. Use these tests to validate real-world execution scenarios.

The directory structure is as follows:

```text
tests/ten_runtime/integration/
  ├── test_1/
  │    ├── test_case.py
  │    └── ...
  ├── test_2/
  │    ├── test_case.py
  │    └── ...
  └── ...
```

To execute the integration tests, use the following command:

```shell
cd path/to/out/
pytest tests/ten_runtime/integration/
```

### Testing Tricks

#### Linux

To help trigger timing-related bugs, you can slow down the execution of TEN using the following method:

```shell
sudo apt install util-linux
cpulimit -f -l 50 -- taskset 0x3 ...
```

- `taskset 0x1`: Runs the program on 1 CPU core.
- `taskset 0x3`: Runs the program on 2 CPU cores.


## For Users of the TEN Framework

### Standalone testing of extensions

The TEN framework provides a standalone extension testing mechanism that allows you to test individual extensions without relying on other TEN components, such as other extensions, graphs, or apps. This is especially useful when you need to verify an extension’s behavior without running the entire TEN app.

The standalone testing framework follows three key principles:

1. **Works with any native testing framework used by the extension’s language**  
   For example, if an extension is written in C++, you can use the Google gtest/gmock framework together with the standalone testing framework to test it independently.

2. **Requires no changes to the extension code under test**  
   You can test the exact same code used at runtime without modification.

3. **Provides a consistent design and usage model across languages**  
   Once you learn the testing workflow for one language, you can apply the same concepts to test extensions written in other languages.

For users, the TEN extension standalone testing framework introduces two main concepts:

1. **extension_tester**
2. **ten_env_tester**

The role of **extension_tester** is similar to a testing driver, responsible for setting up and executing the entire testing process. **ten_env_tester**, on the other hand, behaves like a typical TEN extension's `ten_env` instance, enabling users to invoke functionalities within the standalone testing framework from the callback of `extension_tester`, such as sending messages to the extension under test and receiving messages from the extension.

From the API design of **extension_tester** and **ten_env_tester**, you can see that they are very similar to **TEN extension** and **ten_env**, and this is by design. The main purpose is to allow users familiar with extension development to quickly get accustomed to the standalone testing framework and then develop standalone test cases for the extension itself.

However, for testing purposes, there are inevitably APIs and features dedicated specifically to testing. To prevent these test-specific functionalities and APIs, which are not needed during actual runtime, from polluting the runtime API set, the standalone testing framework is designed not to directly use or extend the API sets of **extension** and **ten_env**. Instead, it introduces types and API sets that are exclusive to standalone testing. This separation ensures that the types and API sets used in actual runtime and those used during testing do not interfere with each other, avoiding any negative side effects.

For users, the TEN extension standalone testing framework introduces two main concepts:

1. `extension_tester`
2. `ten_env_tester`

The `extension_tester` serves as a testing driver, responsible for setting up and executing the entire testing process. In contrast, `ten_env_tester` acts like a typical TEN extension's `ten_env` instance. It enables users to invoke functionalities within the standalone testing framework from the callback of `extension_tester`, such as sending messages to and receiving messages from the extension under test.

The API design of `extension_tester` and `ten_env_tester` mirrors that of TEN extension and `ten_env`, which is intentional. This design helps users familiar with extension development quickly get accustomed to the standalone testing framework and efficiently develop standalone test cases for their extensions.

However, for testing purposes, certain APIs and features are dedicated exclusively to testing. To prevent these test-specific APIs and functionalities, which are not required during runtime, from affecting the runtime API set, the standalone testing framework is designed not to directly use or extend the APIs of extension and `ten_env`. Instead, it introduces types and APIs exclusive to standalone testing. This separation ensures that the runtime and testing APIs remain independent, avoiding potential conflicts.

### Standalone testing framework internal workings

Internally, the TEN extension standalone testing framework automatically starts a test app, loads the extension to be tested (referred to as extension A), and initializes a graph containing both extension A and another extension (extension B) used for testing other extensions. All input and output messages from extension A are redirected to extension B, allowing users to customize inputs and outputs during the testing process and complete the testing.

![](/images/ten-framework/testing-framework.png)

Think of the testing extension within the framework as a proxy between the extension being tested and the tester. It functions as a proxy extension within the TEN graph, facilitating message exchanges between the tested extension and the tester using the TEN environment's language.

### Basic testing process

The basic testing process and logic are as follows:

1. Create an extension tester to manage the entire standalone testing process.
2. Inform the standalone testing framework of the folder containing the extension to be tested.
3. Set the testing mode, such as the mode for testing a single extension.
4. Start the testing.

- **C++**

    Following is an example of TEN extension standalone testing using Google `gtest`:

    ```cpp
    class `extension_tester`_basic : public ten::extension_tester_t {
    public:
        void on_start(ten::ten_env_tester_t &ten_env) override {
            auto new_cmd = ten::cmd_t::create("hello_world");
            ten_env.send_cmd(std::move(new_cmd),
                            [](ten::ten_env_tester_t &ten_env,
                            std::unique_ptr<ten::cmd_result_t> result) {
                                if (result->get_status_code() == TEN_STATUS_CODE_OK) {
                                    ten_env.stop_test();
                                }
                            });
        }
    };

    TEST(Test, Basic) {
        // 1. Create an extension tester to manage the entire standalone testing process.
        auto *tester = new `extension_tester`_basic();
        // 2. Set a testing mode, such as a mode for testing a single extension.
        tester->set_test_mode_single("default_extension_cpp");
        // 3. Start the testing.
        tester->run();
        delete tester;
    }
    ```

{/*
- **Golang**

TODO: To be added.
*/}

- **Python**

    ```python
    class ExtensionTesterBasic(ExtensionTester):
        def check_hello(self, ten_env: TenEnvTester, result: CmdResult):
            statusCode = result.get_status_code()
            print("receive hello_world, status:" + str(statusCode))
            if statusCode == StatusCode.OK:
                ten_env.stop_test()
                
        def on_start(self, ten_env: TenEnvTester) -> None:
            new_cmd = Cmd.create("hello_world")
            print("send hello_world")
            ten_env.send_cmd(
                new_cmd,
                lambda ten_env, result: self.check_hello(ten_env, result),
            )
            print("tester on_start_done")
            ten_env.on_start_done()


    def test_basic():
        # 1. Create an extension tester to manage the entire standalone testing process.
        tester = ExtensionTesterBasic()
        # 2. Set a testing mode, such as a mode for testing a single extension.
        tester.set_test_mode_single("default_extension_python")
        # 3. Start the testing.
        tester.run()
    ```