import CodeBlock from '@theme/CodeBlock';
import CodeRtcPy from '@docs/assets/code/open-ai-integration/rtc-py.mdx'

<PlatformWrapper platform="python">

### Import Agora classes

Import the relevant Agora SDK classes and interfaces:

```python
from agora.rtc.agora_base import (
    ChannelProfileType,
    ClientRoleType,
)
from agora.rtc.agora_service import (
    AgoraService,
    AgoraServiceConfig,
    RTCConnConfig,
)
from agora.rtc.audio_frame_observer import AudioFrame, IAudioFrameObserver
from agora.rtc.audio_pcm_data_sender import PcmAudioFrame
from agora.rtc.local_user import LocalUser
from agora.rtc.local_user_observer import IRTCLocalUserObserver
from agora.rtc.rtc_connection import RTCConnection, RTCConnInfo
from agora.rtc.rtc_connection_observer import IRTCConnectionObserver
```

### Initialize the engine

The following code defines the `RtcEngine` class, which initializes and configures the `AgoraService`. The class constructor takes an `appid` as input, configures the Agora service, and initializes it. You use the `RtcEngine` class to interact with the Agora SDK in this demo.

```python
class RtcEngine:
    def __init__(self, appid: str):
        self.appid = appid
        config = AgoraServiceConfig()
        config.appid = appid
        config.log_path = os.path.join(
            os.path.dirname(
                os.path.dirname(
                    os.path.dirname(os.path.join(os.path.abspath(__file__)))
                )
            ),
            "agorasdk.log",
        )
        self.agora_service = AgoraService()
        self.agora_service.initialize(config)
```

### Join a channel

To asynchronously join a channel, implement a `Channel` class. When you create an instance of the class, the initializer sets up the necessary components for joining a channel. It takes an instance of `RtcEngine`, a `channelId`, and a `uid` as parameters. During initialization, the code creates an event emitter, configures the connection for broadcasting, and registers an event observer for channel events. It also sets up the local user’s audio configuration to enable audio streaming.

<Admonition type="info" title="Note">
UIDs in the Python SDK are set using a string value. Agora recommends using only numerical values for UID strings to ensure compatibility with all Agora products and extensions.
</Admonition>

```python
class Channel():
    def __init__(
        self, rtc: "RtcEngine", channelId: str, uid: str
    ) -> None:
        self.loop = asyncio.get_event_loop()

        # Create the event emitter
        self.emitter = AsyncIOEventEmitter()

        self.rtc = rtc
        self.chat = Chat(self)
        self.channelId = channelId
        self.uid = uid
        conn_config = RTCConnConfig(
            client_role_type=ClientRoleType.CLIENT_ROLE_BROADCASTER,
            channel_profile=ChannelProfileType.CHANNEL_PROFILE_LIVE_BROADCASTING,
        )
        self.connection = self.rtc.agora_service.create_rtc_connection(conn_config)

        self.channel_event_observer = ChannelEventObserver(self.emitter)    
        self.connection.register_observer(self.channel_event_observer)
        self.connection.connect("", self.channelId, self.uid)

        self.local_user = self.connection.get_local_user()
        self.local_user.set_playback_audio_frame_before_mixing_parameters(
            CHANNELS, SAMPLE_RATE
        )
        self.local_user.register_local_user_observer(self.channel_event_observer)
        self.local_user.register_audio_frame_observer(self.channel_event_observer)
        self.local_user.subscribe_all_audio()

        self.media_node_factory = self.rtc.agora_service.create_media_node_factory()
        self.audio_pcm_data_sender = (
            self.media_node_factory.create_audio_pcm_data_sender()
        )
        self.audio_track = self.rtc.agora_service.create_custom_audio_track_pcm(
            self.audio_pcm_data_sender
        )
        self.audio_track.set_enabled(1)
        self.local_user.publish_audio(self.audio_track)

        self.stream_id = self.connection.create_data_stream(False, False)
        self.received_chunks = {}
        self.waiting_message = None
        self.msg_id = ""
        self.msg_index = ""
```

The following code uses the `Channel` class to join a channel. It sets up a `future` to handle the connection state and returns a `Channel` object when the connection is successfully established.

```python
async def connect(self, channelId: str, uid: str) -> Channel:
    loop = asyncio.get_event_loop()
    future = loop.create_future()

    def callback(agora_rtc_conn: RTCConnection, conn_info: RTCConnInfo, reason):
        channel.off("connection_state_changed", callback)
        if conn_info.state == 3:
            future.set_result(channel)
        else:
            future.set_exception(
                Exception(f"connection state:{conn_info.state}"),
            )

    channel = Channel(self, channelId, uid)
    channel.on("connection_state_changed", callback)

    await future
    return channel
```

### Handle connection and channel events

To listen for channel and connection events, such as users joining or leaving the channel, and connection state changes, implement the `ChannelEventObserver` class. This class enables you to respond to SDK events.

```python
class ChannelEventObserver(IRTCConnectionObserver, IRTCLocalUserObserver, IAudioFrameObserver):
    def __init__(self, event_emitter: AsyncIOEventEmitter) -> None:
        self.loop = asyncio.get_event_loop()
        self.emitter = event_emitter
        self.audio_stream = AudioStream()

    def emit_event(self, event_name: str, *args):
        # Helper function to emit events
        self.emitter.emit(event_name, *args)

    def on_connected(
        self, agora_rtc_conn: RTCConnection, conn_info: RTCConnInfo, reason
    ):
        logger.info(f"Connected to RTC: {agora_rtc_conn} {conn_info} {reason}")        
        self.emit_event("connection_state_changed", agora_rtc_conn, conn_info, reason)

    def on_disconnected(
        self, agora_rtc_conn: RTCConnection, conn_info: RTCConnInfo, reason
    ):
        logger.info(f"Disconnected from RTC: {agora_rtc_conn} {conn_info} {reason}")
        self.emit_event("connection_state_changed", agora_rtc_conn, conn_info, reason)

    def on_connecting(
        self, agora_rtc_conn: RTCConnection, conn_info: RTCConnInfo, reason
    ):
        logger.info(f"Connecting to RTC: {agora_rtc_conn} {conn_info} {reason}")
        self.emit_event("connection_state_changed", agora_rtc_conn, conn_info, reason)

    def on_connection_failure(self, agora_rtc_conn, conn_info, reason):
        logger.error("Connection failure: {agora_rtc_conn} {conn_info} {reason}")
        self.emit_event("connection_state_changed", agora_rtc_conn, conn_info, reason)

    def on_user_joined(self, agora_rtc_conn: RTCConnection, user_id):
        logger.info(f"User joined: {agora_rtc_conn} {user_id}")
        self.emit_event("user_joined", agora_rtc_conn, user_id)

    def on_user_left(self, agora_rtc_conn: RTCConnection, user_id, reason):
        logger.info(f"User left: {agora_rtc_conn} {user_id} {reason}")
        self.emit_event("user_left", agora_rtc_conn, user_id, reason)

    def on_audio_subscribe_state_changed(
        self,
        agora_local_user,
        channel,
        user_id,
        old_state,
        new_state,
        elapse_since_last_state,
    ):
        logger.info(f'on_audio_subscribe_state_changed: {channel} {user_id} {old_state} {new_state} {elapse_since_last_state}')
        self.emit_event("audio_subscribe_state_changed", channel, user_id, old_state, new_state)

    def on_playback_audio_frame_before_mixing(
        self, agora_local_user: LocalUser, channelId, uid, frame: AudioFrame
    ):
        audio_frame = PcmAudioFrame()
        audio_frame.samples_per_channel = frame.samples_per_channel
        audio_frame.bytes_per_sample = frame.bytes_per_sample
        audio_frame.number_of_channels = frame.channels
        audio_frame.sample_rate = SAMPLE_RATE
        audio_frame.data = frame.buffer

        self.loop.call_soon_threadsafe(self.audio_stream.queue.put_nowait, audio_frame)
        return 0
```

### Subscribe to an audio stream

To asynchronously subscribe to audio streams for a specific user identified by their `uid`, refer to the following code. The method sets up a callback to monitor changes in the audio subscription state and handles the result based on whether the subscription is successfully established.

```python
async def subscribe_audio(self, uid: int) -> None:
    # Subscribes to the audio of a user.
    def callback(
        agora_local_user,
        channel,
        user_id,
        old_state,
        new_state,
        elapse_since_last_state,
    ):
        if new_state == 3:
            loop.call_soon_threadsafe(future.set_result, None)
        else:
            loop.call_soon_threadsafe(
                future.set_exception,
                Exception(
                    f"subscribe {user_id} audio state from {old_state} to {new_state}"
                ),
            )

    self.once("audio_subscribe_state_changed", callback)
    self.local_user.subscribe_audio(uid)

    await future
```

### Unsubscribe from an audio stream

To unsubscribe from an audio stream, implement an asynchronous method similar to `subscribe_audio` and use the following code to unsubscribe:

```python
self.local_user.unsubscribe_audio(uid)
```

### Disconnect from the service

To leave a channel, disconnect from Agora SD-RTN™ and release resources, refer to he following code.

```python
async def disconnect(self) -> None:
    # Disconnects the channel.
    disconnected_future = asyncio.Future[None]()
    def callback(agora_rtc_conn: RTCConnection, conn_info: RTCConnInfo, reason):
        self.off("connection_state_changed", callback)
        if conn_info.state == 1:
            disconnected_future.set_result(None)
    self.on("connection_state_changed", callback)
    self.connection.disconnect()
    await disconnected_future
```

### Complete code

The `rtc.py` script integrates the code components presented in this section into reusable Python classes that you can extend for your own applications.

<details>
<summary>Complete code for `rtc.py`</summary>
<CodeRtcPy />
</details>

</PlatformWrapper>