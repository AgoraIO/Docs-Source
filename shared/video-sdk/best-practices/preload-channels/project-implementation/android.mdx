<PlatformWrapper platform="android">

### API calls before using the VideoLoader API

This section shows the preparations before implementing the second-on and second-off functions.

1. Initialize `RtcEngine`

Call `create` in the RTC SDK to create and initialize the RtcEngine object:

```kotlin
// Initialize RtcEngine
private val mRtcEngine by lazy {
    RtcEngine.create(RtcEngineConfig().apply {
        mContext = applicationContext
        // Pass in the Agora project APP ID you got from the console
        mAppId = BuildConfig.AGORA_APP_ID
        mEventHandler = object : IRtcEngineEventHandler() {}
    })
}
```

2. Use a wildcard token

You need to generate a Token on the server first, and then pass in the Token parameter for authentication in the subsequent client implementation steps.

To speed up the process of users joining a channel, use a [wildcard token](../token-authentication/authentication-workflow#generate-wildcard-tokens).

<Admonition type="info" title="Note">The use of wildcard tokens will bring risks such as "room bombing". Please decide whether to use wildcard tokens based on specific needs.</Admonition>

### Open in seconds

This section describes how to achieve a smooth, instant-opening experience for viewers in live broadcast scenarios.

1. Implement the live broadcast room list UI module

Implement a UI module that displays a list of live broadcasts, A `RecyclerView` example is given below:

```xml
<androidx.recyclerview.widget.RecyclerView
    android:id="@+id/rvRooms"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:paddingHorizontal="7.5dp"
    android:overScrollMode="never"
    app:layoutManager="androidx.recyclerview.widget.GridLayoutManager"
    app:spanCount="2"
    android:clipToPadding="false"
    android:clipChildren="false"
    android:paddingBottom="50dp"
    android:visibility="visible" />
```

2. Listen for scrolling events

Create an `OnRoomListScrollEventHandler` object and register it as a proxy of the live room list scroll event to the live room list UI. To create the OnRoomListScrollEventHandler object, you need to pass the following in the constructor parameters:

    - `mRtcEngine`: A previously initialized `RtcEngine` object.
    - `localUid`: `uid` of the local user.

After the `OnRoomListScrollEventHandler` object listens to the scroll event of the live broadcast room list, it will drive the best practices encapsulated within the `OnRoomListScrollEventHandler` class and preload the channels of the live broadcast rooms that appear on the screen (`preloadChannel`).

```kotlin
// Code snippet from RoomListActivity
class RoomListActivity : AppCompatActivity() {
    private val mBinding by lazy { ShowRoomListActivityBinding.inflate(LayoutInflater.from(this)) }
    // Create an OnRoomListScrollEventHandler object
    private val onRoomListScrollEventHandler: OnRoomListScrollEventHandler = object : OnRoomListScrollEventHandler(mRtcEngine, RtcEngineInstance.localUid()) {}
    // Business Service Module
    private val mService by lazy { ShowServiceProtocol.getImplInstance() }

    override fun onCreate(savedInstanceState: Bundle?) {
        // Set the OnRoomListScrollEventHandler object to the live room list to listen for scroll events
        mBinding.rvRooms.addOnScrollListener(onRoomListScrollEventHandler as OnRoomListScrollEventHandler)

        // Get Room List
        mService.getRoomList { roomList ->
            // After getting the room list, pass the result to the onRoomListScrollEventHandler object
            onRoomListScrollEventHandler?.updateRoomList(roomList)
        }
    }
}
```

3. Listen for touch events

Create an `OnLiveRoomItemTouchEventHandler` object and register the object as a proxy for the touch events of a single live room to a single live room UI. To create the `OnLiveRoomItemTouchEventHandler` object, you need to pass the following parameters in the constructor:

    - `mRtcEngine`：A previously initialized `RtcEngine` object.
    - `roomInfo`：`VideoLoader.RoomInfo` object.

After the `OnLiveRoomItemTouchEventHandler` object listens to the touch event of a single live broadcast room, it will drive the best practices encapsulated within the `OnLiveRoomItemTouchEventHandler` class and enter the live broadcast room the user clicked on. At this point, you do not need to call `joinChannel` or similar methods for joining the channel in the business layer.

```kotlin
// Code snippet from RoomListActivity
class RoomListActivity : AppCompatActivity() {
    private val mBinding by lazy { ShowRoomListActivityBinding.inflate(LayoutInflater.from(this)) }
    private lateinit var mRoomAdapter: BindingSingleAdapter<ShowRoomDetailModel, ShowRoomItemBinding>

    override fun onCreate(savedInstanceState: Bundle?) {
        mRoomAdapter = object : BindingSingleAdapter<ShowRoomDetailModel, ShowRoomItemBinding>() {
            override fun onBindViewHolder(
                holder: BindingViewHolder<ShowRoomItemBinding>,
                position: Int
            ) {
                // UI for individual live streams
                val roomInfo = getItem(position) ?: return
                // Create an OnLiveRoomItemTouchEventHandler object
                val onTouchEventHandler = object : OnLiveRoomItemTouchEventHandler(
                    // Previously initialized RtcEngine object
                    mRtcEngine,
                    // Room Information
                    VideoLoader.RoomInfo(
                        roomInfo.roomId,
                        arrayListOf(
                            VideoLoader.AnchorInfo(
                                roomInfo.roomId,
                                roomInfo.ownerId.toInt(),
                                // Token mentioned above
                                // Sample code for wildcard token
                                RtcEngineInstance.generalToken()
                            )
                        )
                    ),
                    RtcEngineInstance.localUid()
                ) {
                    override fun onTouch(v: View?, event: MotionEvent?): Boolean {
                        when (event!!.action) {
                            MotionEvent.ACTION_UP -> {
                                if (RtcEngineInstance.generalToken() != "") {
                                    super.onTouch(v, event)
                                    // Listen to the ACTION_UP event and go to the in-stream page
                                    goLiveDetailActivity(list, position, roomInfo)
                                }
                            }
                        }
                        return true
                    }

                    // Informs you to render the anchor screen
                    override fun onRequireRenderVideo(info: VideoLoader.AnchorInfo): VideoLoader.VideoCanvasContainer? {
                        // The best time to render the anchor screen
                        return ...
                    }
                }

                // Set the OnLiveRoomItemTouchEventHandler object to a single live room to listen for touch events
                binding.root.setOnTouchListener(onTouchEventHandler)
            }
        }
        mBinding.rvRooms.adapter = mRoomAdapter
    }
}
```

The moment of receiving the `onRequireRenderVideo` event is the best time to render the anchor screen. Therefore, it is recommended to create a container for the anchor screen in advance. After receiving the `onRequireRenderVideo` event notification, return the container to the `OnLiveRoomItemTouchEventHandler` object which will automatically add the anchor screen to the container and render it.

### Switch in seconds

This section describes how to enable viewers to switch live broadcast rooms within seconds to watch live broadcasts.

1. Implement the live broadcast room slide switch UI module

Implement a slide switching module for the list of live broadcasts using `ViewPager2` as an example:

```xml
<androidx.viewpager2.widget.ViewPager2 xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/viewPager2"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:overScrollMode="never"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    app:layout_scrollEffect="none"
    android:layout_height="match_parent" />
```

2. Listen for live room switching events

Create an `OnPageScrollEventHandler` object and register it as the slide event proxy for the `ViewPager2` live broadcast room. To create the `OnPageScrollEventHandler` object, you need to pass the following in the constructor's parameters:

    - `mRtcEngine`: A previously initialized `RtcEngine` object.
    - `localUid`: `uid` of the local user.
    - `needPreJoin`: Set whether to join the upper and lower live broadcast rooms of the live broadcast room in advance. If set to yes ( true), it will bring better instant switching effect, but it will also increase the cost.
    - `sliceMode`: Switch the timing of outputting pictures in the live broadcast room.

After the `OnPageScrollEventHandler` object listens to the `ViewPager2` slide event of the live broadcast room, it will drive the best practices encapsulated inside the `OnPageScrollEventHandler` class and switch the audio/video subscription behavior of different live broadcast rooms at the optimal time. The `OnPageScrollEventHandler` object will trigger the following events of the live broadcast room at the corresponding position (`position`):

    - `onPageStartLoading`: Just started loading/displaying the live broadcast room.
    - `onPageLoaded`: Live room loading/displaying completed
    - `onPageLeft`: Left the live broadcast room
    - `onRequireRenderVideo`: The best time to render the anchor view of the corresponding live broadcast room. At this time, you must pass in the container for the anchor screen of the corresponding live broadcast room, and the `OnPageScrollEventHandler` object will add and render the anchor screen on the container.

```kotlin
// Code snippet from LiveViewPagerActivity
class LiveViewPagerActivity : AppCompatActivity() {
    private val mBinding by lazy { LiveViewPagerActivityBinding.inflate(LayoutInflater.from(this)) }
    // Use a circular array to store a list of live rooms that can be switched between
    private val vpFragments = SparseArray<LiveViewPagerFragment>()
    // Create OnPageScrollEventHandler object
    private var onPageScrollEventHandler: OnPageScrollEventHandler? = object : OnPageScrollEventHandler(
        // Previously initialized RtcEngine object
        RtcEngineInstance.rtcEngine,
        // Local user's uid
        RtcEngineInstance.localUid(),
        // Set whether or not to join the top and bottom two live rooms of the live room you're in ahead of time
        // If yes (true), this will result in a better second cut, but at an increased cost
        needPreJoin,
        // Toggles the timing of the live feed out via the onPageScrollStateChanged event.
        sliceMode
    ) {
        override fun onPageScrollStateChanged(state: Int) {
            when (state) {
                ViewPager2.SCROLL_STATE_SETTLING -> binding.viewPager2.isUserInputEnabled = false
                ViewPager2.SCROLL_STATE_IDLE -> binding.viewPager2.isUserInputEnabled = true
            }
            super.onPageScrollStateChanged(state)
        }

        override fun onPageStartLoading(position: Int) {
            // Notify the corresponding position of the live room to start displaying
            vpFragments[position]?.startLoadPageSafely()
        }

        override fun onPageLoaded(position: Int) {
            // Notify the corresponding position that the live room has been displayed
            vpFragments[position]?.onPageLoaded()
        }

        override fun onPageLeft(position: Int) {
            // Notify the corresponding position that the live room has left
            vpFragments[position]?.stopLoadPage(true)
        }

        override fun onRequireRenderVideo(position: Int, info: VideoLoader.AnchorInfo): VideoLoader.VideoCanvasContainer? {
            // The best time to render the anchor screen of the corresponding live room, and notify the live room of the corresponding position to return the container of the corresponding anchor screen.
            return vpFragments[position]?.initAnchorVideoView(info)
        }
    }

    // The actions that are performed when an Activity is created are described below.
    override fun onCreate(savedInstanceState: Bundle?) {
        // To be added
        ...
    }
}
```

You need to call `updateRoomList` when the Activity is created to pass the initial live broadcast room list information to the `onPageScrollEventHandler` object; at the same time, call `onRoomCreated` within the `createFragment` event of the `FragmentStateAdapter` to notify `onPageScrollEventHandler` that the corresponding live room has been created. So, add code within `override fun onCreate(savedInstanceState: Bundle?) {}` as follows:

```kotlin
override fun onCreate(savedInstanceState: Bundle?) {
    // When initializing the Activity, you need to pass the initial live room list information to the onPageScrollEventHandler object
    onPageScrollEventHandler?.updateRoomList(list)
    // 1 means that ViewPager2 will keep at least one page (Fragment) on each side of the current page in memory
    binding.viewPager2.offscreenPageLimit = 1
    // Create a FragmentStateAdapter that manages the page representing the live room
    val fragmentAdapter = object : FragmentStateAdapter(this) {
        // If ViewPager2 is slidable, it holds an infinite number of pages 
        // Otherwise, it returns 1, which holds only one page.
        override fun getItemCount() = if (mScrollable) Int.MAX_VALUE else 1

        // Create a LiveViewPagerFragment for each live feed
        override fun createFragment(position: Int): Fragment {
            val roomInfo = if (mScrollable) {
                mRoomInfoList[position % mRoomInfoList.size]
            } else {
                mRoomInfoList[selectedRoomIndex]
            }
            return LiveViewPagerFragment.newInstance(
                roomInfo,
                onPageScrollEventHandler as OnPageScrollEventHandler, position
            ).apply {
                // Store the created LiveViewPagerFragment in vpFragments
                vpFragments.put(position, this)
                // Creating a list of anchors in a live room
                val anchorList = arrayListOf(
                    VideoLoader.AnchorInfo(
                        roomInfo.roomId,
                        roomInfo.ownerId.toInt(),
                        RtcEngineInstance.generalToken()
                    )
                )
                // onRoomCreated notifies onPageScrollEventHandler that the corresponding room has been created.
                onPageScrollEventHandler?.onRoomCreated(
                    position,
                    VideoLoader.RoomInfo(roomInfo.roomId, anchorList),
                    position == binding.viewPager2.currentItem
                )
            }
        }
    }
    binding.viewPager2.adapter = fragmentAdapter
    // Set whether the user can manually swipe the page 
    // In a typical live room scenario, the viewer can manually swipe the page, but the anchor cannot.
    binding.viewPager2.isUserInputEnabled = mScrollable
    if (mScrollable) {
        // If you can slide 
        // set the OnPageScrollEventHandler object to ViewPager2 to listen for page change events 
        // and calculate the latest position.
        binding.viewPager2.registerOnPageChangeCallback(
            onPageScrollEventHandler as OnPageChangeCallback
        )
        binding.viewPager2.setCurrentItem(
            Int.MAX_VALUE / 2 - Int.MAX_VALUE / 2 % mRoomInfoList.size + selectedRoomIndex,
            false
        )
    } else {
        // If not slidable 
        // set current position to 0
        currLoadPosition = 0
    }
}
```

### Release resources

After using the <Vg k="COMPANY" /> scenario-based API (VideoLoader API), when you leave the live broadcast scene you don't need to call `leaveChannel` in the business layer. You can release resources according to the following sample code:

```kotlin
VideoLoader.getImplInstance(mRtcEngine).cleanCache()
VideoLoader.release()
RtcEngineEx.destroy()
```

</PlatformWrapper>