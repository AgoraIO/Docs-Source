import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import CompleteCodeJava from './complete-code-java.mdx';
import CompleteCodeKotlin from './complete-code-kotlin.mdx';

<PlatformWrapper platform = "android">
The following figure illustrates the essential steps:
<ProductWrapper notAllowed="voice-calling">
<details>
<summary>Quick start sequence</summary>

![](/images/video-sdk/quick-start-sequence.svg)
</details>
</ProductWrapper>

<ProductWrapper product="voice-calling">
<details>
<summary>Quick start sequence</summary>

![](/images/video-sdk/quickstart-voice-call-sequence.svg)
</details>
</ProductWrapper>

A complete code sample that implements the basic process of real-time interaction is presented here for your reference. To use the sample code, copy the following lines into the `MainActivity` file in `/app/src/main/java/com/example/<projectname>` file and replace `<projectname>` in `package com.example.<projectname>` with the name of your project.

<details>
<summary>Complete sample code for real-time <Vpd k="PRODUCT"/></summary>

<Tabs groupId="language">
<TabItem value="java" label="Java" default>
<CompleteCodeJava />
</TabItem>

<TabItem value="kotlin" label="Kotlin">
<CompleteCodeKotlin />
</TabItem>
</Tabs>

</details>

<Admonition type="info">
For the `myAppId` and `token` variables, replace the placeholders with the values you obtained from <Vg k="CONSOLE"/>. Ensure you enter the same `channelName` you used when generating the temporary token.
</Admonition>

Follow the implementation steps to understand the core API calls in the sample code.

### Handle permissions

This section describes how to import Android classes and obtain the camera, recording, and other permissions of Android devices.

1. **Import Android classes**

    <Tabs groupId="language">
    <TabItem value="java" label="Java" default>
    <ProductWrapper notAllowed="voice-calling">
    <CodeBlock language="java" showLineNumbers>
    {`import androidx.appcompat.app.AppCompatActivity;
   import androidx.core.app.ActivityCompat;
   import androidx.core.content.ContextCompat;

   import android.Manifest;
   import android.content.pm.PackageManager;
   import android.view.SurfaceView;
   import android.widget.FrameLayout;`}
    </CodeBlock>
    </ProductWrapper>
    <ProductWrapper product="voice-calling">
    <CodeBlock language="java" showLineNumbers>
    {`import android.Manifest;
   import android.content.pm.PackageManager;
   import android.os.Build;
   import android.os.Bundle;
   import android.widget.Toast;

   import androidx.appcompat.app.AppCompatActivity;
   import androidx.core.app.ActivityCompat;
   import androidx.core.content.ContextCompat;`}
    </CodeBlock>
    </ProductWrapper>
    </TabItem>

    <TabItem value="kotlin" label="Kotlin">
    <ProductWrapper notAllowed="voice-calling">
    <CodeBlock language="kotlin" showLineNumbers>
    {`import androidx.appcompat.app.AppCompatActivity
   import androidx.core.app.ActivityCompat
   import androidx.core.content.ContextCompat

   import android.Manifest
   import android.content.pm.PackageManager
   import android.view.SurfaceView
   import android.widget.FrameLayout
   `}
    </CodeBlock>
    </ProductWrapper>
    <ProductWrapper product="voice-calling">
    <CodeBlock language="kotlin" showLineNumbers>
    {`import android.Manifest
   import android.content.pm.PackageManager
   import android.os.Build
   import android.os.Bundle
   import android.widget.Toast

   import androidx.appcompat.app.AppCompatActivity
   import androidx.core.app.ActivityCompat
   import androidx.core.content.ContextCompat`}
    </CodeBlock>
    </ProductWrapper>
    </TabItem>

    </Tabs>


1. **Get Android permissions**

    When the app [starts](#start-and-close-the-app), check that the permissions necessary for real-time interaction have been granted to the app.

    <Tabs groupId="language">
    <TabItem value="java" label="Java" default>
    <ProductWrapper product="video-calling">
    <CodeBlock language="java" showLineNumbers>
    {`private static final int PERMISSION_REQ_ID = 22;

    private void requestPermissions() {
        ActivityCompat.requestPermissions(this, getRequiredPermissions(), PERMISSION_REQ_ID);
    }
    private boolean checkPermissions() {
        for (String permission : getRequiredPermissions()) {
            if (ContextCompat.checkSelfPermission(this, permission) != PackageManager.PERMISSION_GRANTED) {
                return false;
            }
        }
        return true;
    }
    private String[] getRequiredPermissions() {
        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.S) {
            return new String[]{
                Manifest.permission.RECORD_AUDIO,
                Manifest.permission.CAMERA,
                Manifest.permission.READ_PHONE_STATE,
                Manifest.permission.BLUETOOTH_CONNECT
            };
        } else {
            return new String[]{
                Manifest.permission.RECORD_AUDIO,
                Manifest.permission.CAMERA
            };
        }
    }
    @Override
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
        if (requestCode == PERMISSION_REQ_ID && checkPermissions()) {
            startVideoCalling();
        }
    }`}
    </CodeBlock>
    </ProductWrapper>
    <ProductWrapper product="broadcast-streaming">
    <CodeBlock language="java" showLineNumbers>
    {`private boolean checkPermissions() {
        for (String permission : getRequiredPermissions()) {
            if (ContextCompat.checkSelfPermission(this, permission) != PackageManager.PERMISSION_GRANTED) {
                return false;
            }
        }
        return true;
    }

    private String[] getRequiredPermissions() {
        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.S) {
            return new String[]{
                Manifest.permission.RECORD_AUDIO,
                Manifest.permission.CAMERA,
                Manifest.permission.READ_PHONE_STATE,
                Manifest.permission.BLUETOOTH_CONNECT
            };
        } else {
            return new String[]{
                Manifest.permission.RECORD_AUDIO,
                Manifest.permission.CAMERA
            };
        }
    }

    @Override
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
        if (requestCode == PERMISSION_REQ_ID && checkPermissions()) {
            startBroadcastStreaming();
        }
    }`}
    </CodeBlock>
    </ProductWrapper>
    <ProductWrapper product="interactive-live-streaming">
    <CodeBlock language="java" showLineNumbers>
    {`for (String permission : getRequiredPermissions()) {
            if (ContextCompat.checkSelfPermission(this, permission) != PackageManager.PERMISSION_GRANTED) {
                return false;
            }
        }
        return true;
    }

    private String[] getRequiredPermissions() {
        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.S) {
            return new String[]{
                Manifest.permission.RECORD_AUDIO,
                Manifest.permission.CAMERA,
                Manifest.permission.READ_PHONE_STATE,
                Manifest.permission.BLUETOOTH_CONNECT
            };
        } else {
            return new String[]{
                Manifest.permission.RECORD_AUDIO,
                Manifest.permission.CAMERA
            };
        }
    }
    
    @Override
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
        if (requestCode == PERMISSION_REQ_ID && checkPermissions()) {
            startLiveStreaming();
        }
    }private boolean checkPermissions() {
    `}
    </CodeBlock>
    </ProductWrapper>
    <ProductWrapper product="voice-calling">
    <CodeBlock language="java" showLineNumbers>
    {`private static final int PERMISSION_REQ_ID = 22;
    
    private boolean checkPermissions() {
        for (String permission : getRequiredPermissions()) {
            if (ContextCompat.checkSelfPermission(this, permission) != PackageManager.PERMISSION_GRANTED) {
                return false;
            }
        }
        return true;
    }

    private void requestPermissions() {
        ActivityCompat.requestPermissions(this, getRequiredPermissions(), PERMISSION_REQ_ID);
    }

    private String[] getRequiredPermissions() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
            return new String[]{
                Manifest.permission.RECORD_AUDIO,
                Manifest.permission.READ_PHONE_STATE,
                Manifest.permission.BLUETOOTH_CONNECT
            };
        } else {
            return new String[]{Manifest.permission.RECORD_AUDIO};
        }
    }

    @Override
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
        if (checkPermissions()) {
            startVoiceCalling();
        }
    }`}
    </CodeBlock>
    </ProductWrapper>
    </TabItem>

    <TabItem value="kotlin" label="Kotlin">
    <ProductWrapper product="interactive-live-streaming">
    <CodeBlock language="kotlin" showLineNumbers>
    {`private val PERMISSION_REQ_ID = 22

    private fun requestPermissions() {
        ActivityCompat.requestPermissions(this, getRequiredPermissions(), PERMISSION_REQ_ID)
    }

    private fun checkPermissions(): Boolean {
        for (permission in getRequiredPermissions()) {
            if (ContextCompat.checkSelfPermission(this, permission) != PackageManager.PERMISSION_GRANTED) {
                return false
            }
        }
        return true
    }

    private fun getRequiredPermissions(): Array<String> {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
            arrayOf(
                Manifest.permission.RECORD_AUDIO,
                Manifest.permission.CAMERA,
                Manifest.permission.READ_PHONE_STATE,
                Manifest.permission.BLUETOOTH_CONNECT
            )
        } else {
            arrayOf(
                Manifest.permission.RECORD_AUDIO,
                Manifest.permission.CAMERA
            )
        }
    }

    override fun onRequestPermissionsResult(
        requestCode: Int,
        permissions: Array<out String>,
        grantResults: IntArray
    ) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults)
        if (requestCode == PERMISSION_REQ_ID && checkPermissions()) {
            startLiveStreaming()
        }
    }`}
    </CodeBlock>
    </ProductWrapper>
    <ProductWrapper product="broadcast-streaming">
    <CodeBlock language="kotlin" showLineNumbers>
    {`private val PERMISSION_REQ_ID = 22

    private fun requestPermissions() {
        ActivityCompat.requestPermissions(this, getRequiredPermissions(), PERMISSION_REQ_ID)
    }

    private fun checkPermissions(): Boolean {
        for (permission in getRequiredPermissions()) {
            if (ContextCompat.checkSelfPermission(this, permission) != PackageManager.PERMISSION_GRANTED) {
                return false
            }
        }
        return true
    }

    private fun getRequiredPermissions(): Array<String> {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
            arrayOf(
                Manifest.permission.RECORD_AUDIO,
                Manifest.permission.CAMERA,
                Manifest.permission.READ_PHONE_STATE,
                Manifest.permission.BLUETOOTH_CONNECT
            )
        } else {
            arrayOf(
                Manifest.permission.RECORD_AUDIO,
                Manifest.permission.CAMERA
            )
        }
    }

    override fun onRequestPermissionsResult(
        requestCode: Int,
        permissions: Array<out String>,
        grantResults: IntArray
    ) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults)
        if (requestCode == PERMISSION_REQ_ID && checkPermissions()) {
            startBroadcastStreaming()
        }
    }`}
    </CodeBlock>
    </ProductWrapper>
    <ProductWrapper product="video-calling">
    <CodeBlock language="kotlin" showLineNumbers>
    {`private val PERMISSION_REQ_ID = 22

    private fun requestPermissions() {
        ActivityCompat.requestPermissions(this, getRequiredPermissions(), PERMISSION_REQ_ID)
    }

    private fun checkPermissions(): Boolean {
        for (permission in getRequiredPermissions()) {
            if (ContextCompat.checkSelfPermission(this, permission) != PackageManager.PERMISSION_GRANTED) {
                return false
            }
        }
        return true
    }

    private fun getRequiredPermissions(): Array<String> {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
            arrayOf(
                Manifest.permission.RECORD_AUDIO,
                Manifest.permission.CAMERA,
                Manifest.permission.READ_PHONE_STATE,
                Manifest.permission.BLUETOOTH_CONNECT
            )
        } else {
            arrayOf(
                Manifest.permission.RECORD_AUDIO,
                Manifest.permission.CAMERA
            )
        }
    }

    override fun onRequestPermissionsResult(
        requestCode: Int,
        permissions: Array<out String>,
        grantResults: IntArray
    ) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults)
        if (requestCode == PERMISSION_REQ_ID && checkPermissions()) {
            startVideoCalling()
        }
    }`}
    </CodeBlock>
    </ProductWrapper>
    <ProductWrapper product="voice-calling">
    <CodeBlock language="kotlin" showLineNumbers>
    {`private val permissionReqId = 22

    private fun checkPermissions(): Boolean {
        for (permission in getRequiredPermissions()) {
            if (ContextCompat.checkSelfPermission(this, permission) != PackageManager.PERMISSION_GRANTED) {
                return false
            }
        }
        return true
    }
    private fun requestPermissions() {
        ActivityCompat.requestPermissions(this, getRequiredPermissions(), PERMISSION_REQ_ID)
    }
    private fun getRequiredPermissions(): Array<String> {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
            arrayOf(
                Manifest.permission.RECORD_AUDIO,
                Manifest.permission.READ_PHONE_STATE,
                Manifest.permission.BLUETOOTH_CONNECT
            )
        } else {
            arrayOf(Manifest.permission.RECORD_AUDIO)
        }
    }
    override fun onRequestPermissionsResult(requestCode: Int, permissions: Array<out String>, grantResults: IntArray) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults)
        if (checkPermissions()) {
            startVoiceCalling()
        }
    }`}
    </CodeBlock>
    </ProductWrapper>
    </TabItem>

    </Tabs>

### Import Agora classes
Import the relevant Agora classes and interfaces:

<Tabs groupId="language">
<TabItem value="java" label="Java" default>
<ProductWrapper notAllowed="voice-calling">
<CodeBlock language="java" showLineNumbers>
{`import io.agora.rtc2.Constants;
import io.agora.rtc2.IRtcEngineEventHandler;
import io.agora.rtc2.RtcEngine;
import io.agora.rtc2.RtcEngineConfig;
import io.agora.rtc2.video.VideoCanvas;
import io.agora.rtc2.ChannelMediaOptions;`}
</CodeBlock>
</ProductWrapper>
<ProductWrapper product="voice-calling">
<CodeBlock language="java" showLineNumbers>
{`import io.agora.rtc2.Constants;
import io.agora.rtc2.IRtcEngineEventHandler;
import io.agora.rtc2.RtcEngine;
import io.agora.rtc2.RtcEngineConfig;
import io.agora.rtc2.ChannelMediaOptions;`}
</CodeBlock>
</ProductWrapper>
</TabItem>

<TabItem value="kotlin" label="Kotlin">
<ProductWrapper notAllowed="voice-calling">
<CodeBlock language="kotlin" showLineNumbers>
{`import io.agora.rtc2.Constants
import io.agora.rtc2.IRtcEngineEventHandler
import io.agora.rtc2.RtcEngine
import io.agora.rtc2.RtcEngineConfig
import io.agora.rtc2.video.VideoCanvas
import io.agora.rtc2.ChannelMediaOptions`}
</CodeBlock>
</ProductWrapper>
<ProductWrapper product="voice-calling">
<CodeBlock language="kotlin" showLineNumbers>
{`import io.agora.rtc2.ChannelMediaOptions
import io.agora.rtc2.Constants
import io.agora.rtc2.IRtcEngineEventHandler
import io.agora.rtc2.RtcEngine
import io.agora.rtc2.RtcEngineConfig`}
</CodeBlock>
</ProductWrapper>
</TabItem>

</Tabs>

### Declare variables

Pass in the app ID and the temporary token obtained from <Vg k="CONSOLE"/>. Use the channel name you filled in when generating the temporary token. You use these values to initialize the engine and join a channel.

<Tabs groupId="language">
<TabItem value="java" label="Java" default>
<CodeBlock language="java" showLineNumbers>
{`// Fill in the app ID from Agora Console
private String myAppId = "<Your app ID>";
// Fill in the channel name
private String channelName = "<Your channel name>";
// Fill in the temporary token generated from Agora Console
private String token = "<#Your token#>";`}
</CodeBlock>
</TabItem>

<TabItem value="kotlin" label="Kotlin">
<CodeBlock language="kotlin" showLineNumbers>
{`// Fill in the App ID obtained from the Agora Console
private val myAppId = "<Your app ID>"
// Fill in the channel name
private val channelName = "<Your channel name>"
// Fill in the temporary token generated from Agora Console
private val token = "<Your token>"`}
</CodeBlock>
</TabItem>
</Tabs>

### Initialize the engine

For real-time communication, initialize an `RtcEngine` instance and set up event handlers to manage user interactions within the channel. Use `RtcEngineConfig` to specify the application context, app ID, and custom event handler, then call `RtcEngine.create(config)` to initialize the engine, enabling further channel operations.

<Tabs groupId="language">
<TabItem value="java" label="Java" default>
<ProductWrapper notAllowed="voice-calling">
<CodeBlock language="java" showLineNumbers>
{`private void initializeAgoraVideoSDK() {
    try {
        RtcEngineConfig config = new RtcEngineConfig();
        config.mContext = getBaseContext();
        config.mAppId = myAppId;
        config.mEventHandler = mRtcEventHandler;
        mRtcEngine = RtcEngine.create(config);
    } catch (Exception e) {
        throw new RuntimeException("Error initializing RTC engine: " + e.getMessage());
    }
}`}
</CodeBlock>
</ProductWrapper>
<ProductWrapper product="voice-calling">
<CodeBlock language="java" showLineNumbers>
{`private void initializeAgoraVoiceSDK() {
    try {
        RtcEngineConfig config = new RtcEngineConfig();
        config.mContext = getBaseContext();
        config.mAppId = myAppId;
        config.mEventHandler = mRtcEventHandler;
        mRtcEngine = RtcEngine.create(config);
    } catch (Exception e) {
        throw new RuntimeException("Error initializing RTC engine: " + e.getMessage());
    }
}`}
</CodeBlock>
</ProductWrapper>
</TabItem>

<TabItem value="kotlin" label="Kotlin">
<ProductWrapper notAllowed="voice-calling">
<CodeBlock language="kotlin" showLineNumbers>
{`private fun initializeRtcEngine() {
    try {
        val config = RtcEngineConfig().apply {
            mContext = applicationContext
            mAppId = myAppId
            mEventHandler = mRtcEventHandler
        }
        mRtcEngine = RtcEngine.create(config)
    } catch (e: Exception) {
        throw RuntimeException("Error initializing RTC engine: $\{e.message\}")
    }
}`}
</CodeBlock>
</ProductWrapper>
<ProductWrapper product="voice-calling">
<CodeBlock language="kotlin" showLineNumbers>
{`private fun initializeAgoraVoiceSDK() {
    try {
        val config = RtcEngineConfig().apply {
            mContext = baseContext
            mAppId = myAppId
            mEventHandler = mRtcEventHandler
        }
        mRtcEngine = RtcEngine.create(config)
    } catch (e: Exception) {
        throw RuntimeException("Error initializing RTC engine: $\{\e.message\}")
    }
}`}
</CodeBlock>
</ProductWrapper>
</TabItem>

</Tabs>

<Admonition type="caution" title="Note">
Before initializing the SDK, ensure that the user fully understands and agrees to the relevant privacy policy.
</Admonition>

### Subscribe to <Vg k="VSDK"/> events

The <Vg k="VSDK"/> provides the `IRtcEngineEventHandler` interface for subscribing to channel events. To use it, create an instance of `IRtcEngineEventHandler` and implement the event methods you want to handle.

<Tabs groupId="language">
<TabItem value="java" label="Java" default>
<ProductWrapper notAllowed="voice-calling">
<CodeBlock language="java" showLineNumbers>
{`private final IRtcEngineEventHandler mRtcEventHandler = new IRtcEngineEventHandler() {
    // Callback when successfully joining the channel
    @Override
    public void onJoinChannelSuccess(String channel, int uid, int elapsed) {
        super.onJoinChannelSuccess(channel, uid, elapsed);
        runOnUiThread(() -> {
            Toast.makeText(MainActivity.this, "Join channel success", Toast.LENGTH_SHORT).show();
        });
    }
    // Callback when a remote user or host joins the current channel
    @Override
    public void onUserJoined(int uid, int elapsed) {
        runOnUiThread(() -> {
            // When a remote user joins the channel, display the remote video stream for the specified uid
            setupRemoteVideo(uid);
        });
    }
    // Callback when a remote user or host leaves the current channel
    @Override
    public void onUserOffline(int uid, int reason) {
        super.onUserOffline(uid, reason);
        runOnUiThread(() -> {
            Toast.makeText(MainActivity.this, "User offline: " + uid, Toast.LENGTH_SHORT).show();
        });
    }
};`}
</CodeBlock>
</ProductWrapper>
<ProductWrapper product="voice-calling">
<CodeBlock language="java" showLineNumbers>
{`private final IRtcEngineEventHandler mRtcEventHandler = new IRtcEngineEventHandler() {
    @Override
    public void onJoinChannelSuccess(String channel, int uid, int elapsed) {
        runOnUiThread(() ->
                Toast.makeText(MainActivity.this, "Join channel success", Toast.LENGTH_SHORT).show()
        );
    }

    @Override
    public void onUserJoined(int uid, int elapsed) {
        runOnUiThread(() ->
                Toast.makeText(MainActivity.this, "User joined: " + uid, Toast.LENGTH_SHORT).show()
        );
    }

    @Override
    public void onUserOffline(int uid, int reason) {
        runOnUiThread(() ->
                Toast.makeText(MainActivity.this, "User offline: " + uid, Toast.LENGTH_SHORT).show()
        );
    }
};`}
</CodeBlock>
</ProductWrapper>
</TabItem>
<TabItem value="kotlin" label="Kotlin" default>
<CodeBlock language="kotlin" showLineNumbers>
{`private val mRtcEventHandler = object : IRtcEngineEventHandler() {
    override fun onJoinChannelSuccess(channel: String?, uid: Int, elapsed: Int) {
        super.onJoinChannelSuccess(channel, uid, elapsed)
        runOnUiThread {
            Toast.makeText(this@MainActivity, "Join channel success", Toast.LENGTH_SHORT).show()
        }
    }
    override fun onUserJoined(uid: Int, elapsed: Int) {
        super.onUserJoined(uid, elapsed)
        runOnUiThread {
            Toast.makeText(this@MainActivity, "User joined: $uid", Toast.LENGTH_SHORT).show()
        }
    }
    override fun onUserOffline(uid: Int, reason: Int) {
        super.onUserOffline(uid, reason)
        runOnUiThread {
            Toast.makeText(this@MainActivity, "User offline: $uid", Toast.LENGTH_SHORT).show()
        }
    }
}`}
</CodeBlock>
</TabItem>
</Tabs>
Pass `mRtcEventHandler` to the `RtcEngineConfig` when initializing the engine to enable these callbacks.


<ProductWrapper notAllowed="voice-calling">

### Enable the video module

Follow these steps to enable the video module:

1. Call `enableVideo` to enable the video module.
1. Call `startPreview` to enable local video preview.

<Tabs groupId="language">
<TabItem value="java" label="Java" default>
<CodeBlock language="java" showLineNumbers>
{`private void enableVideo() {
    mRtcEngine.enableVideo();
    mRtcEngine.startPreview();
}`}
</CodeBlock>
</TabItem>
<TabItem value="kotlin" label="Kotlin">
<CodeBlock language="kotlin" showLineNumbers>
{`private fun enableVideo() {
    mRtcEngine.enableVideo()
    mRtcEngine.startPreview()
}
`}
</CodeBlock>
</TabItem>
</Tabs>

### Display the local video

Call `setupLocalVideo` to initialize the local view and set the local video display properties.

<Tabs groupId="language">
<TabItem value="java" label="Java" default>
<CodeBlock language="java" showLineNumbers>
{`/**
 * Initializes the local video view and sets the display properties.
 * This method adds a SurfaceView to the local video container and configures it.
 */
private void setupLocalVideo() {
    FrameLayout container = findViewById(R.id.local_video_view_container);
    SurfaceView surfaceView = new SurfaceView(getBaseContext());
    container.addView(surfaceView);
    mRtcEngine.setupLocalVideo(new VideoCanvas(surfaceView, VideoCanvas.RENDER_MODE_FIT, 0));
}`}
</CodeBlock>
</TabItem>

<TabItem value="kotlin" label="Kotlin">
<CodeBlock language="kotlin" showLineNumbers>
{`/**
 * Initializes the local video view and sets the display properties.
 * This method adds a SurfaceView to the local video container and configures it.
 */
private fun setupLocalVideo() {
    val container: FrameLayout = findViewById(R.id.local_video_view_container)
    val surfaceView = SurfaceView(baseContext)
    container.addView(surfaceView)
    mRtcEngine.setupLocalVideo(VideoCanvas(surfaceView, VideoCanvas.RENDER_MODE_FIT, 0))
}`}
</CodeBlock>
</TabItem>
</Tabs>

### Join a channel
<ProductWrapper product="video-calling">
Instantiate and configure `ChannelMediaOptions` and call `joinChannel` to join a channel. In `ChannelMediaOptions`, set the channel profile to `COMMUNICATION` (video calling) and set the user role to `BROADCASTER` (host) or `AUDIENCE`.

<Tabs groupId="language">
<TabItem value="java" label="Java" default>
<CodeBlock language="java" showLineNumbers>
{`private void joinChannel() {
    ChannelMediaOptions options = new ChannelMediaOptions();
    options.clientRoleType = Constants.CLIENT_ROLE_BROADCASTER;
    options.channelProfile = Constants.CHANNEL_PROFILE_COMMUNICATION;
    mRtcEngine.joinChannel(token, channelName, 0, options);
}`}
</CodeBlock>
</TabItem>

<TabItem value="kotlin" label="Kotlin">
<CodeBlock language="kotlin" showLineNumbers>
{`private fun joinChannel() {
    val options = ChannelMediaOptions().apply {
        clientRoleType = Constants.CLIENT_ROLE_BROADCASTER
        channelProfile = Constants.CHANNEL_PROFILE_COMMUNICATION
    }
    mRtcEngine.joinChannel(token, channelName, 0, options)
}
`}
</CodeBlock>
</TabItem>

</Tabs>

</ProductWrapper>
<ProductWrapper product="broadcast-streaming">
Instantiate and configure `ChannelMediaOptions` and call `joinChannel` to join a channel. In `ChannelMediaOptions`, set the channel profile to `BROADCASTING` (live broadcast scene) and set the user role to `BROADCASTER` (host) or `AUDIENCE`.

<Tabs groupId="language">
<TabItem value="java" label="Java" default>
<CodeBlock language="java" showLineNumbers>
{`private void joinChannel() {
    // Create an instance of ChannelMediaOptions and configure it
    ChannelMediaOptions options = new ChannelMediaOptions();
    // Set the user role to BROADCASTER or AUDIENCE according to the use-case
    options.clientRoleType = Constants.CLIENT_ROLE_BROADCASTER;
    // In the live broadcast use-case, set the channel profile to BROADCASTING (live broadcast use-case)
    options.channelProfile = Constants.CHANNEL_PROFILE_LIVE_BROADCASTING;
    // Set the audience latency level
    options.audienceLatencyLevel = Constants.AUDIENCE_LATENCY_LEVEL_LOW_LATENCY;
    mRtcEngine.joinChannel(token, channelName, 0, options);
}`}
</CodeBlock>
</TabItem>

<TabItem value="kotlin" label="Kotlin">
<CodeBlock language="kotlin" showLineNumbers>
{`// Create an instance of ChannelMediaOptions and configure it
val options = ChannelMediaOptions().apply {
    // Set the user role to BROADCASTER or AUDIENCE according to the use-case
    clientRoleType = Constants.CLIENT_ROLE_BROADCASTER
    // In the live broadcast use-case, set the channel profile to BROADCASTING (live broadcast use-case)
    channelProfile = Constants.CHANNEL_PROFILE_LIVE_BROADCASTING
    // Set the latency level for optimal performance
    audienceLatencyLevel = Constants.AUDIENCE_LATENCY_LEVEL_LOW_LATENCY
    // Publish the audio captured by the microphone
    publishMicrophoneTrack = true
    // Publish the video captured by the camera
    publishCameraTrack = true
    // Automatically subscribe to all audio streams
    autoSubscribeAudio = true
    // Automatically subscribe to all video streams
    autoSubscribeVideo = true
}

// Use the temporary token to join the channel
// Specify the user ID yourself and ensure it is unique within the channel
mRtcEngine.joinChannel(token, channelName, 0, options)
`}
</CodeBlock>
</TabItem>

</Tabs>

</ProductWrapper>

<ProductWrapper product="interactive-live-streaming">
Instantiate and configure `ChannelMediaOptions` and call `joinChannel` to join a channel. In `ChannelMediaOptions`, set the channel profile to `BROADCASTING` (live broadcast scene) and set the user role to `BROADCASTER` (host) or `AUDIENCE`.

<Tabs groupId="language">
<TabItem value="java" label="Java" default>
<CodeBlock language="java" showLineNumbers>
{`private void joinChannel() {
    // Create an instance of ChannelMediaOptions and configure it
    ChannelMediaOptions options = new ChannelMediaOptions();
    // Set the user role to BROADCASTER or AUDIENCE according to the use-case
    options.clientRoleType = Constants.CLIENT_ROLE_BROADCASTER;
    // In the live broadcast use-case, set the channel profile to BROADCASTING (live broadcast use-case)
    options.channelProfile = Constants.CHANNEL_PROFILE_LIVE_BROADCASTING;
    // Set the audience latency level
    options.audienceLatencyLevel = Constants.AUDIENCE_LATENCY_LEVEL_ULTRA_LOW_LATENCY;
    mRtcEngine.joinChannel(token, channelName, 0, options);
}`}
</CodeBlock>
</TabItem>

<TabItem value="kotlin" label="Kotlin">
<CodeBlock language="kotlin" showLineNumbers>
{`private fun joinChannel() {
    // Create an instance of ChannelMediaOptions and configure it
    val options = ChannelMediaOptions().apply {
        // Set the user role to BROADCASTER or AUDIENCE according to the use-case
        clientRoleType = Constants.CLIENT_ROLE_BROADCASTER
        // In the live broadcast use-case, set the channel profile to BROADCASTING (live broadcast use-case)
        channelProfile = Constants.CHANNEL_PROFILE_LIVE_BROADCASTING
        // Set the audience latency level
        audienceLatencyLevel = Constants.AUDIENCE_LATENCY_LEVEL_ULTRA_LOW_LATENCY
    }
    mRtcEngine.joinChannel(token, channelName, 0, options)
}`}
</CodeBlock>
</TabItem>

</Tabs>

</ProductWrapper>

### Display the remote video

When a remote user joins the channel, call `setupRemoteVideo` and pass in the remote user's `uid`, obtained from the `onUserJoined` callback, to display the remote video.

<Tabs groupId="language">
<TabItem value="java" label="Java" default>
<CodeBlock language="java" showLineNumbers>
{`private void setupRemoteVideo(int uid) {
    FrameLayout container = findViewById(R.id.remote_video_view_container);
    SurfaceView surfaceView = new SurfaceView(getBaseContext());
    surfaceView.setZOrderMediaOverlay(true);
    container.addView(surfaceView);
    mRtcEngine.setupRemoteVideo(new VideoCanvas(surfaceView, VideoCanvas.RENDER_MODE_FIT, uid));
}`}
</CodeBlock>
</TabItem>

<TabItem value="kotlin" label="Kotlin">
<CodeBlock language="kotlin" showLineNumbers>
{`private fun setupRemoteVideo(uid: Int) {
    val container = findViewById<FrameLayout>(R.id.remote_video_view_container)
    val surfaceView = SurfaceView(baseContext).apply {
        setZOrderMediaOverlay(true)
    }
    container.addView(surfaceView)
    mRtcEngine.setupRemoteVideo(VideoCanvas(surfaceView, VideoCanvas.RENDER_MODE_FIT, uid))
}
`}
</CodeBlock>
</TabItem>

</Tabs>

</ProductWrapper>

<ProductWrapper product="voice-calling">

### Join a channel

Call `joinChannel` to join the channel. Configure the `ChannelMediaOptions` to set the channel profile to `BROADCASTING` (live broadcast scene) and set the user role to `BROADCASTER` (host) or `AUDIENCE`.

<Tabs groupId="language">
<TabItem value="java" label="Java" default>
<CodeBlock language="java" showLineNumbers>
{`private void joinChannel() {
    ChannelMediaOptions options = new ChannelMediaOptions();
    options.clientRoleType = Constants.CLIENT_ROLE_BROADCASTER;
    options.channelProfile = Constants.CHANNEL_PROFILE_COMMUNICATION;
    mRtcEngine.joinChannel(token, channelName, 0, options);
}`}
</CodeBlock>
</TabItem>

<TabItem value="kotlin" label="Kotlin">
<CodeBlock language="kotlin" showLineNumbers>
{`private fun joinChannel() {
    val options = ChannelMediaOptions().apply {
        clientRoleType = Constants.CLIENT_ROLE_BROADCASTER
        channelProfile = Constants.CHANNEL_PROFILE_COMMUNICATION
    }
    mRtcEngine?.joinChannel(token, channelName, 0, options)
}`}
</CodeBlock>
</TabItem>

</Tabs>

</ProductWrapper>

### Start and close the app

When a user launches your <Vpl k="CLIENT"/>, start real-time interaction. When a user closes the app, stop the interaction.

1. In the `onCreate` callback, check whether the <Vpl k="CLIENT"/> has been granted the required permissions. If the permissions have not been granted, request the required permissions from the user. If permissions are granted, initialize `RtcEngine` and join a channel.

    <Tabs groupId="language">
    <TabItem value="java" label="Java" default>
    <ProductWrapper product="video-calling">
    <CodeBlock language="java" showLineNumbers>
    {`@Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        if (checkPermissions()) {
            startVideoCalling();
        } else {
            requestPermissions();
        }
    }`}
    </CodeBlock>
    </ProductWrapper>
    <ProductWrapper product="broadcast-streaming">
    <CodeBlock language="java" showLineNumbers>
    {`@Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        if (checkPermissions()) {
            startBroadcastStreaming();
        } else {
            requestPermissions();
        }
    }`}
    </CodeBlock>
    </ProductWrapper>
    <ProductWrapper product="interactive-live-streaming">
    <CodeBlock language="java" showLineNumbers>
    {`@Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        if (checkPermissions()) {
            startLiveStreaming();
        } else {
            requestPermissions();
        }
    }`}
    </CodeBlock>
    </ProductWrapper>
    <ProductWrapper product="voice-calling">
    <CodeBlock language="java" showLineNumbers>
    {`@Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        if (checkPermissions()) {
            startVoiceCalling();
        } else {
            requestPermissions();
        }
    }`}
    </CodeBlock>
    </ProductWrapper>
    </TabItem>

    <TabItem value="kotlin" label="Kotlin">
    <CodeBlock language="kotlin" showLineNumbers>
    {`override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        if (checkPermissions()) {
            startLiveStreaming()
        } else {
            requestPermissions()
        }
    }`}
    </CodeBlock>
    </TabItem>

    </Tabs>    
    
<ProductWrapper notAllowed="voice-calling">

2. When a user closes the <Vpl k="CLIENT"/>, or switches the <Vpl k="CLIENT"/> to the background, call `stopPreview` to stop the video preview and then call `leaveChannel` to leave the current channel and release all session-related resources.

    <Tabs groupId="language">
    <TabItem value="java" label="Java" default>
    <CodeBlock language="java" showLineNumbers>
    {`private void cleanupAgoraEngine() {
        if (mRtcEngine != null) {
            mRtcEngine.stopPreview();
            mRtcEngine.leaveChannel();
            mRtcEngine = null;
        }
    }`}
    </CodeBlock>
    </TabItem>

    <TabItem value="kotlin" label="Kotlin">
    <CodeBlock language="kotlin" showLineNumbers>
    {`private fun cleanupAgoraEngine() {
        mRtcEngine?.let {
            it.stopPreview()
            it.leaveChannel()
            mRtcEngine = null
        }
    }`}
    </CodeBlock>
    </TabItem>

    </Tabs>

</ProductWrapper>
<ProductWrapper product="voice-calling">
2. When a user closes the <Vpl k="CLIENT"/>, or switches the <Vpl k="CLIENT"/> to the background, call `leaveChannel` to leave the current channel and release all session-related resources.

    <Tabs groupId="language">
    <TabItem value="java" label="Java" default>
    <CodeBlock language="java" showLineNumbers>
    {`private void cleanupAgoraEngine() {
        if (mRtcEngine != null) {
            mRtcEngine.leaveChannel();
            mRtcEngine = null;
        }
   }`}
    </CodeBlock>
    </TabItem>

    <TabItem value="kotlin" label="Kotlin">
    <CodeBlock language="kotlin" showLineNumbers>
    {`override fun onDestroy() {
        super.onDestroy()
        mRtcEngine?.apply {
            leaveChannel()
            RtcEngine.destroy()
        }
        mRtcEngine = null
    }`}
    </CodeBlock>
    </TabItem>

    </Tabs>

</ProductWrapper>
</PlatformWrapper>