<PlatformWrapper platform="web">


1.  **Declare the variables to create an <Vg k="MESS_ENGINE" /> instance**

    You use these objects to communicate with <Vg k="MESS" />.

    ``` typescript
    // The Signaling RTMEngine instance
    let signalingEngine = null;
    let signalingChannel = null;
    let uid = "";
    ```

1.  **Declare the variables to join a channel**

    Best practice is to keep these variables in a separate configuration file.

    ``` json
    {
        "uid": "1",
        "appId": "",
        "channelName": "",
        "token": "",
        "proxyUrl": "http://localhost:8080/",
        "serverUrl": "<URL to a token server>",
        "tokenExpiryTime": "600",
        "encryptionMode": 1,
        "salt": "",
        "cipherKey": "",
        "presenceTimeout": 300,
        "logUpload": false,
        "logFilter": {
            "error": true,
            "warn": true,
            "info": true,
            "track": true,
            "debug": false
        },
        "cloudProxy": true,
        "useStringUserId": false,
        "rtcToken": ""
    }
    ```
    To learn more about the configuration parameters, see [RTMConfig](/en/signaling/reference/api#rtmconfig).

3.  **Configure a <Vg k="MESS_ENGINE" /> instance**

    Your code reads the parameters from the configuration file.

    ``` typescript
    try {
      rtmConfig = rtmConfig || {
        token: config.token,
        useStringUserId: config.useStringUserId,
        logUpload: config.logUpload,
        presenceTimeout: config.presenceTimeout,
      };
      AgoraRTM.setArea({ areaCodes: ["ASIA"] });
      signalingEngine = new AgoraRTM.RTM(config.appId, config.uid, rtmConfig);
    } catch (error) {
      console.log("Error:", error);
    }
    ```

4.  **Handle and respond to  <Vg k="MESS" /> events**
    <a name="handle-events" />
    The following event listener handles events for all <Vg k="MESS" /> features, including [Messages](/en/signaling/reference/api#messages),
    [Presence](/en/signaling/reference/api#presence), [Storage](/en/signaling/reference/api#storage),
    [Topics](/en/signaling/reference/api#topics), [Lock](/en/signaling/reference/api#lock) and
    [token expiration](/en/signaling/reference/api#event-listeners).

    ``` typescript
    // Event listener to handle incoming messages and connection status changes
    signalingEngine.addEventListener({
      // Message event handler
      message: (eventArgs) => {
        eventsCallback("message", eventArgs);
        messageCallback(
          "Received message from " +
            eventArgs.publisher +
            ": " +
            eventArgs.message
        );
      },
      // State event handler
      status: (eventArgs) => {
        eventsCallback("status", eventArgs);
        messageCallback(
          "Connection state changed to: " +
            eventArgs.state +
            ", Reason: " +
            eventArgs.reason
        );
      },
      // Presence event handler.
      presence: (eventArgs) => {
        eventsCallback("presence", eventArgs);
        if (eventArgs.eventType === "SNAPSHOT") {
          messageCallback(
            eventArgs.snapshot[0].userId + " joined " + eventArgs.channelName
          );
        } else {
          messageCallback(
            "Presence event: " +
              eventArgs.eventType +
              ", User: " +
              eventArgs.publisher
          );
        }
      },
      // Storage event handler
      storage: (eventArgs) => {
        eventsCallback("storage", eventArgs);
      },
      // Topic event handler
      topic: (eventArgs) => {
        eventsCallback("topic", eventArgs);
      },
      // Lock event handler
      lock: (eventArgs) => {
        eventsCallback("lock", eventArgs);
      },
      // TokenPrivilegeWillExpire event handler
      TokenPrivilegeWillExpire: (eventArgs) => {
        eventsCallback("TokenPrivilegeWillExpire ", eventArgs);
      },
    });
    ```

1.  **Login to <Vg k="MESS" />**

      In <Vg k="MESS" />, each token is specific to a user ID. If `uid` and `token` do not match, your user cannot login.

      ``` typescript
      const login = async (uid, token) => {
        try {
          if (uid !== undefined) config.uid = uid;
          if (token !== undefined) config.token = token;

          await setupSignalingEngine(rtmConfig);
          const result = await signalingEngine.login();
          console.log(result);
        } catch (error) {
          console.log(error);
        }
      };
      ```


1.  **Send a messages**

    Messages are sent directly to the UID of another user.

    ``` typescript
      // Send a message to a channel
      const sendChannelMessage = async (channelName, Message) => {
        const payload = { type: "text", message: Message };
        const publishMessage = JSON.stringify(payload);
        try {
          const sendResult = await signalingEngine.publish(
            channelName,
            publishMessage
          );
          messageCallback(config.uid + ": " + publishMessage);
        } catch (error) {
          console.log(error);
        }
      };
    ```

    You setup the event handlers for messages received from other users during <Vg k="MESS_ENGINE" /> initiation.


1.  **Logout of <Vg k="MESS" />**

    Had enough of the conversation? Just logout.

    ``` typescript
      // Logout from the signaling engine
      const logout = async () => {
        await signalingEngine.logout();
      };
    ```

You have just implemented the <Vg k="MESS" /> workflow. Yes, it's as easy as that.
</PlatformWrapper>