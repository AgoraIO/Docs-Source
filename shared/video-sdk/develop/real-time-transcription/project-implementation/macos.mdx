<PlatformWrapper platform="macos">

### Implement the user interface

To create a simple interface to test this feature, you add the following elements to the user interface:

* A button to start and stop real-time transcription task
* A button to query the real-time transcription task status

To create this user interface, in the `ViewController` class:

1. **Add the UI elements you need**

    Add the following declarations at the top of the class:

    ```swift
    var realTimeTranscriptionButton: NSButton!
    var queryRealTimeTranscriptionButton: NSButton!
    ```

1. **Configure the UI elements in your interface**

    Paste the following lines inside the `initViews` function:

    ```swift
    // Button to start or stop the real-time transcription task
    realTimeTranscriptionButton = NSButton()
    realTimeTranscriptionButton.frame = CGRect(x: 230, y: 240, width: 80, height: 20)
    realTimeTranscriptionButton.title = "Start real-time transcription"
    realTimeTranscriptionButton.target = self

    realTimeTranscriptionButton.action = #selector(realTimeTranscription)
    self.view.addSubview(realTimeTranscriptionButton)

    // Button to query the status of the real-time transcription task
    queryRealTimeTranscriptionButton = NSButton()
    queryRealTimeTranscriptionButton.frame = CGRect(x: 310, y: 240, width: 80, height: 20)
    queryRealTimeTranscriptionButton.title = "Query real-time transcription"
    queryRealTimeTranscriptionButton.target = self

    queryRealTimeTranscriptionButton.action = #selector(query)
    self.view.addSubview(queryRealTimeTranscriptionButton)
    ```

You see errors in your IDE. This is because the layout refers to methods that you create later.

### Handle the system logic

1. **Define variables to manage a real-time transcription task**

    Add the following declarations to the top of the `ViewController` class:

    ```swift
    let baseUrl = "https://api.agora.io"
    var apiKey = "<your Customer ID from Agora console>"
    var apiSecret = "<your Customer secret from Agora console>"
    let instanceID = "Test-1"
    var authorizationHeader = ""
    var builderToken = ""
    var realTimeTranscriptionTaskId = ""  // Returned by the start method
    var isRealTimeTranscriptionRunning: Bool = false
    ```

### Manage a real-time transcription task

Take the following steps to start, stop, and query a real-time transcription task in your <Vpl k="CLIENT" />.

1. **Get a `builderToken`**

    To [acquire a builderToken](#acquire-a-buildertoken), you:

    1. Generate a Base64-encoded credential from the API key and secret associated with your <Vg k="COMPANY" /> project.
    1. Add this credential to the request header as a parameter named `Authorization`.
    1. In the request body, pass the `instanceID` that you use to identify the instance.

    To [acquire a `builderToken`](#acquire-a-buildertoken), add the following method to the `ViewController` class:

    ```swift
    func getBuilderToken() {
        guard let url = URL(string: "\(baseUrl)/v1/projects/\(appID)/rtsc/speech-to-text/builderTokens") else { return }

        // Concatenate the key and secret and use base64 encoding
        let plainCredentials = "\(apiKey):\(apiSecret)"

        let plainCredentialsUtf8 = plainCredentials.data(using: .utf8)
        let base64Credentials: String? = plainCredentialsUtf8?.base64EncodedString(options: [])

        // Create authorization header
        authorizationHeader = "Basic \(base64Credentials!)"

        // Create the request
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue(authorizationHeader, forHTTPHeaderField: "Authorization")

        let body: [String: String] = [
            "instanceId": instanceID
        ]
        // Generate JSON data from the body object and set as the request's HTTP body
        request.httpBody = try? JSONSerialization.data(withJSONObject: body)

        // Make the API call
        let task = URLSession.shared.dataTask(with: request) { data, response, err in
            guard let data = data, err == nil else {
                return
            }

            let responseJSON = try? JSONSerialization.jsonObject(with: data, options: [])

            if let responseDict = responseJSON as? [String: Any] {
                // Check if a successful response code was retrieved
                guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {
                    DispatchQueue.main.async {
                        self.showMessage(title: "Error", text: "Error receiving builder token: \(responseDict["message"]!)", delay: 0)
                    }
                    return
                }

                if let tokenToReturn = responseDict["tokenName"] as? String {
                    // Key "tokenName" found in response, assigning to builderToken
                    self.builderToken = tokenToReturn
                    self.showMessage(title:"Success", text:"builderToken received", delay: 0)
                    self.startRealTimeTranscription()
                } else {
                    self.showMessage(title: "Error", text: "builderToken not received: \(responseDict["message"]!)", delay: 0)
                }
            } else {
                self.showMessage(title: "Error", text: "builderToken not received", delay: 0)
            }
        }
        task.resume()
    }
    ```

    A `builderToken` is usable for 5 minutes. After the time has expired, you must generate a new token.

1. **Start a real-time transcription task**

    To [start a real-time transcription task](#start-a-real-time-transcription-task), you:
    1. Create a JSON configuration and pass it in the body of a `POST` request.
    1. Add the `builderToken` as a query parameter to the URL.
    1. Make a `POST` call to  <Vg k="AGORA_BACKEND" />.

    To start a task, add the following method to the `ViewController` class:

    ```swift
    func startRealTimeTranscription() {
        guard let url = URL(string: "\(baseUrl)/v1/projects/\(appID)/rtsc/speech-to-text/tasks?builderToken=\(builderToken)") else { return }

        // Create the request
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue(authorizationHeader, forHTTPHeaderField: "Authorization")

        let body: [String: Any] = [
            "audio": [
                "subscribeSource": "AGORARTC",
                "agoraRtcConfig": [
                    "channelName": channelName,
                    "uid": "<YourUid>",
                    "token": token,
                    "channelType": "LIVE_TYPE",
                    "subscribeConfig": [
                        "subscribeMode": "CHANNEL_MODE"
                    ],
                    "maxIdleTime": 60
                ]
            ],
            "config": [
                "features": ["RECOGNIZE"],
                "recognizeConfig": [
                    "language": "ENG",
                    "model": "Model",
                    "output": [
                        "destinations": [
                            "AgoraRTCDataStream",
                            "Storage"
                        ],
                        "agoraRTCDataStream": [
                            "channelName": channelName,
                            "uid": "<YourUid>",
                            "token": token
                        ],
                        "cloudStorage": [
                            [
                                "format": "HLS",
                                "storageConfig": [
                                    "accessKey": "<YourOssAccessKey>",
                                    "secretKey": "<YourOssSecretKey>",
                                    "bucket": "<YourOssBucketName>",
                                    "vendor": 0,  // Your Oss Vendor id
                                    "region": 0,  // Your Oss Region id
                                    "fileNamePrefix": [
                                        "directory1",
                                        "directory2"
                                    ]
                                ]
                            ]
                        ]
                    ]
                ]
            ]
        ]

        // Generate JSON data from the body object and set as the request's HTTP body
        request.httpBody = try? JSONSerialization.data(withJSONObject: body)

        // Make the API call
        let task = URLSession.shared.dataTask(with: request) { data, response, err in
            guard let data = data, err == nil else {
                return
            }

            let responseJSON = try? JSONSerialization.jsonObject(with: data, options: [])

            if let responseDict = responseJSON as? [String: Any] {
                // Check if a successful response code was retrieved
                guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {
                    self.showMessage(title: "Error", text: "Error starting real-time transcription task: \(responseDict["message"]!)", delay: 0)
                    return
                }

                if let status = responseDict["status"] as? String, let taskId = responseDict["taskId"] as? String {
                    self.realTimeTranscriptionTaskId = taskId

                    if status == "STARTED" || status == "IN_PROGRESS" {
                        self.isRealTimeTranscriptionRunning = true
                        self.showMessage(title: "Success", text: "Real-time transcription task started", delay: 0)
                        DispatchQueue.main.async {
                            self.realTimeTranscriptionButton.title = "Stop real-time transcription"
                        }
                    } else {
                        self.isRealTimeTranscriptionRunning = false
                        self.showMessage(title: "Error", text: "Real-time transcription status: \(status)", delay: 0)
                    }
                } else {
                    self.showMessage(title: "Error", text: "Real-time transcription status and/or taskId not received: \(responseDict["message"]!)", delay: 0)
                }
            } else {
                self.showMessage(title: "Error", text: "Error parsing Start real-time transcription response", delay: 0)
            }
        }
        task.resume()
    }
    ```

1. **Query task status**

    You [query the status](#query-the-status-of-real-time-transcription) of a real-time transcription task using a `GET` request containing the `taskId` and `builderToken` to notify the user of any change. To do this, add the following method to the `ViewController` class:

    ```swift
    func queryRealTimeTranscription() {
        guard let url = URL(string: "\(baseUrl)/v1/projects/\(appID)/rtsc/speech-to-text/tasks/\(realTimeTranscriptionTaskId)?builderToken=\(builderToken)") else { return }

        // Create the request
        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue(authorizationHeader, forHTTPHeaderField: "Authorization")

        // Make the API call
        let task = URLSession.shared.dataTask(with: request) { data, response, err in
            guard let data = data, err == nil else {
                return
            }
            let responseJSON = try? JSONSerialization.jsonObject(with: data, options: [])

            if let responseDict = responseJSON as? [String: Any] {
                // Check if a successful response code was retrieved
                guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {
                    DispatchQueue.main.async {
                        self.showMessage(title: "Error", text: "Error receiving query call response: \(responseDict["message"]!)", delay: 0)
                    }
                    return
                }

                if let status = responseDict["status"] as? String, let taskId = responseDict["taskId"] as? String {
                    self.realTimeTranscriptionTaskId = taskId

                    if status == "IN_PROGRESS" {
                        self.isRealTimeTranscriptionRunning = true
                        DispatchQueue.main.async {
                            self.realTimeTranscriptionButton.title = "Stop real-time transcription"
                        }
                        self.showMessage(title: "Success", text: "Real-time transcription is running", delay: 0)
                    } else {
                        self.isRealTimeTranscriptionRunning = false
                        self.realTimeTranscriptionTaskId = ""
                        self.showMessage(title: "Success", text: "Real-time transcription status: \(status)", delay: 0)
                        DispatchQueue.main.async {
                            self.realTimeTranscriptionButton.title = "Start real-time transcription"
                        }
                    }
                } else {
                    self.showMessage(title: "Error", text: "Real-time transcription status and/or taskId not received: \(responseDict["message"]!)", delay: 0)
                }
            } else {
                self.showMessage(title: "Error", text: "Error parsing query call response", delay: 0)
            }
        }
        task.resume()
    }
    ```

1. **Stop the task**

    To [stop real-time transcription](#stop-real-time-transcription), you send a `DELETE` request with the `appId`, `taskId`, and `builderToken` in the URL. In the `ViewController` class, add the following method:

    ```swift
    func stopRealTimeTranscription() {
        guard let url = URL(string: "\(baseUrl)/v1/projects/\(appID)/rtsc/speech-to-text/tasks/\(realTimeTranscriptionTaskId)?builderToken=\(builderToken)") else { return }

        // Create the request
        var request = URLRequest(url: url)
        request.httpMethod = "DELETE"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue(authorizationHeader, forHTTPHeaderField: "Authorization")

        // Make the API call
        let task = URLSession.shared.dataTask(with: request) { _, response, err in
            guard err == nil else {
                return
            }

            if let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 {
                DispatchQueue.main.async {
                    self.showMessage(title: "Success", text: "Real-time transcription task stopped", delay: 0)
                    self.realTimeTranscriptionButton.title = "Start real-time transcription"
                }
                self.realTimeTranscriptionTaskId = ""
                self.isRealTimeTranscriptionRunning = false
            } else {
                DispatchQueue.main.async {
                    self.showMessage(title: "Error", text: "Error stopping real-time transcription task: \(response!)", delay: 0)
                }
            }
        }
        task.resume()
    }
    ```

1. **Receive and display the text stream**

    When you set one of the `destinations` in the starting configuration as `AgoraRTCDataStream`, the real-time transcription conversion output stream is pushed to your channel.

    To receive this stream and display the text in your <Vpl k="CLIENT" />, in `ViewController`, add the following function inside `extension ViewController: AgoraRtcEngineDelegate` along with the existing event handlers:

    ```swift
    func rtcEngine(_ engine: AgoraRtcEngineKit, receiveStreamMessageFromUid uid: UInt, streamId: Int, data: Data) {
        showMessage(title: "Success", text: "\(data)")
    }
    ```

1. **Enable a user to start, query, and stop a task**

    In this example, you use two buttons to manage a real-time transcription task.

    1. When a user presses the first button, the <Vpl k="CLIENT" /> requests a `builderToken`. If the request is successful, the <Vpl k="CLIENT" /> starts a real-time transcription task. If a task is already running, you stop the task. To implement this functionality, add the following method to the `ViewController` class:

          ```swift
          // Executed when real-time transcription button is clicked
          @objc func realTimeTranscription(sender: NSButton!) {
              if (!isRealTimeTranscriptionRunning) {
                  getBuilderToken()
              } else {
                  stopRealTimeTranscription()
              }
          }
          ```

    1. When a user presses the query status button, you call the query method to inform the user of the current task status and update the user interface. To implement this functionality, add the following method to the `ViewController` class:

          ```swift
          // Executed when the query real-time transcription button is clicked
          @objc func query(sender: NSButton!) {
              if (isRealTimeTranscriptionRunning) {
                  queryRealTimeTranscription()
              } else {
                  showMessage(title: "Error", text: "Real-time transcription task is not running", delay: 0)
              }
          }
          ```

</PlatformWrapper>
