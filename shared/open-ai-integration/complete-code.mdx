import CodeBlock from '@theme/CodeBlock';

## Complete integration code

This section provides the complete code you need to implement and test integrating Agora's real-time audio streaming and OpenAI's API for processing audio input and generating AI-driven responses.

<details>
<summary>`agent.py`</summary>
<CodeBlock showLineNumbers language="python">
{`import asyncio
import base64
import logging
import os
from builtins import anext
from typing import Any

from agora.rtc.rtc_connection import RTCConnection, RTCConnInfo
from attr import dataclass

from .agora.rtc import Channel, ChatMessage, RtcEngine, RtcOptions
from .logger import setup_logger
from .realtimeapi import messages
from .realtimeapi.client import RealtimeApiClient
from .tools import ClientToolCallResponse, ToolContext
from .utils import PCMWriter

# Set up the logger with color and timestamp support
logger = setup_logger(name=__name__, log_level=logging.INFO)

def _monitor_queue_size(queue: asyncio.Queue, queue_name: str, threshold: int = 5) -> None:
    queue_size = queue.qsize()
    if queue_size > threshold:
        logger.warning(f"Queue {queue_name} size exceeded {threshold}: current size {queue_size}")


async def wait_for_remote_user(channel: Channel) -> int:
    remote_users = list(channel.remote_users.keys())
    if len(remote_users) > 0:
        return remote_users[0]

    future = asyncio.Future[int]()

    channel.once("user_joined", lambda conn, user_id: future.set_result(user_id))

    try:
        # Wait for the remote user with a timeout 
        remote_user = await asyncio.wait_for(future, timeout=15.0)
        return remote_user
    except KeyboardInterrupt:
        future.cancel()
        
    except Exception as e:
        logger.error(f"Error waiting for remote user: {e}")
        raise


@dataclass(frozen=True, kw_only=True)
class InferenceConfig:
    system_message: str | None = None
    turn_detection: messages.ServerVADUpdateParams | None = None  
    voice: messages.Voices | None = None


class RealtimeKitAgent:
    engine: RtcEngine
    channel: Channel
    client: RealtimeApiClient
    audio_queue: asyncio.Queue[bytes] = asyncio.Queue()

    message_queue: asyncio.Queue[messages.ResponseAudioTranscriptDelta] = (
        asyncio.Queue()
    )
    message_done_queue: asyncio.Queue[messages.ResponseAudioTranscriptDone] = (
        asyncio.Queue()
    )
    tools: ToolContext | None = None

    _client_tool_futures: dict[str, asyncio.Future[ClientToolCallResponse]]

    @classmethod
    async def setup_and_run_agent(
        cls,
        *,
        engine: RtcEngine,
        options: RtcOptions,
        inference_config: InferenceConfig,
        tools: ToolContext | None,
    ) -> None:
        channel = engine.create_channel(options)
        await channel.connect()

        try:
            async with RealtimeApiClient(
                base_uri=os.getenv("REALTIME_API_BASE_URI", "wss://api.openai.com"),
                api_key=os.getenv("OPENAI_API_KEY"),
                verbose=False,
            ) as client:
                await client.send_message(
                    messages.SessionUpdate(
                        session=messages.SessionUpdateParams(
                            turn_detection=inference_config.turn_detection,
                            tools=tools.model_description() if tools else [],
                            tool_choice="auto",
                            input_audio_format="pcm16",
                            output_audio_format="pcm16",
                            instructions=inference_config.system_message,
                            voice=inference_config.voice,
                            model=os.environ.get("OPENAI_MODEL", "gpt-4o-realtime-preview-2024-10-01"),
                            modalities=["text", "audio"],
                            temperature=0.8,
                            max_response_output_tokens="inf",
                        )
                    )
                )

                start_session_message = await anext(client.listen())
                # assert isinstance(start_session_message, messages.StartSession)
                logger.info(
                    f"Session started: {start_session_message.session.id} model: {start_session_message.session.model}"
                )

                agent = cls(
                    client=client,
                    tools=tools,
                    channel=channel,
                )
                await agent.run()

        finally:
            await channel.disconnect()
            await client.shutdown()

    def __init__(
        self,
        *,
        client: RealtimeApiClient,
        tools: ToolContext | None,
        channel: Channel,
    ) -> None:
        self.client = client
        self.tools = tools
        self._client_tool_futures = {}
        self.channel = channel
        self.subscribe_user = None
        self.write_pcm = os.environ.get("WRITE_AGENT_PCM", "false") == "true"
        logger.info(f"Write PCM: {self.write_pcm}")

    async def run(self) -> None:
        try:

            def log_exception(t: asyncio.Task[Any]) -> None:
                if not t.cancelled() and t.exception():
                    logger.error(
                        "unhandled exception",
                        exc_info=t.exception(),
                    )

            logger.info("Waiting for remote user to join")
            self.subscribe_user = await wait_for_remote_user(self.channel)
            logger.info(f"Subscribing to user {self.subscribe_user}")
            await self.channel.subscribe_audio(self.subscribe_user)

            async def on_user_left(
                agora_rtc_conn: RTCConnection, user_id: int, reason: int
            ):
                logger.info(f"User left: {user_id}")
                if self.subscribe_user == user_id:
                    self.subscribe_user = None
                    logger.info("Subscribed user left, disconnecting")
                    await self.channel.disconnect()

            self.channel.on("user_left", on_user_left)

            disconnected_future = asyncio.Future[None]()

            def callback(agora_rtc_conn: RTCConnection, conn_info: RTCConnInfo, reason):
                logger.info(f"Connection state changed: {conn_info.state}")
                if conn_info.state == 1:
                    if not disconnected_future.done():
                        disconnected_future.set_result(None)

            self.channel.on("connection_state_changed", callback)

            asyncio.create_task(self.rtc_to_model()).add_done_callback(log_exception)
            asyncio.create_task(self.model_to_rtc()).add_done_callback(log_exception)

            asyncio.create_task(self._process_model_messages()).add_done_callback(
                log_exception
            )

            await disconnected_future
            logger.info("Agent finished running")
        except asyncio.CancelledError:
            logger.info("Agent cancelled")
        except Exception as e:
            logger.error(f"Error running agent: {e}")
            raise

    async def rtc_to_model(self) -> None:
        if self.subscribe_user is None:
            await asyncio.sleep(0.1)

        audio_frames = self.channel.get_audio_frames(self.subscribe_user)

        # Initialize PCMWriter for receiving audio
        pcm_writer = PCMWriter(prefix="rtc_to_model", write_pcm=self.write_pcm)

        try:
            async for audio_frame in audio_frames:
                # Process received audio (send to model)
                _monitor_queue_size(self.audio_queue, "audio_queue")
                await self.client.send_audio_data(audio_frame.data)

                # Write PCM data if enabled
                await pcm_writer.write(audio_frame.data)

                await asyncio.sleep(0)  # Yield control to allow other tasks to run

        except asyncio.CancelledError:
            # Write any remaining PCM data before exiting
            await pcm_writer.flush()
            raise  # Re-raise the exception to propagate cancellation

    async def model_to_rtc(self) -> None:
        # Initialize PCMWriter for sending audio
        pcm_writer = PCMWriter(prefix="model_to_rtc", write_pcm=self.write_pcm)

        try:
            while True:
                # Get audio frame from the model output
                frame = await self.audio_queue.get()

                # Process sending audio (to RTC)
                await self.channel.push_audio_frame(frame)

                # Write PCM data if enabled
                await pcm_writer.write(frame)

        except asyncio.CancelledError:
            # Write any remaining PCM data before exiting
            await pcm_writer.flush()
            raise  # Re-raise the cancelled exception to properly exit the task

    async def _process_model_messages(self) -> None:
        async for message in self.client.listen():
            # logger.info(f"Received message {message=}")
            match message:
                case messages.ResponseAudioDelta():
                    # logger.info("Received audio message")
                    self.audio_queue.put_nowait(base64.b64decode(message.delta))
                    # loop.call_soon_threadsafe(self.audio_queue.put_nowait, base64.b64decode(message.delta))
                    logger.info(f"TMS:ResponseAudioDelta: response_id:{message.response_id},item_id: {message.item_id}")
                case messages.ResponseAudioTranscriptDelta():
                    logger.info(f"Received text message {message=}")
                    asyncio.create_task(self.channel.chat.send_message(
                        ChatMessage(
                            message=message.model_dump_json(), msg_id=message.item_id
                        )
                    ))
                case messages.ResponseAudioTranscriptDone():
                    logger.info(f"Text message done: {message=}")
                    asyncio.create_task(self.channel.chat.send_message(
                        ChatMessage(
                            message=message.model_dump_json(), msg_id=message.item_id
                        )
                    ))
                case messages.InputAudioBufferSpeechStarted():
                    await self.channel.clear_sender_audio_buffer()
                    # clear the audio queue so audio stops playing
                    while not self.audio_queue.empty():
                        self.audio_queue.get_nowait()
                    logger.info(f"TMS:InputAudioBufferSpeechStarted: item_id: {message.item_id}")
                case messages.InputAudioBufferSpeechStopped():
                    pass
                #  InputAudioBufferCommitted
                case messages.InputAudioBufferCommitted():
                    pass
                # ItemCreated
                case messages.ItemCreated():
                    pass
                # ResponseCreated
                case messages.ResponseCreated():
                    pass
                # ResponseDone
                case messages.ResponseDone():
                    pass
                # ResponseOutputItemAdded
                case messages.ResponseOutputItemAdded():
                    pass
                # ResponseContenPartAdded
                case messages.ResponseContentPartAdded():
                    pass
                # ResponseAudioDone
                case messages.ResponseAudioDone():
                    pass
                # ResponseContentPartDone
                case messages.ResponseContentPartDone():
                    pass
                # ResponseOutputItemDone
                case messages.ResponseOutputItemDone():
                    pass
                case _:
                    logger.warning(f"Unhandled message {message=}")
`}
</CodeBlock>
</details>

<details>
<summary>`main.py`</summary>
<CodeBlock showLineNumbers language="python">
{`# Function to run the agent in a new process
import asyncio
import logging
import os
import signal
from multiprocessing import Process

from aiohttp import web
from dotenv import load_dotenv
from pydantic import BaseModel, Field, ValidationError

from .agent import InferenceConfig, RealtimeKitAgent
from .agora.rtc import RtcEngine, RtcOptions
from .logger import setup_logger
from .parse_args import parse_args, parse_args_realtimekit
from .realtimeapi import messages
from .realtimeapi.util import CHANNELS, SAMPLE_RATE

# Set up the logger with color and timestamp support
logger = setup_logger(name=__name__, log_level=logging.INFO)

load_dotenv(override=True)
app_id = os.environ.get("AGORA_APP_ID")
app_cert = os.environ.get("AGORA_APP_CERT")

if not app_id:
    raise ValueError("AGORA_APP_ID must be set in the environment.")


class StartAgentRequestBody(BaseModel):
    channel_name: str = Field(..., description="The name of the channel")
    uid: int = Field(..., description="The UID of the user")
    language: str = Field("en", description="The language of the agent")


class StopAgentRequestBody(BaseModel):
    channel_name: str = Field(..., description="The name of the channel")


# Function to monitor the process and perform extra work when it finishes
async def monitor_process(channel_name: str, process: Process):
    # Wait for the process to finish in a non-blocking way
    await asyncio.to_thread(process.join)

    logger.info(f"Process for channel {channel_name} has finished")

    # Perform additional work after the process finishes
    # For example, removing the process from the active_processes dictionary
    if channel_name in active_processes:
        active_processes.pop(channel_name)

    # Perform any other cleanup or additional actions you need here
    logger.info(f"Cleanup for channel {channel_name} completed")

    logger.info(f"Remaining active processes: {len(active_processes.keys())}")

def handle_agent_proc_signal(signum, frame):
    logger.info(f"Agent process received signal {signal.strsignal(signum)}. Exiting...")
    os._exit(0)


def run_agent_in_process(
    engine_app_id: str,
    engine_app_cert: str,
    channel_name: str,
    uid: int,
    inference_config: InferenceConfig,
):  # Set up signal forwarding in the child process
    signal.signal(signal.SIGINT, handle_agent_proc_signal)  # Forward SIGINT
    signal.signal(signal.SIGTERM, handle_agent_proc_signal)  # Forward SIGTERM
    asyncio.run(
        RealtimeKitAgent.setup_and_run_agent(
            engine=RtcEngine(appid=engine_app_id, appcert=engine_app_cert),
            options=RtcOptions(
                channel_name=channel_name,
                uid=uid,
                sample_rate=SAMPLE_RATE,
                channels=CHANNELS,
                enable_pcm_dump= os.environ.get("WRITE_RTC_PCM", "false") == "true"
            ),
            inference_config=inference_config,
            tools=None,
        )
    )


# HTTP Server Routes
async def start_agent(request):
    try:
        # Parse and validate JSON body using the pydantic model
        try:
            data = await request.json()
            validated_data = StartAgentRequestBody(**data)
        except ValidationError as e:
            return web.json_response(
                {"error": "Invalid request data", "details": e.errors()}, status=400
            )

        # Parse JSON body
        channel_name = validated_data.channel_name
        uid = validated_data.uid
        language = validated_data.language

        # Check if a process is already running for the given channel_name
        if (
            channel_name in active_processes
            and active_processes[channel_name].is_alive()
        ):
            return web.json_response(
                {"error": f"Agent already running for channel: {channel_name}"},
                status=400,
            )

        system_message = ""
        if language == "en":
            system_message = """\
You are a helpful assistant prefer to speak English.\
"""

        inference_config = InferenceConfig(
            system_message=system_message,
            voice=messages.Voices.Shimmer,
            turn_detection=messages.ServerVADUpdateParams(
                type="server_vad", threshold=0.5, prefix_padding_ms=300, silence_duration_ms=200
            ),
        )
        # Create a new process for running the agent
        process = Process(
            target=run_agent_in_process,
            args=(app_id, app_cert, channel_name, uid, inference_config),
        )

        try:
            process.start()
        except Exception as e:
            logger.error(f"Failed to start agent process: {e}")
            return web.json_response(
                {"error": f"Failed to start agent: {e}"}, status=500
            )

        # Store the process in the active_processes dictionary using channel_name as the key
        active_processes[channel_name] = process

        # Monitor the process in a background asyncio task
        asyncio.create_task(monitor_process(channel_name, process))

        return web.json_response({"status": "Agent started!"})

    except Exception as e:
        logger.error(f"Failed to start agent: {e}")
        return web.json_response({"error": str(e)}, status=500)


# HTTP Server Routes: Stop Agent
async def stop_agent(request):
    try:
        # Parse and validate JSON body using the pydantic model
        try:
            data = await request.json()
            validated_data = StopAgentRequestBody(**data)
        except ValidationError as e:
            return web.json_response(
                {"error": "Invalid request data", "details": e.errors()}, status=400
            )

        # Parse JSON body
        channel_name = validated_data.channel_name

        # Find and terminate the process associated with the given channel name
        process = active_processes.get(channel_name)

        if process and process.is_alive():
            logger.info(f"Terminating process for channel {channel_name}")
            await asyncio.to_thread(os.kill, process.pid, signal.SIGKILL)

            return web.json_response(
                {"status": "Agent process terminated", "channel_name": channel_name}
            )
        else:
            return web.json_response(
                {"error": "No active agent found for the provided channel_name"},
                status=404,
            )

    except Exception as e:
        logger.error(f"Failed to stop agent: {e}")
        return web.json_response({"error": str(e)}, status=500)


# Dictionary to keep track of processes by channel name or UID
active_processes = {}


# Function to handle shutdown and process cleanup
async def shutdown(app):
    logger.info("Shutting down server, cleaning up processes...")
    for channel_name, process in active_processes.items():
        if process.is_alive():
            logger.info(
                f"Terminating process for channel {channel_name} (PID: {process.pid})"
            )
            await asyncio.to_thread(os.kill, process.pid, signal.SIGKILL)
            await asyncio.to_thread(process.join)  # Ensure process has terminated
    active_processes.clear()
    logger.info("All processes terminated, shutting down server")


# Signal handler to gracefully stop the application
def handle_signal(signum, frame):
    logger.info(f"Received exit signal {signal.strsignal(signum)}...")

    loop = asyncio.get_running_loop()
    if loop.is_running():
        # Properly shutdown by stopping the loop and running shutdown
        loop.create_task(shutdown(None))
        loop.stop()


# Main aiohttp application setup
async def init_app():
    app = web.Application()

    # Add cleanup task to run on app exit
    app.on_cleanup.append(shutdown)

    app.add_routes([web.post("/start_agent", start_agent)])
    app.add_routes([web.post("/stop_agent", stop_agent)])

    return app


if __name__ == "__main__":
    # Parse the action argument
    args = parse_args()
    # Action logic based on the action argument
    if args.action == "server":
        # Python 3.10+ requires explicitly creating a new event loop if none exists
        try:
            loop = asyncio.get_event_loop()
        except RuntimeError:
            # For Python 3.10+, use this to get a new event loop if the default is closed or not created
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)

        # Start the application using asyncio.run for the new event loop
        app = loop.run_until_complete(init_app())
        web.run_app(app, port=int(os.getenv("SERVER_PORT") or "8080"))
    elif args.action == "agent":
        # Parse RealtimeKitOptions for running the agent
        realtime_kit_options = parse_args_realtimekit()

        # Example logging for parsed options (channel_name and uid)
        logger.info(f"Running agent with options: {realtime_kit_options}")

        inference_config = InferenceConfig(
            system_message="""\
You are a helpful assistant. If asked about the weather make sure to use the provided tool to get that information. \
If you are asked a question that requires a tool, say something like "working on that" and dont provide a concrete response \
until you have received the response to the tool call.\
""",
            voice=messages.Voices.Echo,
            turn_detection=messages.ServerVADUpdateParams(
                type="server_vad", threshold=0.5, prefix_padding_ms=300, silence_duration_ms=200
            ),
        )
        run_agent_in_process(
            engine_app_id=app_id,
            engine_app_cert=app_cert,
            channel_name=realtime_kit_options["channel_name"],
            uid=realtime_kit_options["uid"],
            inference_config=inference_config,
        )
`}
</CodeBlock>
</details>

<details>
<summary>`tools.py`</summary>
<CodeBlock showLineNumbers language="python">
{`import abc
import json
import logging
from typing import Any, Callable, assert_never

from attr import dataclass
from pydantic import BaseModel

from .logger import setup_logger

# Set up the logger with color and timestamp support
logger = setup_logger(name=__name__, log_level=logging.INFO)


@dataclass(frozen=True, kw_only=True)
class LocalFunctionToolDeclaration:
    """Declaration of a tool that can be called by the model, and runs a function locally on the tool context."""

    name: str
    description: str
    parameters: dict[str, Any]
    function: Callable[..., Any]

    def model_description(self) -> dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": self.name,
                "description": self.description,
                "parameters": self.parameters,
            },
        }


@dataclass(frozen=True, kw_only=True)
class PassThroughFunctionToolDeclaration:
    """Declaration of a tool that can be called by the model."""

    name: str
    description: str
    parameters: dict[str, Any]

    def model_description(self) -> dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": self.name,
                "description": self.description,
                "parameters": self.parameters,
            },
        }


ToolDeclaration = LocalFunctionToolDeclaration | PassThroughFunctionToolDeclaration


@dataclass(frozen=True, kw_only=True)
class LocalToolCallExecuted:
    json_encoded_output: str


@dataclass(frozen=True, kw_only=True)
class ShouldPassThroughToolCall:
    decoded_function_args: dict[str, Any]


ExecuteToolCallResult = LocalToolCallExecuted | ShouldPassThroughToolCall


class ToolContext(abc.ABC):
    _tool_declarations: dict[str, ToolDeclaration]

    def __init__(self) -> None:
        # TODO should be an ordered dict
        self._tool_declarations = {}

    def register_function(
        self,
        *,
        name: str,
        description: str = "",
        parameters: dict[str, Any],
        fn: Callable[..., Any],
    ) -> None:
        self._tool_declarations[name] = LocalFunctionToolDeclaration(
            name=name, description=description, parameters=parameters, function=fn
        )

    def register_client_function(
        self,
        *,
        name: str,
        description: str = "",
        parameters: dict[str, Any],
    ) -> None:
        self._tool_declarations[name] = PassThroughFunctionToolDeclaration(
            name=name, description=description, parameters=parameters
        )

    async def execute_tool(
        self, tool_name: str, encoded_function_args: str
    ) -> ExecuteToolCallResult | None:
        tool = self._tool_declarations.get(tool_name)
        if not tool:
            return None

        args = json.loads(encoded_function_args)
        assert isinstance(args, dict)

        if isinstance(tool, LocalFunctionToolDeclaration):
            logger.info(f"Executing tool {tool_name} with args {args}")
            result = await tool.function(**args)
            logger.info(f"Tool {tool_name} executed with result {result}")
            return LocalToolCallExecuted(json_encoded_output=json.dumps(result))

        if isinstance(tool, PassThroughFunctionToolDeclaration):
            return ShouldPassThroughToolCall(decoded_function_args=args)

        assert_never(tool)

    def model_description(self) -> list[dict[str, Any]]:
        return [v.model_description() for v in self._tool_declarations.values()]


class ClientToolCallResponse(BaseModel):
    tool_call_id: str
    result: dict[str, Any] | str | float | int | bool | None = None
`}
</CodeBlock>
</details>

<details>
<summary>`logger.py`</summary>
<CodeBlock showLineNumbers language="python">
{`import logging
from datetime import datetime

import colorlog


def setup_logger(
    name: str,
    log_level: int = logging.INFO,
    log_format: str = "%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    use_color: bool = True
) -> logging.Logger:
    """Sets up and returns a logger with color and timestamp support, including milliseconds."""

    # Create or get a logger with the given name
    logger = logging.getLogger(name)

    # Prevent the logger from propagating to the root logger (disable extra output)
    logger.propagate = False
    
    # Clear existing handlers to avoid duplicate messages
    if logger.hasHandlers():
        logger.handlers.clear()

    # Set the log level
    logger.setLevel(log_level)

    # Create console handler
    handler = logging.StreamHandler()

    # Custom formatter for adding milliseconds
    class CustomFormatter(colorlog.ColoredFormatter):
        def formatTime(self, record, datefmt=None):
            record_time = datetime.fromtimestamp(record.created)
            if datefmt:
                return record_time.strftime(datefmt) + f",{int(record.msecs):03d}"
            else:
                return record_time.strftime("%Y-%m-%d %H:%M:%S") + f",{int(record.msecs):03d}"

    # Use custom formatter that includes milliseconds
    if use_color:
        formatter = CustomFormatter(
            "%(log_color)s" + log_format,
            datefmt="%Y-%m-%d %H:%M:%S",  # Milliseconds will be appended manually
            log_colors={
                "DEBUG": "cyan",
                "INFO": "green",
                "WARNING": "yellow",
                "ERROR": "red",
                "CRITICAL": "bold_red",
            },
        )
    else:
        formatter = CustomFormatter(log_format, datefmt="%Y-%m-%d %H:%M:%S")

    handler.setFormatter(formatter)

    # Add the handler to the logger
    logger.addHandler(handler)

    return logger
`}
</CodeBlock>
</details>

<details>
<summary>`utils.py`</summary>
<CodeBlock showLineNumbers language="python">
{`import asyncio
import functools
from datetime import datetime


def write_pcm_to_file(buffer: bytearray, file_name: str) -> None:
    """Helper function to write PCM data to a file."""
    with open(file_name, "ab") as f:  # append to file
        f.write(buffer)


def generate_file_name(prefix: str) -> str:
    # Create a timestamp for the file name
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    return f"{prefix}_{timestamp}.pcm"


class PCMWriter:
    def __init__(self, prefix: str, write_pcm: bool, buffer_size: int = 1024 * 64):
        self.write_pcm = write_pcm
        self.buffer = bytearray()
        self.buffer_size = buffer_size
        self.file_name = generate_file_name(prefix) if write_pcm else None
        self.loop = asyncio.get_event_loop()

    async def write(self, data: bytes) -> None:
        """Accumulate data into the buffer and write to file when necessary."""
        if not self.write_pcm:
            return

        self.buffer.extend(data)

        # Write to file if buffer is full
        if len(self.buffer) >= self.buffer_size:
            await self._flush()

    async def flush(self) -> None:
        """Write any remaining data in the buffer to the file."""
        if self.write_pcm and self.buffer:
            await self._flush()

    async def _flush(self) -> None:
        """Helper method to write the buffer to the file."""
        if self.file_name:
            await self.loop.run_in_executor(
                None,
                functools.partial(write_pcm_to_file, self.buffer[:], self.file_name),
            )
        self.buffer.clear()
`}
</CodeBlock>
</details>

<details>
<summary>`parse_args.py`</summary>
<CodeBlock showLineNumbers language="python">
{`import argparse
import logging
from typing import TypedDict

from .logger import setup_logger

# Set up the logger with color and timestamp support
logger = setup_logger(name=__name__, log_level=logging.INFO)


class RealtimeKitOptions(TypedDict):
    channel_name: str
    uid: int

def parse_args():
    parser = argparse.ArgumentParser(description="Manage server and agent actions.")
    
    # Create a subparser for actions (server and agent)
    subparsers = parser.add_subparsers(dest="action", required=True)

    # Subparser for the 'server' action (no additional arguments)
    subparsers.add_parser("server", help="Start the server")

    # Subparser for the 'agent' action (with required arguments)
    agent_parser = subparsers.add_parser("agent", help="Run an agent")
    agent_parser.add_argument("--channel_name", required=True, help="Channel Id / must")
    agent_parser.add_argument("--uid", type=int, default=0, help="User Id / default is 0")

    return parser.parse_args()


def parse_args_realtimekit() -> RealtimeKitOptions:
    args = parse_args()
    logger.info(f"Parsed arguments: {args}")

    if args.action == "agent":
        options: RealtimeKitOptions = {"channel_name": args.channel_name, "uid": args.uid}
        return options

    return None
`}
</CodeBlock>
</details>

<Admonition type="info">
The `agent.py` imports key classes from `rtc.py`, which implements the server-side Agora Python Voice SDK, facilitating communication and managing audio streams.
</Admonition>