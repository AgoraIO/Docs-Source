<PlatformWrapper platform="android">
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Since June 2023, Agora has introduced the RTM `2.x` series to meet market and industry demands, providing innovative enhancements in functionality, performance, and user experience:

- **Extended Functionality**: This version introduces functional modules such as `Channel`, `Message`, `Topic`, `Presence`, `Storage`, and `Lock`, expanding coverage for various business scenarios, allowing you to focus more on your business innovations.

- **Performance Improvement**: With a backend architecture overhaul and optimized network connections, the new version delivers long-term low-latency, high-reliability, high-concurrency, and easily scalable real-time network access, alleviating concerns about business quality.

- **Enhanced User Experience**: The API interfaces have been redesigned and streamlined, and documentation, including user guides and API references, has been optimized. Comprehensive example programs support developers in learning to use the SDK efficiently and quickly integrate it into their projects.

This document outlines the main differences between RTM `1.x` and `2.x`, providing relevant example code to facilitate a smooth transition from `1.x` to `2.x`.

## Activate Signaling

To activate Signaling `2.x`, take the following steps:

1. Log in to [<Vg k="CONSOLE"/>](https://console.agora.io/v2)
1. Create a new <Vg k="COMPANY"/> project or choose an existing project from the project list.
1. Select the project on the [Project Management](https://console.agora.io/v2/project-management) page and click the pencil icon to configure it.
1. Go to **All features > Signaling > Basic information** and select a data center in the dropdown.
1. Go to **Subscriptions > Signaling** and subscribe to a plan.
1. Copy the  App ID for your project for use in your code.

## Integration the SDK

Note that the SDK package names for `2.x` and `1.x` are different. Both support integration through CDN and Maven Central. The integration methods are as follows:

- For `1.x`:
    ```java
    dependencies {
        // Replace x.y.z with the specific SDK version, e.g., 1.5.1
        implementation 'io.agora.rtm:rtm-sdk:x.y.z'
    }
    ```

- For v2:
    ```java
    dependencies {
        // Replace x.y.z with the specific SDK version, e.g., 2.1.9
        implementation 'io.agora:agora-rtm:x.y.z'
    }
    ```
    <Admonition type="info" title="Info">
    The `2.x` SDK package name is `agora-rtm`, while the `1.x` SDK package name is `rtm-sdk`.
    </Admonition>

## Initialize RTM Client instance

Compared to `1.x`, `2.x` has made adjustments to initialization parameters, introducing new features such as end-to-end encryption and cloud proxy. Refer to the [API Reference](../reference/api) for details. Additionally, `2.x` provides richer error information when invoking interfaces, allowing you to quickly identify issues. Combine this with [Error Codes](../reference/api#troubleshooting) for efficient troubleshooting.

- Example code for `1.x`:
    ```java
    try {
        rtmClient = RtmClient.createInstance(getBaseContext(), "your_appId", new RtmClientListener() {
            @Override
            public void onConnectionStateChanged(int state, int reason) {
            }
            
            @Override
            public void onMessageReceived(RtmMessage rtmMessage, String peerId) {
            }
            
            @Override
            public void onTokenExpired() {
            }
            
            @Override
            public void onTokenPrivilegeWillExpire() {
            }
            
            @Override
            public void onPeersOnlineStatusChanged(Map<String, Integer> status) {
            }
        });
    } catch (Exception e) {
        throw new RuntimeException("RTM initialization failed!");
    }
    ```

- Example code for `2.x`:
    
    ```java
    RtmConfig rtmConfig = new RtmConfig.Builder("your_appId", "your_userId")
        .eventListener(eventListener)
        .build();
    try {
        rtmClient = RtmClient.create(rtmConfig);
    } catch (Exception e) {
        e.printStackTrace();
    }
    ```

## Log in to Signaling

The login method for `2.x` differs from `1.x`:

- Example code for `1.x`:
    
    ```java
    rtmClient.login("your_token", "your_userId", new ResultCallback<Void>() {
        @Override
        public void onSuccess(Void responseInfo) {
            // Handle login result
        }
        @Override
        public void onFailure(ErrorInfo errorInfo) {
            // Handle errors
        }
    });
    ```

- Example code for `2.x`:

    ```java
    rtmClient.login("your_token", new ResultCallback<Void>() {
        @Override
        public void onSuccess(Void responseInfo) {
            // Handle login result
        }
        
        @Override
        public void onFailure(ErrorInfo errorInfo) {
            // Handle errors
        }
    });
    ```

## Event Notifications

Compared to `1.x`, `2.x` has redesigned the system event notification mechanism and API interfaces, providing more detailed classification and aggregation of event notification types, and optimizing the payload data structure.

`2.x` introduces 7 types of event notifications, as listed below:

| Event Type                                                      | Description                                                            |
|-----------------------------------------------------------------|------------------------------------------------------------------------|
| `onMessageEvent`               | Message Event Notification: Receives notifications for all message events in subscribed Message Channels and Topics.                    |
| `onPresenceEvent`              | User Presence and Custom State Change Event Notification (Presence Event Notification): Receives notifications for Presence events in subscribed Message Channels and joined Stream Channels, including user online/offline status and custom temporary state changes.   |
| `onTopicEvent`                 | Topic Change Event Notification: Receives notifications for Topic changes in joined Stream Channels.                               |
| `onStorageEvent`               | Channel and User Property Event Notification: Receives notifications for Channel Metadata events in subscribed Message Channels and joined Stream Channels, as well as User Metadata events for subscribed users.|
| `onLockEvent`                  | Lock Change Event Notification: Receives notifications for Lock events in subscribed Message Channels and joined Stream Channels.      |
| `onConnection`                | Network Connection State Change Event Notification: Receives notifications for changes in client network connection status.              |
| `onTokenWillExpire`            | Receives notifications for when the client's token is about to expire.                                                                |

For more information on event notifications and payload data structures, see [Event listeners](../reference/api#event-listeners).

Taking the example of listening to channel message events `onMessageEvent`, the example code for `1.x` is as follows:

- For `1.x`:
    ```java
    rtmChannel = rtmClient.createChannel("channelName", new RtmChannelListener() {
        @Override
        public void onMessageReceived(final RtmMessage message, final RtmChannelMember fromMember) {
            // Handle message event
        }
    // Add other event notifications
    });
    ```

- For `2.x`:
    ```java
    RtmEventListener eventListener = new RtmEventListener() {
        @Override
        public void onMessageEvent(MessageEvent event) {
            // Handle message event
        }
    // Add other event notifications
    };
    
    // Option 1: Add event listener when initializing RTM Client instance with create method
    RtmConfig rtmConfig = new RtmConfig.Builder("your_appId", "your_userId")
        .eventListener(eventListener)
        .build();
    try {
        rtmClient = RtmClient.create(rtmConfig);
    } catch (Exception e) {
        e.printStackTrace();
    }
    
    // Option 2: Add event listener at any time during the app's lifecycle
    rtmClient.addEventListener(eventListener);
    ```
The above example code demonstrates significant differences:

- In `1.x`, channel message event notifications are bound to specific channel instances. Users need to call the `createChannel()` method to create a `channel` instance, then register the `onMessageReceived` callback to handle events. The SDK notifies the handler through this callback when a message is received. If multiple channels are involved, this process needs to be repeated for each. In `2.x`, message event notifications are bound to the client instance globally. You call the `addEventListener()` method to register the callback program once, and it applies to all subscribed channels or topics. This simplifies the implementation for handling message events across multiple channels or topics.

- The payload data structure for message event notifications in `2.x` contains more information, aiding in better implementation of custom business logic.

## Channel Messages

In `1.x`, sending channel messages involved the following steps:

1. Create a channel instance.
1. Join the channel.
1. Send the channel message.

This design had a drawback: you couldn't send a message without receiving it because sending and receiving messages were coupled. `2.x` adopts a new design based on Pub/Sub, decoupling the sending and receiving of channel messages. You can send messages to a specific channel without joining, and you can subscribe to a specific channel to receive messages without affecting sending.

- Example code for `1.x`:

    ```java
    // Create channel
    rtmChannel = rtmClient.createChannel("channelName", new RtmChannelListener() {
        @Override
        public void onMessageReceived(final RtmMessage message, final RtmChannelMember fromMember) {
            // Handle message event
        }
        // Add other event notifications
    });
    
    // Join channel
    rtmChannel.join(new ResultCallback<Void>() {
        @Override
        public void onSuccess(Void responseInfo) {
            // Handle join channel result
        }
        
        @Override
        public void onFailure(ErrorInfo errorInfo) {
            // Handle errors
        }
    });
    
    // Send message
    RtmMessage message = rtmClient.createMessage();
    message.setText("Hello World!");
    rtmChannel.sendMessage(message, new ResultCallback<Void>() {
        @Override
        public void onSuccess(Void aVoid) {
            // Handle message send result
        }
        
        @Override
        public void onFailure(ErrorInfo errorInfo) {
            // Handle errors
        }
    });
    ```

- Example code for `2.x`:

    ```java
    // Send message in Message Channel
    String message = "Hello world";
    PublishOptions options = new PublishOptions();
    options.customType = 'PlainText';
    rtmClient.publish("channelName", message, options, new ResultCallback<Void>() {
        @Override
        public void onSuccess(Void responseInfo) {
            // Handle message send result
        }
        @Override
        public void onFailure(ErrorInfo errorInfo) {
            // Handle errors
        }
    });
    
    // Subscribe to Message Channel
    SubscribeOptions options = new SubscribeOptions();
    options.setWithMessage(true);
    rtmClient.subscribe("channelName", options, new ResultCallback<Void>() {
        @Override
        public void onSuccess(Void responseInfo) {
            // Handle subscribe result
        }
        @Override
        public void onFailure(ErrorInfo errorInfo) {
            // Handle errors
        }
    });
    
    // Handle received messages
    rtmClient.addEventListener(new RtmEventListener() {
        @Override
        public void onMessageEvent(MessageEvent event) {
            String channelName = event.getChannelId();
            String content = event.getMessage();
            // Handle received message
        }
        // Add other event notifications
    });
    ```

## Peer-to-Peer Messaging
In `1.x`, the API for peer-to-peer messaging is used to send messages to specific users. For example, if you want to send a message to a user with the ID `Tony`, you can achieve it as follows:
    ```java
    // v1
    // Create an instance of RtmMessage
    RtmMessage message = rtmClient.createMessage();
    // Set the text of the message to "Hello World!"
    message.setText("Hello World!");
    
    // Create options for sending the message
    SendMessageOptions options = new SendMessageOptions();
    
    // Send the message to the peer named "Tony" using the RtmClient
    rtmClient.sendMessageToPeer("Tony", message, options, new ResultCallback<Void>() {
        @Override
        public void onSuccess(Void aVoid) {
            // Handle the success of message sending
        }
        
        @Override
        public void onFailure(ErrorInfo errorInfo) {
            // Handle the failure and provide error information
        }
    });
    ```

The reason for designing this interface in `1.x` is to meet the scenario requirement of end-to-end message transmission. That is, user A only wants to send a message to a specific user B, and user B only wants to receive this message without paying attention to other events. The channel mechanism in `1.x` is a structure design based on the Room mode, and this design cannot achieve the decoupling of sending and receiving messages. Therefore, it cannot meet the requirements of the scenario mentioned earlier.

`2.x` has redesigned the distribution mode of channel messages, adopting the Pub/Sub mode to decouple sending and receiving messages. Based on this, peer-to-peer messages can be implemented using channel messages. The implementation is as follows:

1. Each user subscribes to a private channel named `inbox_` + `UserID` after initialization. This channel is referred to as the inbox, and only the user can subscribe to it; others cannot.

1. When you need to send a peer-to-peer message to a user, you only need to send the message to the user's inbox.

- Example code for `2.x`:
    ```java
    // `2.x`
    // 1. Subscribe to your own inbox
    String channelName = "inbox_Tony";
    SubscribeOptions options = new SubscribeOptions();
    options.setWithMessage(true);
    rtmClient.subscribe(channelName, options, new ResultCallback<Void>() {
        @Override
        public void onSuccess(Void responseInfo) {
            // Handle subscription result
        }
        
        @Override
        public void onFailure(ErrorInfo errorInfo) {
            // Handle errors
        }
    });
    
    // 2. Send a message to Lily
    String channelName = "inbox_Lily";
    String message = "This is a message";
    PublishOptions options = new PublishOptions();
    rtmClient.publish(channelName, message, options, new ResultCallback<Void>() {
        @Override
        public void onSuccess(Void responseInfo) {
            // Handle message send result
        }
        
        @Override
        public void onFailure(ErrorInfo errorInfo) {
            // Handle errors
        }
    });
    ```
    <Admonition type="info" title="Info">
    To receive messages, you also need to implement the `onMessageEvent` event listener function.
    </Admonition>

## Picture and File Messages

Starting from version 1.5.0, to comply with data privacy protection and cost optimization considerations, RTM no longer directly supports the transmission of image and file messages, and related APIs have been deprecated. You can combine RTM with third-party object storage services (such as Amazon S3 or Alibaba Cloud OSS) to build image and file messaging functionality. This approach not only provides an excellent real-time messaging experience but also enables more flexible technical construction solutions, such as implementing CDN static resource acceleration, image text review, and other business requirements. The following example code shows how to use `2.x` and the Amazon S3 object storage service to build and send image and file messages:
```java
// 1. Upload the file to Amazon S3

// 2. Notify RTM
JSONObject jsonObject = new JSONObject();
// File type, the receiving party can parse the message packet structure based on this field
jsonObject.put("type", "file");
// Your bucket name on Amazon S3, the receiving party needs this field to download the file
jsonObject.put("bucket", "uploadParams.Bucket");
// The Key under which the file is stored on Amazon S3, the receiving party needs this field to download the file
jsonObject.put("key", "uploadParams.Key");
// File content type
jsonObject.put("contentType", "uploadParams.ContentType");
// File URL address
jsonObject.put("url", "data.Location");

PublishOptions options = new PublishOptions();
rtmClient.publish("receiver", jsonObject.toString(), options, new ResultCallback<Void>() {
    @Override
    public void onSuccess(Void responseInfo) {
        // Handle message send result
    }

    @Override
    public void onFailure(ErrorInfo errorInfo) {
        // Handle errors
    }
});
```
<Admonition type="info" title="Info">
When using Amazon S3 for static file storage, you need to enter the Amazon S3 console and set the correct user permissions and access policies. Refer to [Access Control Best Practices](https://docs.aws.amazon.com/zh_en/AmazonS3/latest/userguide/access-control-best-practices.html) for details.
</Admonition>

## User presence and custom status

In `1.x`, you could subscribe to or query the online status of multiple users, query the number of users or the list of online members in a channel, and more. `2.x` not only retains these capabilities but also upgrades and extends them based on `1.x`, introducing the Presence module. The Presence module provides the ability to monitor user online and offline events, user temporary state changes, and allows you to obtain real-time information such as:

- When a user joins or leaves a specific channel
- Custom temporary user states and their changes
- Query which channels a specified user has joined or subscribed to
- Query which users have joined a specified channel and their temporary user state data

You can call the `whoNow` method to instantly query the number of online users, the list of online users, and the temporary state of online users in a specified channel.

```java
// `2.x`
PresenceOptions options = new PresenceOptions();
options.setIncludeUserId(true);
options.setIncludeState(true);
options.setPage("yourBookMark");

rtmClient.getPresence().whoNow("channelName", RtmChannelType.MESSAGE, options, new ResultCallback<WhoNowResult>() {
    @Override
    public void onSuccess(WhoNowResult result) {
        // Handle the whoNow call result
    }

    @Override
    public void onFailure(ErrorInfo errorInfo) {
        // Handle errors
    }
});
```

You can call the `whereNow` method to instantly obtain the list of channels in which a specified user is located.
```java
// `2.x`
rtmClient.getPresence().whereNow("Tony", new ResultCallback<ArrayList<ChannelInfo>>() {
    @Override
    public void onSuccess(ArrayList<ChannelInfo> channels) {
        // Handle the whereNow call result
    }

    @Override
    public void onFailure(ErrorInfo errorInfo) {
        // Handle errors
    }
});
```
To meet the requirements of setting user states for business scenarios, `2.x` provides the ability to set temporary user states. You can use the `setState` method to customize temporary user states. Users can add scores, game states, locations, moods, and custom states such as linking status.

```java
// `2.x`
ArrayList<StateItem> stateItems = new ArrayList<>();
stateItems.add(new StateItem("mood", "pumped"));

rtmClient.getPresence().setState("channelName", RtmChannelType.MESSAGE, stateItems, new ResultCallback<Void>() {
    @Override
    public void onSuccess(Void responseInfo) {
        // Handle the setState call result
    }

    @Override
    can someone please explain this to me

    public void onFailure(ErrorInfo errorInfo) {
        // Handle errors
    }
});
```
You can also use the `getState` method to get a user's online status at any time, or use the `removeState` method to delete a user's state. After a user's temporary state changes, the RTM server triggers the `REMOTE_STATE_CHANGED` type of `onPresenceEvent` event notification. See [Temporary User State](../reference/api#presencesetstatepropsag_platform) for specific usage.

n `2.x`, it is more convenient to real-time monitor notifications of users joining, leaving, timing out, or changing temporary states in a channel. You only need to follow these steps:

1. Implement the Presence event listener.

1. When subscribing to a channel, turn on the `withPresence` switch.

```java
// `2.x`
// 1. Implement the Presence event listener
RtmEventListener eventListener = new RtmEventListener() {
        @Override
        public void onPresenceEvent(PresenceEvent event) {
            // Handle Precense event notifications
        }
    };
rtmClient.addEventListener(eventListener);

// 2. When subscribing to a channel, turn on the withPresence switch
SubscribeOptions options = new SubscribeOptions();
options.setWithPresence(true);
rtmClient.subscribe("channelName", options, new ResultCallback<Void>() {
    @Override
    public void onSuccess(Void responseInfo) {
        // Handle message subscription result
    }

    @Override
    public void onFailure(ErrorInfo errorInfo) {
        // Handle errors
    }
});
```
`2.x` has completely redesigned real-time notifications, adopting two modes to notify Presence events to subscribing users in a channel: **Real-time Notification Mode (Announce)** and **Interval Notification Mode (Interval)**. You can determine the conditions for switching between the two modes through the **Announce Max** size in the project settings on the console. The Interval Notification Mode can prevent event clutter caused by too many online users in a channel; see [Event Notification Modes](../reference/api#enumvpresencetypepropsag_platform) for details.

## User metadata and channel metadata

Based on the user and channel property functionality in `1.x`, `2.x` has added capabilities such as version control and lock control, and optimized the API interface to make functionality usage simpler. In `2.x`, user properties and channel properties are placed under the Storage module. Taking setting channel properties as an example, the code snippet is as follows:
```java
// `2.x`
// Create a Metadata instance
Metadata metadata = rtmClient.getStorage().createMetadata();
// Set Major Revision
metadata.setMajorRevision(174298270);
// Add a Metadata Item
metadata.setMetadataItem(new MetadataItem("Apple", "100", 174298200));
// Add another Metadata Item
metadata.setMetadataItem(new MetadataItem("Banana", "200", 174298100));
// Record the timestamp and user ID when setting Metadata Items
MetadataOptions options = new MetadataOptions();
options.setRecordTs(true);
options.setRecordUserId(true);

rtmClient.getStorage().setChannelMetadata("channelName", RtmChannelType.MESSAGE, metadata, options, "lockName", new ResultCallback<Void>() {
    @Override
    public void onSuccess(Void responseInfo) {
        // Handle setChannelMetadata result
    }

    @Override
    public void onFailure(ErrorInfo errorInfo) {
        // Handle errors
    }
});
```
For details on how to get, update, delete channel and user properties, and how to use CAS control, lock control, etc., see [Storage](../develop/storage).

`2.x` distributes channel properties and user properties to users through event notifications of the `onStorageEvent` type. The steps to listen for `onStorageEvent` event notifications are as follows:

1. Implement the Storage event listener.

1. When subscribing to a channel, turn on the `withMetadata` switch.
```java
// `2.x`
// 1. Implement the Storage event listener
RtmEventListener eventListener = new RtmEventListener() {
        @Override
        public void onStorageEvent(StorageEvent event) {
            // Handle Storage event notifications
        }

        // Add other event notifications
    };
rtmClient.addEventListener(eventListener);

// 2. When subscribing to a channel, turn on the withMetadata switch
SubscribeOptions options = new SubscribeOptions();
options.setWithMetadata(true);
rtmClient.subscribe("channelName", options, new ResultCallback<Void>() {
    @Override
    public void onSuccess(Void responseInfo) {
        // Handle message subscription result
    }

    @Override
    public void onFailure(ErrorInfo errorInfo) {
        // Handle errors
    }
});
```

## Restrict access area

In addition to the enhancements presented in this document, Signaling `2.x` introduces an array of additional features. Choose and implement features that fit the needs of your project. The following table outlines key new features of Signaling `2.x`:

- Example code for `1.x`:
    ```java
    // `1.x`
    RtmServiceContext context = new RtmServiceContext();
    context.areaCode = RtmAreaCode.AREA_CODE_GLOB;
    setRtmServiceContext(context);
    ```

- Example code for `2.x`:
    ```java
    // `2.x`
    RtmConfig rtmConfig = new RtmConfig.Builder(appId, userId)
                    .areaCode(EnumSet.of(RtmAreaCode.AS))
                    .eventListener(eventListener)
                    .build();
    ```

## Other New Features

In addition to the enhancements presented in this document, Signaling `2.x` introduces an array of additional features. Choose and implement features that fit the needs of your project. The following table outlines key new features of Signaling `2.x`:

| Feature | Function | API Interface |
|:-------:|:--------:|:-------------:|
| **Setup** | Create Instance | `RtmClient create(RtmConfig config)` |
| | Destroy Instance | `RtmClient.release()` |
| | Token Configuration | `login` interface with `token` parameter |
| | End-to-End Encryption | `RtmEncryptionConfig` with `encryptionMode`, `encryptionKey`, `encryptionSalt` parameters |
| | Presence Timeout Setting | `RtmConfig` with `presenceTimeout` parameter |
| | Log Level Setting | `RtmLogConfig` with `level` parameter |
| | Proxy Configuration | `RtmProxyConfig` with `proxyType`, `server`, `port`, `account`, `password` parameters |
| | Event Listener | `void addEventListener(RtmEventListener listener)`<br/> `void removeEventListener(RtmEventListener listener)` |
| | Login Service | `void login(String token, ResultCallback<Void> resultCallback)` |
| | Logout Service | `void logout(ResultCallback<Void> resultCallback)` |
| | Unsubscribe Channel | `void unsubscribe(String... channelIds)` |
| | Create Stream Channel | `StreamChannel createStreamChannel(String channelName)` |
| | Join Stream Channel | `void join(JoinChannelOptions options, ResultCallback<Void> resultCallback)` |
| | Leave Stream Channel | `void leave(ResultCallback<Void> resultCallback)` |
| **Channel** | Subscribe Channel | `void subscribe(String channelName, SubscribeOptions options, ResultCallback<Void> resultCallback)` |
| | Unsubscribe Channel | `void unsubscribe(String channelName, ResultCallback<Void> resultCallback)` |
| | Create Stream Channel | `StreamChannel createStreamChannel(String channelName)` |
| | Join Stream Channel | `void join(JoinChannelOptions options, ResultCallback<Void> resultCallback)` |
| | Leave Stream Channel | `void leave(ResultCallback<Void> resultCallback)` |
| | Destroy Stream Channel | `streamChannel.release()` |
| **Topic** | Join Topic | `void joinTopic(String topicName, JoinTopicOptions options, ResultCallback<Void> resultCallback)` |
| | Publish Topic Message | `void publishTopicMessage(String topicName, String message, TopicMessageOptions options, ResultCallback<Void> resultCallback)` |
| | Leave Topic | `void leaveTopic(String topicName, ResultCallback<Void> resultCallback)` |
| | Subscribe Topic | `void subscribeTopic(String topicName, TopicOptions options, ResultCallback<SubscribeTopicResult> resultCallback)` |
| | Unsubscribe Topic | `void unsubscribeTopic(String topicName, TopicOptions options, ResultCallback<Void> resultCallback)` |
| **Message** | Send Message | `void publish(String channelName, String message, PublishOptions options, ResultCallback<Void> resultCallback)` |
| **Presence** | Query Channel's Online Users | `void getOnlineUsers(String channelName, RtmChannelType channelType, ResultCallback<GetOnlineUsersResponse> resultCallback)` |
| | Query User's Channel | `void getUserChannels(String userId, ResultCallback<GetUserChannelsResponse> resultCallback)` |
| | Set User's Temporary State | `void setState(String channelName, RtmChannelType channelType, ArrayList<StateItem> items, ResultCallback<Void> resultCallback)` |
| | Query User Temporary State | `void getState(String channelName, RtmChannelType channelType, String userId, ResultCallback<UserState> resultCallback)` |
| | Remove User Temporary State | `void removeState(String channelName, RtmChannelType channelType, ArrayList<String> keys, ResultCallback<Void> resultCallback)` |
| **Storage** | Set Channel Metadata | `void setChannelMetadata(String channelName, RtmChannelType channelType, Metadata data, MetadataOptions options, String lockName, ResultCallback<Void> resultCallback)` |
| | Get Channel Metadata | `void getChannelMetadata(String channelName, RtmChannelType channelType, ResultCallback<Metadata> resultCallback)` |
| | Remove Channel Metadata | `void removeChannelMetadata(String channelName, RtmChannelType channelType, Metadata data, MetadataOptions options, String lockName, ResultCallback<Void> resultCallback)` |
| | Update Channel Metadata | `void updateChannelMetadata(String channelName, RtmChannelType channelType, Metadata data, MetadataOptions options, String lockName, ResultCallback<Void> resultCallback)` |
| | Set User Attributes | `void setUserMetadata(String userId, Metadata data, MetadataOptions options, ResultCallback<Void> resultCallback)` |
| | Get User Attributes | `void getUserMetadata(String userId, ResultCallback<Metadata> resultCallback)` |
| | Remove User Attributes | `void removeUserMetadata(String userId, Metadata data, MetadataOptions options, ResultCallback<Void> resultCallback)` |
| | Update User Attributes | `void updateUserMetadata(String userId, Metadata data, MetadataOptions options, ResultCallback<Void> resultCallback)` |
| | Subscribe User Attributes | `void subscribeUserMetadata(String userId, ResultCallback<Void> resultCallback)` |
| | Unsubscribe User Attributes | `void unsubscribeUserMetadata(String userId, ResultCallback<Void> resultCallback)` |
| **Lock** | Set Lock | `void setLock(String channelName, RtmChannelType channelType, String lockName, long ttl, ResultCallback<Void> resultCallback)` |
| | Acquire Lock | `void acquireLock(String channelName, RtmChannelType channelType, String lockName, boolean retry, ResultCallback<Void> resultCallback)` |
| | Release Lock | `void releaseLock(String channelName, RtmChannelType channelType, String lockName, ResultCallback<Void> resultCallback)` |
| | Revoke Lock | `void revokeLock(String channelName, RtmChannelType channelType, String lockName, String owner, ResultCallback<Void> resultCallback)` |
| | Query Lock | `void getLocks(String channelName, RtmChannelType channelType, ResultCallback<ArrayList<LockDetail>> resultCallback)` |
| | Remove Lock | `void removeLock(String channelName, RtmChannelType channelType, String lockName, ResultCallback<Void> resultCallback)` |

</PlatformWrapper>
