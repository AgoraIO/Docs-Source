import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';

<PlatformWrapper platform="unreal">
The following figure illustrates the essential steps:
<ProductWrapper notAllowed="voice-calling">
<details>
<summary>Quick start sequence</summary>

![](/images/video-sdk/quick-start-sequence.svg)
</details>
</ProductWrapper>
<ProductWrapper product="voice-calling">
<details>
<summary>Quick start sequence</summary>

![](/images/video-sdk/quickstart-voice-call-sequence.svg)
</details>
</ProductWrapper>

### Complete sample code

A complete code sample that implements the basic process of real-time interaction is presented here for your reference. Copy the sample code into your project to quickly implement the basic functions of real-time <Vpd k="PRODUCT"/> interaction. 

To use the sample code, copy each of the following code blocks and paste it in the corresponding file.

<details> 
<summary><code>Project/Source/Project/AgoraWidget.h</code></summary>
<ProductWrapper notAllowed="voice-calling">

<CodeBlock language="cpp" showLineNumbers>
{`#pragma once
#include "CoreMinimal.h"
#include "Blueprint/UserWidget.h"
#if PLATFORM_ANDROID
#include "AndroidPermission/Classes/AndroidPermissionFunctionLibrary.h"
#endif
#include "AgoraPluginInterface.h"
#include "Components/Image.h"
#include "Components/Button.h"
#include "AgoraWidget.generated.h"
UCLASS()
class UNREALLEARNING_API UAgoraWidget : public UUserWidget,public agora::rtc::IRtcEngineEventHandler
{
    GENERATED_BODY()
public:
    // Fill in your app ID
    FString _appID = "";
    // Fill in your channel name
    FString _channelName = "";
    // Fill in a valid authentication token
    FString _token = "";
UPROPERTY(BlueprintReadWrite, meta = (BindWidget))
UImage* RemoteVideo = nullptr;
UPROPERTY(BlueprintReadWrite, meta = (BindWidget))
UImage* LocalVideo = nullptr;
UPROPERTY(VisibleAnywhere, BlueprintReadWrite, meta = (BindWidget))
UButton* JoinBtn = nullptr;
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, meta = (BindWidget))
UButton* LeaveBtn = nullptr;
UFUNCTION(BlueprintCallable)
void Join();
UFUNCTION(BlueprintCallable)
void Leave();
agora::rtc::IRtcEngine* RtcEngineProxy;
void onLeaveChannel(const agora::rtc::RtcStats& stats) override;
void onUserJoined(agora::rtc::uid_t uid, int elapsed) override;
void onUserOffline(agora::rtc::uid_t uid, agora::rtc::USER_OFFLINE_REASON_TYPE reason) override;
void onJoinChannelSuccess(const char* channel, agora::rtc::uid_t uid, int elapsed) override;
private:
    void CheckAndroidPermission();
    void SetupVideoSDKEngine();
    void SetupUI();
protected:
    void NativeConstruct() override;
    void NativeDestruct() override;
};`}
</CodeBlock>
</ProductWrapper>

<ProductWrapper product="voice-calling">
<CodeBlock language="cpp" showLineNumbers>
{`#pragma once
#include "CoreMinimal.h"
#include "Blueprint/UserWidget.h"
#if PLATFORM_ANDROID
#include "AndroidPermission/Classes/AndroidPermissionFunctionLibrary.h"
#endif
#include "AgoraPluginInterface.h"
#include "Components/Image.h"
#include "Components/Button.h"
#include "AgoraWidget.generated.h"

UCLASS()
class UNREALLEARNING_API UAgoraWidget : public UUserWidget, public agora::rtc::IRtcEngineEventHandler
{
    GENERATED_BODY()

public:
    // Fill in your App ID
    FString _appID = "";
    // Fill in your channel name
    FString _channelName = "";
    // Fill in Token
    FString _token = "";

    UPROPERTY(VisibleAnywhere, BlueprintReadWrite, meta = (BindWidget))
    UButton* JoinBtn = nullptr;
    
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, meta = (BindWidget))
    UButton* LeaveBtn = nullptr;

    UFUNCTION(BlueprintCallable)
    void Join();

    UFUNCTION(BlueprintCallable)
    void Leave();

    agora::rtc::IRtcEngine* RtcEngineProxy;

    // Callback triggered when the local user leaves the channel
    void onLeaveChannel(const agora::rtc::RtcStats& stats) override;

    // Callback triggered when a remote broadcaster successfully joins the channel
    void onUserJoined(agora::rtc::uid_t uid, int elapsed) override;

    // Callback triggered when a remote broadcaster leaves the channel
    void onUserOffline(agora::rtc::uid_t uid, agora::rtc::USER_OFFLINE_REASON_TYPE reason) override;

    // Callback triggered when the local user successfully joins the channel
    void onJoinChannelSuccess(const char* channel, agora::rtc::uid_t uid, int elapsed) override;

private:
    // Get Android permissions
    void CheckAndroidPermission();
    
    // Create and initialize IRtcEngine
    void SetupSDKEngine();
    
    // Set up UI elements
    void SetupUI();

protected:
    // Initialize the custom Widget
    void NativeConstruct() override;
    
    // Clean up all session-related resources
    void NativeDestruct() override;
};`}
</CodeBlock>
</ProductWrapper>
</details> 

<details> 
<summary><code>Project/Source/Project/AgoraWidget.cpp</code></summary>
<ProductWrapper product="video-calling">
```cpp
#include "AgoraWidget.h"
void UAgoraWidget::CheckAndroidPermission()
{
#if PLATFORM_ANDROID
    FString pathfromName = UGameplayStatics::GetPlatformName();
    if (pathfromName == "Android")
    {
        TArray AndroidPermission;
        AndroidPermission.Add(FString("android.permission.CAMERA"));
        AndroidPermission.Add(FString("android.permission.RECORD_AUDIO"));
        AndroidPermission.Add(FString("android.permission.READ_PHONE_STATE"));
        AndroidPermission.Add(FString("android.permission.WRITE_EXTERNAL_STORAGE"));
        UAndroidPermissionFunctionLibrary::AcquirePermissions(AndroidPermission);
    }
#endif
}
void UAgoraWidget::SetupVideoSDKEngine()
{
    agora::rtc::RtcEngineContext RtcEngineContext;
    RtcEngineContext.appId = TCHAR_TO_ANSI(*_appID);
    RtcEngineContext.eventHandler = this;
    RtcEngineProxy = agora::rtc::ue::createAgoraRtcEngine();
    RtcEngineProxy->initialize(RtcEngineContext);
}
void UAgoraWidget::SetupUI()
{
    JoinBtn->OnClicked.AddDynamic(this, &UAgoraWidget::Join);
    LeaveBtn->OnClicked.AddDynamic(this, &UAgoraWidget::Leave);
}
void UAgoraWidget::Join()
{
    RtcEngineProxy->enableVideo();
    agora::rtc::ChannelMediaOptions options;
    options.autoSubscribeAudio = true;
    options.autoSubscribeVideo = true;
    options.publishCameraTrack = true;
    options.publishMicrophoneTrack = true;
    options.channelProfile = agora::CHANNEL_PROFILE_TYPE::CHANNEL_PROFILE_COMMUNICATION;
    options.clientRoleType = agora::rtc::CLIENT_ROLE_TYPE::CLIENT_ROLE_BROADCASTER;
    RtcEngineProxy->joinChannel(TCHAR_TO_ANSI(_token), TCHAR_TO_ANSI(_channelName), 0, options);
}
void UAgoraWidget::Leave()
{
    RtcEngineProxy->leaveChannel();
}
void UAgoraWidget::NativeConstruct()
{
    Super::NativeConstruct();
    #if PLATFORM_ANDROID
        CheckAndroidPermission()
    #endif
    SetupUI();
    SetupVideoSDKEngine();
}
void UAgoraWidget::NativeDestruct()
{
    Super::NativeDestruct();
    if (RtcEngineProxy != nullptr)
    {
        RtcEngineProxy->unregisterEventHandler(this);
        RtcEngineProxy->release();
        delete RtcEngineProxy;
        RtcEngineProxy = nullptr;
    }
}
void UAgoraWidget::onUserJoined(agora::rtc::uid_t uid, int elapsed)
{
    agora::rtc::VideoCanvas videoCanvas;
    videoCanvas.view = RemoteVideo;
    videoCanvas.uid = uid;
    videoCanvas.sourceType = agora::rtc::VIDEO_SOURCE_TYPE::VIDEO_SOURCE_REMOTE;
    agora::rtc::RtcConnection connection;
    connection.channelId = TCHAR_TO_ANSI(*_channelName);
    ((agora::rtc::IRtcEngineEx*)RtcEngineProxy)->setupRemoteVideoEx(videoCanvas, connection);
}
void UAgoraWidget::onUserOffline(agora::rtc::uid_t uid, agora::rtc::USER_OFFLINE_REASON_TYPE reason)
{
    agora::rtc::VideoCanvas videoCanvas;
    videoCanvas.view = nullptr;
    videoCanvas.uid = uid;
    videoCanvas.sourceType = agora::rtc::VIDEO_SOURCE_TYPE::VIDEO_SOURCE_REMOTE;
    agora::rtc::RtcConnection connection;
    connection.channelId = TCHAR_TO_ANSI(*_channelName);
    ((agora::rtc::IRtcEngineEx*)RtcEngineProxy)->setupRemoteVideoEx(videoCanvas, connection);
}
void UAgoraWidget::onJoinChannelSuccess(const char* channel, agora::rtc::uid_t uid, int elapsed)
{
    AsyncTask(ENamedThreads::GameThread, =
    {
        UE_LOG(LogTemp, Warning, TEXT("JoinChannelSuccess uid: %u"), uid);
        agora::rtc::VideoCanvas videoCanvas;
        videoCanvas.view = LocalVideo;
        videoCanvas.uid = 0;
        videoCanvas.sourceType = agora::rtc::VIDEO_SOURCE_TYPE::VIDEO_SOURCE_CAMERA;
        RtcEngineProxy->setupLocalVideo(videoCanvas);
    });
}
void UAgoraWidget::onLeaveChannel(const agora::rtc::RtcStats& stats)
{
    AsyncTask(ENamedThreads::GameThread, =
    {
        agora::rtc::VideoCanvas videoCanvas;
        videoCanvas.view = nullptr;
        videoCanvas.uid = 0;
        videoCanvas.sourceType = agora::rtc::VIDEO_SOURCE_TYPE::VIDEO_SOURCE_CAMERA;
        RtcEngineProxy->setupLocalVideo(videoCanvas);
    });
}
```
</ProductWrapper>

<ProductWrapper product="interactive-live-streaming">
<CodeBlock language="cpp" showLineNumbers>
{`#include "AgoraWidget.h"
void UAgoraWidget::CheckAndroidPermission()
{
#if PLATFORM_ANDROID
    FString pathfromName = UGameplayStatics::GetPlatformName();
    if (pathfromName == "Android")
    {
        TArray AndroidPermission;
        AndroidPermission.Add(FString("android.permission.CAMERA"));
        AndroidPermission.Add(FString("android.permission.RECORD_AUDIO"));
        AndroidPermission.Add(FString("android.permission.READ_PHONE_STATE"));
        AndroidPermission.Add(FString("android.permission.WRITE_EXTERNAL_STORAGE"));
        UAndroidPermissionFunctionLibrary::AcquirePermissions(AndroidPermission);
    }
#endif
}
void UAgoraWidget::SetupVideoSDKEngine()
{
    agora::rtc::RtcEngineContext RtcEngineContext;
    RtcEngineContext.appId = TCHAR_TO_ANSI(*_appID);
    RtcEngineContext.eventHandler = this;
    RtcEngineProxy = agora::rtc::ue::createAgoraRtcEngine();
    RtcEngineProxy->initialize(RtcEngineContext);
}
void UAgoraWidget::SetupUI()
{
    JoinBtn->OnClicked.AddDynamic(this, &UAgoraWidget::Join);
    LeaveBtn->OnClicked.AddDynamic(this, &UAgoraWidget::Leave);
}
void UAgoraWidget::Join()
{
    RtcEngineProxy->enableVideo();
    agora::rtc::ChannelMediaOptions options;
    options.autoSubscribeAudio = true;
    options.autoSubscribeVideo = true;
    options.publishCameraTrack = true;
    options.publishMicrophoneTrack = true;
    options.channelProfile = agora::CHANNEL_PROFILE_TYPE::CHANNEL_PROFILE_LIVE_BROADCASTING;
    options.clientRoleType = agora::rtc::CLIENT_ROLE_TYPE::CLIENT_ROLE_BROADCASTER;
    options.audienceLatencyLevel = agora::rtc::AUDIENCE_LATENCY_LEVEL_TYPE::AUDIENCE_LATENCY_LEVEL_ULTRA_LOW_LATENCY;
    RtcEngineProxy->joinChannel(TCHAR_TO_ANSI(_token), TCHAR_TO_ANSI(_channelName), 0, options);
}
void UAgoraWidget::Leave()
{
    RtcEngineProxy->leaveChannel();
}
void UAgoraWidget::NativeConstruct()
{
    Super::NativeConstruct();
    #if PLATFORM_ANDROID
        CheckAndroidPermission()
    #endif
    SetupUI();
    SetupVideoSDKEngine();
}
void UAgoraWidget::NativeDestruct()
{
    Super::NativeDestruct();
    if (RtcEngineProxy != nullptr)
    {
        RtcEngineProxy->unregisterEventHandler(this);
        RtcEngineProxy->release();
        delete RtcEngineProxy;
        RtcEngineProxy = nullptr;
    }
}
void UAgoraWidget::onUserJoined(agora::rtc::uid_t uid, int elapsed)
{
    agora::rtc::VideoCanvas videoCanvas;
    videoCanvas.view = RemoteVideo;
    videoCanvas.uid = uid;
    videoCanvas.sourceType = agora::rtc::VIDEO_SOURCE_TYPE::VIDEO_SOURCE_REMOTE;
    agora::rtc::RtcConnection connection;
    connection.channelId = TCHAR_TO_ANSI(*_channelName);
    ((agora::rtc::IRtcEngineEx*)RtcEngineProxy)->setupRemoteVideoEx(videoCanvas, connection);
}
void UAgoraWidget::onUserOffline(agora::rtc::uid_t uid, agora::rtc::USER_OFFLINE_REASON_TYPE reason)
{
    agora::rtc::VideoCanvas videoCanvas;
    videoCanvas.view = nullptr;
    videoCanvas.uid = uid;
    videoCanvas.sourceType = agora::rtc::VIDEO_SOURCE_TYPE::VIDEO_SOURCE_REMOTE;
    agora::rtc::RtcConnection connection;
    connection.channelId = TCHAR_TO_ANSI(*_channelName);
    ((agora::rtc::IRtcEngineEx*)RtcEngineProxy)->setupRemoteVideoEx(videoCanvas, connection);
}
void UAgoraWidget::onJoinChannelSuccess(const char* channel, agora::rtc::uid_t uid, int elapsed)
{
    AsyncTask(ENamedThreads::GameThread, =
    {
        UE_LOG(LogTemp, Warning, TEXT("JoinChannelSuccess uid: %u"), uid);
        agora::rtc::VideoCanvas videoCanvas;
        videoCanvas.view = LocalVideo;
        videoCanvas.uid = 0;
        videoCanvas.sourceType = agora::rtc::VIDEO_SOURCE_TYPE::VIDEO_SOURCE_CAMERA;
        RtcEngineProxy->setupLocalVideo(videoCanvas);
    });
}
void UAgoraWidget::onLeaveChannel(const agora::rtc::RtcStats& stats)
{
    AsyncTask(ENamedThreads::GameThread, =
    {
        agora::rtc::VideoCanvas videoCanvas;
        videoCanvas.view = nullptr;
        videoCanvas.uid = 0;
        videoCanvas.sourceType = agora::rtc::VIDEO_SOURCE_TYPE::VIDEO_SOURCE_CAMERA;
        RtcEngineProxy->setupLocalVideo(videoCanvas);
    });
}`}
</CodeBlock>
</ProductWrapper>

<ProductWrapper product="broadcast-streaming">
<CodeBlock language="cpp" showLineNumbers>
{`#include "AgoraWidget.h"
void UAgoraWidget::CheckAndroidPermission()
{
#if PLATFORM_ANDROID
    FString pathfromName = UGameplayStatics::GetPlatformName();
    if (pathfromName == "Android")
    {
        TArray AndroidPermission;
        AndroidPermission.Add(FString("android.permission.CAMERA"));
        AndroidPermission.Add(FString("android.permission.RECORD_AUDIO"));
        AndroidPermission.Add(FString("android.permission.READ_PHONE_STATE"));
        AndroidPermission.Add(FString("android.permission.WRITE_EXTERNAL_STORAGE"));
        UAndroidPermissionFunctionLibrary::AcquirePermissions(AndroidPermission);
    }
#endif
}
void UAgoraWidget::SetupVideoSDKEngine()
{
    agora::rtc::RtcEngineContext RtcEngineContext;
    RtcEngineContext.appId = TCHAR_TO_ANSI(*_appID);
    RtcEngineContext.eventHandler = this;
    RtcEngineProxy = agora::rtc::ue::createAgoraRtcEngine();
    RtcEngineProxy->initialize(RtcEngineContext);
}
void UAgoraWidget::SetupUI()
{
    JoinBtn->OnClicked.AddDynamic(this, &UAgoraWidget::Join);
    LeaveBtn->OnClicked.AddDynamic(this, &UAgoraWidget::Leave);
}
void UAgoraWidget::Join()
{
    RtcEngineProxy->enableVideo();
    agora::rtc::ChannelMediaOptions options;
    options.autoSubscribeAudio = true;
    options.autoSubscribeVideo = true;
    options.publishCameraTrack = true;
    options.publishMicrophoneTrack = true;
    options.channelProfile = agora::CHANNEL_PROFILE_TYPE::CHANNEL_PROFILE_LIVE_BROADCASTING;
    options.clientRoleType = agora::rtc::CLIENT_ROLE_TYPE::CLIENT_ROLE_BROADCASTER;
    options.audienceLatencyLevel = agora::rtc::AUDIENCE_LATENCY_LEVEL_TYPE::AUDIENCE_LATENCY_LEVEL_LOW_LATENCY;
    RtcEngineProxy->joinChannel(TCHAR_TO_ANSI(_token), TCHAR_TO_ANSI(_channelName), 0, options);
}
void UAgoraWidget::Leave()
{
    RtcEngineProxy->leaveChannel();
}
void UAgoraWidget::NativeConstruct()
{
    Super::NativeConstruct();
    #if PLATFORM_ANDROID
        CheckAndroidPermission()
    #endif
    SetupUI();
    SetupVideoSDKEngine();
}
void UAgoraWidget::NativeDestruct()
{
    Super::NativeDestruct();
    if (RtcEngineProxy != nullptr)
    {
        RtcEngineProxy->unregisterEventHandler(this);
        RtcEngineProxy->release();
        delete RtcEngineProxy;
        RtcEngineProxy = nullptr;
    }
}
void UAgoraWidget::onUserJoined(agora::rtc::uid_t uid, int elapsed)
{
    agora::rtc::VideoCanvas videoCanvas;
    videoCanvas.view = RemoteVideo;
    videoCanvas.uid = uid;
    videoCanvas.sourceType = agora::rtc::VIDEO_SOURCE_TYPE::VIDEO_SOURCE_REMOTE;
    agora::rtc::RtcConnection connection;
    connection.channelId = TCHAR_TO_ANSI(*_channelName);
    ((agora::rtc::IRtcEngineEx*)RtcEngineProxy)->setupRemoteVideoEx(videoCanvas, connection);
}
void UAgoraWidget::onUserOffline(agora::rtc::uid_t uid, agora::rtc::USER_OFFLINE_REASON_TYPE reason)
{
    agora::rtc::VideoCanvas videoCanvas;
    videoCanvas.view = nullptr;
    videoCanvas.uid = uid;
    videoCanvas.sourceType = agora::rtc::VIDEO_SOURCE_TYPE::VIDEO_SOURCE_REMOTE;
    agora::rtc::RtcConnection connection;
    connection.channelId = TCHAR_TO_ANSI(*_channelName);
    ((agora::rtc::IRtcEngineEx*)RtcEngineProxy)->setupRemoteVideoEx(videoCanvas, connection);
}
void UAgoraWidget::onJoinChannelSuccess(const char* channel, agora::rtc::uid_t uid, int elapsed)
{
    AsyncTask(ENamedThreads::GameThread, =
    {
        UE_LOG(LogTemp, Warning, TEXT("JoinChannelSuccess uid: %u"), uid);
        agora::rtc::VideoCanvas videoCanvas;
        videoCanvas.view = LocalVideo;
        videoCanvas.uid = 0;
        videoCanvas.sourceType = agora::rtc::VIDEO_SOURCE_TYPE::VIDEO_SOURCE_CAMERA;
        RtcEngineProxy->setupLocalVideo(videoCanvas);
    });
}
void UAgoraWidget::onLeaveChannel(const agora::rtc::RtcStats& stats)
{
    AsyncTask(ENamedThreads::GameThread, =
    {
        agora::rtc::VideoCanvas videoCanvas;
        videoCanvas.view = nullptr;
        videoCanvas.uid = 0;
        videoCanvas.sourceType = agora::rtc::VIDEO_SOURCE_TYPE::VIDEO_SOURCE_CAMERA;
        RtcEngineProxy->setupLocalVideo(videoCanvas);
    });
}`}
</CodeBlock>
</ProductWrapper>

<ProductWrapper product="voice-calling">
<CodeBlock language="cpp" showLineNumbers>
{`#include "AgoraWidget.h"

void UAgoraWidget::CheckAndroidPermission()
{
#if PLATFORM_ANDROID
    // Get the platform name
    FString pathfromName = UGameplayStatics::GetPlatformName();
    // Check if the platform is Android
    if (pathfromName == "Android")
    {
        // Array to store Android permissions
        TArray AndroidPermission;
        // Add required permissions
        AndroidPermission.Add(FString("android.permission.RECORD_AUDIO"));
        AndroidPermission.Add(FString("android.permission.READ_PHONE_STATE"));
        AndroidPermission.Add(FString("android.permission.WRITE_EXTERNAL_STORAGE"));
        // Request permissions
        UAndroidPermissionFunctionLibrary::AcquirePermissions(AndroidPermission);
    }
#endif
}

void UAgoraWidget::SetupSDKEngine()
{
    // Create RtcEngineContext
    agora::rtc::RtcEngineContext RtcEngineContext;
    // Set App ID
    RtcEngineContext.appId = TCHAR_TO_ANSI(*_appID);
    // Set event handler
    RtcEngineContext.eventHandler = this;
    // Create and initialize RtcEngineProxy
    RtcEngineProxy = agora::rtc::ue::createAgoraRtcEngine();
    RtcEngineProxy->initialize(RtcEngineContext);
}

void UAgoraWidget::SetupUI()
{
    // Bind event handlers to UI buttons
    JoinBtn->OnClicked.AddDynamic(this, &UAgoraWidget::Join);
    LeaveBtn->OnClicked.AddDynamic(this, &UAgoraWidget::Leave);
}

void UAgoraWidget::Join()
{
    // Set channel media options
    agora::rtc::ChannelMediaOptions options;
    // Automatically subscribe to all audio streams
    options.autoSubscribeAudio = true;
    // Publish the audio collected by the microphone
    options.publishMicrophoneTrack = true;
    // Set channel profile to live broadcasting
    options.channelProfile = agora::CHANNEL_PROFILE_TYPE::CHANNEL_PROFILE_COMMUNICATION;
    // Set user role to broadcaster
    options.clientRoleType = agora::rtc::CLIENT_ROLE_TYPE::CLIENT_ROLE_BROADCASTER;
    // Join the channel
    RtcEngineProxy->joinChannel(TCHAR_TO_ANSI(_token), TCHAR_TO_ANSI(_channelName), 0 , options);
}

void UAgoraWidget::Leave()
{
    // Leave the channel
    RtcEngineProxy->leaveChannel();
}

void UAgoraWidget::NativeConstruct()
{
    Super::NativeConstruct();
#if PLATFORM_ANDROID
    // Check and request Android permissions
    CheckAndroidPermission();
#endif
    // Setup UI elements
    SetupUI();
    // Setup Agora SDK engine
    SetupSDKEngine();
}

void UAgoraWidget::NativeDestruct()
{
    Super::NativeDestruct();
    // Clean up resources
    if (RtcEngineProxy != nullptr)
    {
        RtcEngineProxy->unregisterEventHandler(this);
        RtcEngineProxy->release();
        delete RtcEngineProxy;
        RtcEngineProxy = nullptr;
    }
}

void UAgoraWidget::onUserJoined(agora::rtc::uid_t uid, int elapsed)
{
    // Callback when a remote user joins the channel
    agora::rtc::RtcConnection connection;
    connection.channelId = TCHAR_TO_ANSI(*_channelName);
}

void UAgoraWidget::onUserOffline(agora::rtc::uid_t uid, agora::rtc::USER_OFFLINE_REASON_TYPE reason)
{
    // Callback when a remote user leaves the channel
    agora::rtc::RtcConnection connection;
    connection.channelId = TCHAR_TO_ANSI(*_channelName);
}

void UAgoraWidget::onJoinChannelSuccess(const char* channel, agora::rtc::uid_t uid, int elapsed)
{
    // Callback when the local user successfully joins the channel
    AsyncTask(ENamedThreads::GameThread, =
    {
        UE_LOG(LogTemp, Warning, TEXT("JoinChannelSuccess uid: %u"), uid);
    });
}`}
</CodeBlock>
</ProductWrapper>
</details> 

<details> 
<summary><code>Project/Source/Project/Project.Build.cs</code></summary>

<CodeBlock language="csharp" showLineNumbers>
{`using UnrealBuildTool;
public class UnrealLearning : ModuleRules
{
    public UnrealLearning(ReadOnlyTargetRules Target) : base(Target)
    {
        PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;
    PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore","AgoraPlugin" });
    if (Target.Platform == UnrealTargetPlatform.Android)
    {
        PrivateDependencyModuleNames.AddRange(new string[] { "AndroidPermission" });
    }
    PrivateDependencyModuleNames.AddRange(new string[] {  });
    // Uncomment if you are using Slate UI
    // PrivateDependencyModuleNames.AddRange(new string[] { "Slate", "SlateCore" });
    // Uncomment if you are using online features
    // PrivateDependencyModuleNames.Add("OnlineSubsystem");
    // To include OnlineSubsystemSteam, add it to the plugins section in your uproject file with the Enabled attribute set to true
    }
}`}
</CodeBlock>
</details> 

To understand the sample code, refer to the following sections.

### Implement the system logic
This section describes how to add the C++ libraries required to implement <Vpd k="PRODUCT"/> in your project.

1. Add the <Vg k="COMPANY" /> dependency library

    In `Project/Source/Project/Project.Build.cs`, add the `AgoraPlugin` using `PublicDependencyModuleNames.AddRange()`.

    ```cpp
    // Add the AgoraPlugin library
    PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore","AgoraPlugin" });
    ```

1. Create a new C++ class and generate header files and library files

    In the Unreal Editor, select **Tools > New C++ Class**, then select **All Classes**, find **UserWidget** and name it **AgoraWidget**. Click **Create Class** to create the class. A new C++ class is added to your project and you see `AgoraWidget.h` and `AgoraWidget.cpp` files.

1. Initialize custom Widget

    Add the following code to the `Project/Source/AgoraWidget.h` file:

    ```cpp
    protected:
    // Initialize custom Widget
    void NativeConstruct() override;
    ```

1. Associate C++ classes and Widgets

    In Unreal Editor, click **Content Drawer**, select **Class Settings > Graph**, and set the **Parent Class** under **Class Options** to **AgoraWidget**.

        ![](/images/video-sdk/associate-classes-unreal.png)

### Handle permissionsâ€‹

Follow the steps for your target platform:

<details>
<summary>Android</summary>

Add the `AndroidPermission` library to obtain device and network permissions:

1. Add the following code to the `Project/Source/Project/AgoraWidget.h` file:

    ```cpp
    #if PLATFORM_ANDROID
    #include "AndroidPermission/Classes/AndroidPermissionFunctionLibrary.h"
    #endif
    ```

1. Add the `AndroidPermission` library to the `Project/Source/Project/Project.Build.cs` file:

    ```cpp
    if (Target.Platform == UnrealTargetPlatform.Android)
    {
        PrivateDependencyModuleNames.AddRange(new string[] { "AndroidPermission" });
    }
    ```

1. To check whether Android permissions have been granted, add the `CheckAndroidPermission` method and its implementation to the `AgoraWidget.h` and `AgoraWidget.cpp` files. Add the following code to the respective files:
    
* `AgoraWidget.h`

    ```cpp
    private:
        // Get Android permissions
        void CheckAndroidPermission();
    ```

* `AgoraWidget.cpp`

    <ProductWrapper notAllowed="voice-calling">
    ```cpp
    // Add the following code after #include "AgoraWidget.h"
    void UAgoraWidget::CheckAndroidPermission()
    {
    #if PLATFORM_ANDROID
        FString pathfromName = UGameplayStatics::GetPlatformName();
        if (pathfromName == "Android")
        {
            TArray<FString> AndroidPermission;
            AndroidPermission.Add(FString("android.permission.CAMERA"));
            AndroidPermission.Add(FString("android.permission.RECORD_AUDIO"));
            AndroidPermission.Add(FString("android.permission.READ_PHONE_STATE"));
            AndroidPermission.Add(FString("android.permission.WRITE_EXTERNAL_STORAGE"));
            AndroidPermission.Add(FString("android.permission.ACCESS_WIFI_STATE"));
            AndroidPermission.Add(FString("android.permission.ACCESS_NETWORK_STATE"));
            UAndroidPermissionFunctionLibrary::AcquirePermissions(AndroidPermission);
        }
    #endif
    }

    void UAgoraWidget::NativeConstruct()
    {
        Super::NativeConstruct();
    #if PLATFORM_ANDROID
        CheckAndroidPermission()
    #endif
    }
    ```
    </ProductWrapper>

    <ProductWrapper product="voice-calling">
    ```cpp
    // Add the following code after #include "AgoraWidget.h"
    void UAgoraWidget::CheckAndroidPermission()
    {
    #if PLATFORM_ANDROID
        FString pathfromName = UGameplayStatics::GetPlatformName();
        if (pathfromName == "Android")
        {
            TArray<FString> AndroidPermission;
            AndroidPermission.Add(FString("android.permission.RECORD_AUDIO"));
            AndroidPermission.Add(FString("android.permission.READ_PHONE_STATE"));
            AndroidPermission.Add(FString("android.permission.WRITE_EXTERNAL_STORAGE"));
            AndroidPermission.Add(FString("android.permission.ACCESS_WIFI_STATE"));
            AndroidPermission.Add(FString("android.permission.ACCESS_NETWORK_STATE"));
            UAndroidPermissionFunctionLibrary::AcquirePermissions(AndroidPermission);
        }
    #endif
    }

    void UAgoraWidget::NativeConstruct()
    {
        Super::NativeConstruct();
    #if PLATFORM_ANDROID
        CheckAndroidPermission()
    #endif
    }
    ```
    </ProductWrapper>

</details>

<p/>

<details>
<summary>iOS and macOS</summary>

1. Refer to [How to add the permissions required for real-time interaction to an Unreal Engine project?](./)

1. In `Project/Source/Project.Target.cs`, add the following code:

    ```cpp
    public class unrealstartTarget : TargetRules
    {
        public unrealstartTarget( TargetInfo Target) : base(Target)
        {
            Type = TargetType.Game;
            DefaultBuildSettings = BuildSettingsVersion.V2;
            if (Target.Platform == UnrealTargetPlatform.IOS)
            {
                bOverrideBuildEnvironment = true;
                GlobalDefinitions.Add("FORCE_ANSI_ALLOCATOR=1")
            }
            ExtraModuleNames.AddRange( new string[] { "unrealstart" } );
        }
    }
    ```
</details>
    
### Import libraries

To import <Vg k="COMPANY" /> library, add the following to `AgoraWidget.h`:

    ```cpp
    #include "AgoraPluginInterface.h"
    ```

### Declare variables

1. Declare variables for creating an engine instance and joining a channel.

    Add the following code after `GENERATED_BODY()`. The variable name must be consistent with the name of the control used to create the UI:
    <ProductWrapper notAllowed="voice-calling">
    ```cpp
    // Fill in your app ID
    FString _appID = "";
    // Fill in your channel name
    FString _channelName = "";
    // Fill in a valid authentication token
    FString _token = "";
    // Define a global variable for IRtcEngine 
    agora::rtc::IRtcEngine* RtcEngineProxy;
    ```
    </ProductWrapper>
    <ProductWrapper product="voice-calling">
    ```cpp
        // Fill in your app ID
    FString _appID = "";
    // Fill in your channel name
    FString _channelName = "";
    // Fill in a valid authentication token
    FString _token = "";
    // Define a global variable for IRtcEngine 
    agora::rtc::IRtcEngine* RtcEngineProxy;
    ```
    </ProductWrapper>

### Initialize the engine

<ProductWrapper notAllowed="voice-calling">

Before calling other `IRtcEngine` methods, you create and initialize an `IRtcEngine` instance. Add the `SetupVideoSDKEngine` declaration and implementation to the following files: 
* `AgoraWidget.h`

    ```cpp
    private:
        // Create and initialize IRtcEngine
        void SetupVideoSDKEngine();
    ```
</ProductWrapper>
<ProductWrapper product="voice-calling">
Before calling other `IRtcEngine` methods, you create and initialize an `IRtcEngine` instance. Add the `SetupSDKEngine` declaration and implementation to the following files: 
* `AgoraWidget.h`

    ```cpp
    // Add code after private:  
    private:
    // Get Android permissions (only required for Android platform)
    void CheckAndroidPermission();
    // Create and initialize IRtcEngine
    void SetupSDKEngine();
    ```
</ProductWrapper>

* `AgoraWidget.cpp`

    Add this code after `#include AgoraWidget.h`
    <ProductWrapper notAllowed="voice-calling">
    ```cpp
    void UAgoraWidget::SetupVideoSDKEngine()
    {
        agora::rtc::RtcEngineContext RtcEngineContext;

        RtcEngineContext.appId = TCHAR_TO_ANSI(*_appID);
        RtcEngineContext.eventHandler = this;

        // Create IRtcEngine instance
        RtcEngineProxy = agora::rtc::ue::createAgoraRtcEngine();
        // Initialize IRtcEngine
        RtcEngineProxy->initialize(RtcEngineContext);
    }
    ```
    </ProductWrapper>
    <ProductWrapper product="voice-calling">
    ```cpp
    void UAgoraWidget::SetupSDKEngine()
    {
        agora::rtc::RtcEngineContext RtcEngineContext;

        RtcEngineContext.appId = TCHAR_TO_ANSI(*_appID);
        RtcEngineContext.eventHandler = this;

        // Create IRtcEngine instance
        RtcEngineProxy = agora::rtc::ue::createAgoraRtcEngine();
        // Initialize IRtcEngine
        RtcEngineProxy->initialize(RtcEngineContext);
    }
    ```
    </ProductWrapper>

<Admonition type="caution" title="Note">
Before initializing the SDK, ensure that the user fully understands and agrees to the relevant privacy policy.
</Admonition>

### Join and leave a channel
To enable local users to join and leave a channel, add the `Join` and `Leave` method declarations and implementations to the following files: 

* `AgoraWidget.h`

    ```cpp
    // Add the following code after UPROPERTY:
    UFUNCTION(BlueprintCallable)
    void Join();
    UFUNCTION(BlueprintCallable)
    void Leave();
    ```

* `AgoraWidget.cpp`
    
    Add the following code after `CheckAndroidPermission()`.
    <ProductWrapper product="interactive-live-streaming">
    ```cpp
    void UAgoraWidget::Join()
    {
        // Enable the video module
        RtcEngineProxy->enableVideo();
        // Set channel media options
        agora::rtc::ChannelMediaOptions options;
        // Automatically subscribe to all audio streams
        options.autoSubscribeAudio = true;
        // Automatically subscribe to all video streams
        options.autoSubscribeVideo = true;
        // Publish video captured by the camera
        options.publishCameraTrack = true;
        // Publish audio captured by the microphone
        options.publishMicrophoneTrack = true;
        // Set the channel profile to live broadcasting
        options.channelProfile = agora::CHANNEL_PROFILE_TYPE::CHANNEL_PROFILE_LIVE_BROADCASTING;
        // Set the user role as host or audience
        options.clientRoleType = agora::rtc::CLIENT_ROLE_TYPE::CLIENT_ROLE_BROADCASTER;
        // Set the latency level for optimal experience
        options.audienceLatencyLevel = agora::rtc::AUDIENCE_LATENCY_LEVEL_TYPE::AUDIENCE_LATENCY_LEVEL_ULTRA_LOW_LATENCY;
        // Join a channel
        RtcEngineProxy->joinChannel(TCHAR_TO_ANSI(*_token), TCHAR_TO_ANSI(*_channelName), 0, options);
    }

    void UAgoraWidget::Leave()
    {
        // Leave the channel
        RtcEngineProxy->leaveChannel();
    }
    ```
    </ProductWrapper>
    <ProductWrapper product="broadcast-streaming">
    ```cpp
    void UAgoraWidget::Join()
    {
        // Enable the video module
        RtcEngineProxy->enableVideo();
        // Set channel media options
        agora::rtc::ChannelMediaOptions options;
        // Automatically subscribe to all audio streams
        options.autoSubscribeAudio = true;
        // Automatically subscribe to all video streams
        options.autoSubscribeVideo = true;
        // Publish video captured by the camera
        options.publishCameraTrack = true;
        // Publish audio captured by the microphone
        options.publishMicrophoneTrack = true;
        // Set the channel profile to live broadcasting
        options.channelProfile = agora::CHANNEL_PROFILE_TYPE::CHANNEL_PROFILE_LIVE_BROADCASTING;
        // Set the user role as host or audience
        options.clientRoleType = agora::rtc::CLIENT_ROLE_TYPE::CLIENT_ROLE_BROADCASTER;
        // Set the latency level for optimal experience
        options.audienceLatencyLevel = agora::rtc::AUDIENCE_LATENCY_LEVEL_TYPE::AUDIENCE_LATENCY_LEVEL_LOW_LATENCY;
        // Join a channel
        RtcEngineProxy->joinChannel(TCHAR_TO_ANSI(*_token), TCHAR_TO_ANSI(*_channelName), 0, options);
    }

    void UAgoraWidget::Leave()
    {
        // Leave the channel
        RtcEngineProxy->leaveChannel();
    }
    ```
    </ProductWrapper>
    <ProductWrapper product="video-calling">
    ```cpp
    void UAgoraWidget::Join()
    {
        // Enable the video module
        RtcEngineProxy->enableVideo();
        // Set channel media options
        agora::rtc::ChannelMediaOptions options;
        // Automatically subscribe to all audio streams
        options.autoSubscribeAudio = true;
        // Automatically subscribe to all video streams
        options.autoSubscribeVideo = true;
        // Publish video captured by the camera
        options.publishCameraTrack = true;
        // Publish audio captured by the microphone
        options.publishMicrophoneTrack = true;        
        // Set the channel profile to live broadcasting
        options.channelProfile = agora::CHANNEL_PROFILE_TYPE::CHANNEL_PROFILE_COMMUNICATION;
        // Set the user role as host or audience
        options.clientRoleType = agora::rtc::CLIENT_ROLE_TYPE::CLIENT_ROLE_BROADCASTER;
        // Join a channel
        RtcEngineProxy->joinChannel(TCHAR_TO_ANSI(*_token), TCHAR_TO_ANSI(*_channelName), 0, options);
    }

    void UAgoraWidget::Leave()
    {
        // Leave the channel
        RtcEngineProxy->leaveChannel();
    }
    ```
    </ProductWrapper>
    <ProductWrapper product="voice-calling">
    ```cpp
    void UAgoraWidget::Join()
    {
        // Set channel media options
        agora::rtc::ChannelMediaOptions options;
        // Automatically subscribe to all audio streams
        options.autoSubscribeAudio = true;
        // Publish video captured by the camera
        options.publishMicrophoneTrack = true;        
        // Set the channel profile to live broadcasting
        options.channelProfile = agora::CHANNEL_PROFILE_TYPE::CHANNEL_PROFILE_COMMUNICATION;
        // Set the user role as host or audience
        options.clientRoleType = agora::rtc::CLIENT_ROLE_TYPE::CLIENT_ROLE_AUDIENCE;
        // Join a channel
        RtcEngineProxy->joinChannel(TCHAR_TO_ANSI(*_token), TCHAR_TO_ANSI(*_channelName), 0, options);
    }

    void UAgoraWidget::Leave()
    {
        // Leave the channel
        RtcEngineProxy->leaveChannel();
    }
    ```
    </ProductWrapper>


### Implement callbacks
<ProductWrapper notAllowed="voice-calling">
You implement callbacks to handle and respond to events triggered by the `IRtcEngine` instance. For example, you set up video displays when local and remote users join a channel and stop videos after they leave. Override the following callbacks and add their implementations to the `AgoraWidget` files:
</ProductWrapper>
<ProductWrapper product="voice-calling">
You implement callbacks to handle and respond to events triggered by the `IRtcEngine` instance. For example, you subscribe to the remote audio stream when a remote user joins the channel. Override the following callbacks and add their implementations to the `AgoraWidget` files:
</ProductWrapper>

* `AgoraWidget.h`

    Add the following code after `agora::rtc::IRtcEngine* RtcEngineProxy;`.

    ```cpp
    // This callback is triggered when the local user leaves the channel
    void onLeaveChannel(const agora::rtc::RtcStats& stats) override;

    // This callback is triggered when a remote user joins the channel
    void onUserJoined(agora::rtc::uid_t uid, int elapsed) override;

    // This callback is triggered when a remote user leaves the channel
    void onUserOffline(agora::rtc::uid_t uid, agora::rtc::USER_OFFLINE_REASON_TYPE reason) override;

    // This callback is triggered when the local user joins the channel
    void onJoinChannelSuccess(const char* channel, agora::rtc::uid_t uid, int elapsed) override;
    ```

* `AgoraWidget.cpp`

    <ProductWrapper notAllowed="voice-calling">
    Add the following code after `SetupVideoSDKEngine()`:
    ```cpp
    // Implement the callback triggered after a remote user joins the channel
    void UAgoraWidget::onUserJoined(agora::rtc::uid_t uid, int elapsed)
    {
        // Set up remote video 
        agora::rtc::VideoCanvas videoCanvas;
        videoCanvas.view = RemoteVideo;
        videoCanvas.uid = uid;
        videoCanvas.sourceType = agora::rtc::VIDEO_SOURCE_TYPE::VIDEO_SOURCE_REMOTE;

        agora::rtc::RtcConnection connection;
        connection.channelId = TCHAR_TO_ANSI(*_channelName);

        ((agora::rtc::IRtcEngineEx*)RtcEngineProxy)->setupRemoteVideoEx(videoCanvas, connection);
    }

    // Implement the callback triggered when a remote user leaves the channel
    void UAgoraWidget::onUserOffline(agora::rtc::uid_t uid, agora::rtc::USER_OFFLINE_REASON_TYPE reason)
    {
        // Stop remote video 
        agora::rtc::VideoCanvas videoCanvas;
        videoCanvas.view = nullptr;
        videoCanvas.uid = uid;
        videoCanvas.sourceType = agora::rtc::VIDEO_SOURCE_TYPE::VIDEO_SOURCE_REMOTE;

        agora::rtc::RtcConnection connection;
        connection.channelId = TCHAR_TO_ANSI(*_channelName);

        ((agora::rtc::IRtcEngineEx*)RtcEngineProxy)->setupRemoteVideoEx(videoCanvas, connection);
    }

    // Implement the callback triggered when the local user joins the channel
    void UAgoraWidget::onJoinChannelSuccess(const char* channel, agora::rtc::uid_t uid, int elapsed)
    {
        AsyncTask(ENamedThreads::GameThread, [=]()
        {
            UE_LOG(LogTemp, Warning, TEXT("JoinChannelSuccess uid: %u"), uid);
            // Set up local video
            agora::rtc::VideoCanvas videoCanvas;
            videoCanvas.view = LocalVideo;
            videoCanvas.uid = 0;
            videoCanvas.sourceType = agora::rtc::VIDEO_SOURCE_TYPE::VIDEO_SOURCE_CAMERA;
            RtcEngineProxy->setupLocalVideo(videoCanvas);
        });
    }

    // Implement the callback triggered when the local user leaves the channel
    void UAgoraWidget::onLeaveChannel(const agora::rtc::RtcStats& stats)
    {
        AsyncTask(ENamedThreads::GameThread, [=]()
        {
            agora::rtc::VideoCanvas videoCanvas;
            videoCanvas.view = nullptr;
            videoCanvas.uid = 0;
            videoCanvas.sourceType = agora::rtc::VIDEO_SOURCE_TYPE::VIDEO_SOURCE_CAMERA;
            RtcEngineProxy->setupLocalVideo(videoCanvas);
        });
    }
    ```
    </ProductWrapper>
    <ProductWrapper product="voice-calling">
    Add the following code after `SetupSDKEngine()`:

    ```cpp
    void UAgoraWidget::onUserJoined(agora::rtc::uid_t uid, int elapsed)
    {
        // Callback when a remote user joins the channel
        agora::rtc::RtcConnection connection;
        connection.channelId = TCHAR_TO_ANSI(*_channelName);
    }
    
    void UAgoraWidget::onUserOffline(agora::rtc::uid_t uid, agora::rtc::USER_OFFLINE_REASON_TYPE reason)
    {
        // Callback when a remote user leaves the channel
        agora::rtc::RtcConnection connection;
        connection.channelId = TCHAR_TO_ANSI(*_channelName);
    }
    
    void UAgoraWidget::onJoinChannelSuccess(const char* channel, agora::rtc::uid_t uid, int elapsed)
    {
        // Callback when the local user successfully joins the channel
        AsyncTask(ENamedThreads::GameThread, =
        {
            UE_LOG(LogTemp, Warning, TEXT("JoinChannelSuccess uid: %u"), uid);
        });
    }
    void UAgoraWidget::onLeaveChannel(const agora::rtc::RtcStats& stats)
    {
        // Callback when the local user successfully leaves the channel

    }
    ```
    </ProductWrapper>
    
### Release resources
When the local user leaves the channel, or exits the <Vpl k="CLIENT" />, you release memory by calling the `release` method of `IRtcEngine`. Override the `NativeDestruct()` method and add its implementation as follows: 

* `AgoraWidget.h`

    ```cpp
    void NativeDestruct() override;
    ```

* `AgoraWidget.cpp`
    
    ```cpp
    void UAgoraWidget::NativeDestruct()
    {
        Super::NativeDestruct();
        if (RtcEngineProxy != nullptr)
        {
            RtcEngineProxy->unregisterEventHandler(this);
            RtcEngineProxy->release();
            delete RtcEngineProxy;

            RtcEngineProxy = nullptr;
        }
    }
    ```

</PlatformWrapper>