<PlatformWrapper platform="react-native">

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';

A complete code sample that implements the basic features of <Vpd k="NAME" /> is presented here for your reference. To use the sample code, create a file named `signaling.tsx` and add the following code.

<details>
<summary>Complete sample code for <Vpd k="PRODUCT" /></summary>
<CodeBlock language="tsx" showLineNumbers>
{`import React, { useEffect, useRef, useState } from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  FlatList,
  KeyboardAvoidingView,
  Platform,
  StyleSheet,
} from 'react-native';
import {
  createAgoraRtmClient,
  RtmConfig,
  RTM_AREA_CODE,
  RTMProvider,
  useRtm,
  useLogin,
  MessageEvent,
  RTM_CHANNEL_TYPE,
  RTM_MESSAGE_TYPE,
  useRtmEvent,
} from 'agora-react-native-rtm';

// Configuration constants
const APP_ID = 'YOUR_APP_ID';
const CHANNEL_ID = 'TYPE_CHANNEL_ID';
const TOKEN = 'AUTH_TOKEN'; // You can use the token builder app to generate a token
const USER_ID = 'A_UNIQUE_UID';

interface ChatMessage {
  id: number;
  text: string;
  sender: string;
  timestamp?: number;
}

export default function SignalingEngine() {
  const client = createAgoraRtmClient(
    new RtmConfig({
      userId: USER_ID,
      appId: APP_ID,
      useStringUserId: true,
      areaCode: RTM_AREA_CODE.RTM_AREA_CODE_AS,
    })
  );

  return (
    <RTMProvider client={client}>
      <Signaling />
    </RTMProvider>
  );
}

function Signaling() {
  const flatListRef = useRef<FlatList<ChatMessage>>(null);
  const [message, setMessage] = useState('');
  const [messages, setMessages] = useState<ChatMessage[]>([]);

  const engine = useRtm();
  useLogin(engine, { token: TOKEN });

  useRtmEvent(engine, 'message', (evt) => {
    const msg = new MessageEvent(evt);
    setMessages((prev) => [
      ...prev,
      {
        id: Date.now(),
        text: msg.message ?? '',
        sender: msg.publisher || 'remote',
        timestamp: msg.timestamp,
      },
    ]);
  });

  useRtmEvent(engine, 'linkState', (eventData) => {
    console.log('Link state changed:', eventData);
  });

  const sendMessage = async () => {
    if (!message.trim())
    {
      return;
    }

    // Subscribe to the channel before sending a message
    await subscribe();

    try {
      await engine.publish(CHANNEL_ID, message, {
        channelType: RTM_CHANNEL_TYPE.RTM_CHANNEL_TYPE_MESSAGE,
        messageType: RTM_MESSAGE_TYPE.RTM_MESSAGE_TYPE_STRING,
      });
      setMessages((prev) => [
        ...prev,
        { id: Date.now(), text: message, sender: 'local' },
      ]);
      setMessage('');
    } catch (err) {
      console.warn('Send error:', err);
    }
  };

  // Subscribes to messages from the Signaling channel
  const subscribe = async () => {
    try {
      await engine.subscribe(CHANNEL_ID, { withMessage: true });
    } catch (err) {
      console.warn('Subscribe error:', err);
    }
  };

  const unsubscribe = async () => {
    engine.unsubscribe(CHANNEL_ID).then(() => {
      console.log('Subscribed to: ', CHANNEL_ID);
    }).catch((err) => {
      console.error('Unsubscribe error:', err);
    });
  };

  useEffect(() => {
    return () => {
      unsubscribe();
      engine.logout();
      engine.release();
    };
  }, []);

  return (
    <KeyboardAvoidingView
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : undefined}
      keyboardVerticalOffset={90}
    >
      <FlatList
        ref={flatListRef}
        data={messages}
        renderItem={({ item }) => (
          <View
            style={[
              styles.messageBubble,
              item.sender === 'local'
                ? styles.localBubble
                : styles.remoteBubble,
            ]}
          >
            <Text style={styles.messageText}>{item.text}</Text>
          </View>
        )}
        keyExtractor={(item) => item.id.toString()}
        contentContainerStyle={styles.messageList}
        onContentSizeChange={() =>
          flatListRef.current?.scrollToEnd({ animated: true })
        }
      />
      <View style={styles.inputRow}>
        <TextInput
          style={styles.input}
          placeholder="Type a message"
          value={message}
          onChangeText={setMessage}
        />
        <TouchableOpacity
          style={styles.sendButton}
          onPress={sendMessage}
          disabled={!message.trim()}
        >
          <Text style={styles.sendButtonText}>Send</Text>
        </TouchableOpacity>
      </View>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#f4f4f4' },
  messageList: { padding: 10 },
  inputRow: {
    flexDirection: 'row',
    padding: 10,
    borderTopWidth: 1,
    borderColor: '#ddd',
    backgroundColor: '#fff',
    alignItems: 'center',
  },
  input: {
    flex: 1,
    backgroundColor: '#eee',
    borderRadius: 20,
    paddingHorizontal: 15,
    paddingVertical: 10,
    marginRight: 10,
    borderWidth: 1,
    borderColor: '#ccc',
  },
  sendButton: {
    paddingHorizontal: 16,
    paddingVertical: 10,
    borderRadius: 20,
    backgroundColor: '#007AFF',
  },
  sendButtonText: {
    color: '#fff',
    fontWeight: 'bold',
  },
  messageBubble: {
    padding: 10,
    borderRadius: 15,
    marginVertical: 4,
    maxWidth: '75%',
  },
  localBubble: {
    alignSelf: 'flex-end',
    backgroundColor: '#DCF8C6',
  },
  remoteBubble: {
    alignSelf: 'flex-start',
    backgroundColor: '#fff',
    borderWidth: 1,
    borderColor: '#ddd',
  },
  messageText: {
    fontSize: 16,
  },
  loginContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#fff',
    padding: 20,
  },
  loginInput: {
    width: '100%',
    borderWidth: 1,
    borderColor: '#ccc',
    borderRadius: 20,
    paddingHorizontal: 15,
    paddingVertical: 10,
    marginBottom: 15,
    backgroundColor: '#fff',
  },
});`}
</CodeBlock>
</details>

To confirm that login is successful, use the `login` return value, or listen to the `linkState` event notification which provides the error code and reason for the login failure. When performing a login operation, the client's network connection state is `CONNECTING`. After a successful login, the state is updated to `CONNECTED`. 

<Admonition title="Best practice">
To continuously monitor the network connection state of the client, best practice is to continue to listen for `linkState` notifications throughout the life cycle of the application. For further details, see [API references](https://agoraio-extensions.github.io/agora-react-native-rtm/modules.html).
</Admonition>

<Admonition type="caution">
After a user successfully logs into <Vg k="SIG"/>, the application's PCU increases, which affects your billing data.
</Admonition>

### Import Agora modules

To use <Vg k="SIG"/> APIs in your project, import the relevant Agora classes and interfaces:

```tsx
import {
  createAgoraRtmClient,
  RtmConfig,
  RTM_AREA_CODE,
  RTMProvider,
  useRtm,
  useLogin,
  MessageEvent,
  RTM_CHANNEL_TYPE,
  RTM_MESSAGE_TYPE,
  useRtmEvent,
} from 'agora-react-native-rtm';
```

### Initialize the Signaling engine

To initialize the <Vg k="SIG" /> SDK, create an instance with `createAgoraRtmClient`. Then, pass this instance to the `RTMProvider` so that child components can access it using the `useRtm` hook.

```tsx
export default function SignalingEngine() {
  const client = createAgoraRtmClient(
    new RtmConfig({
      userId: '<Add your UID here>',
      appId: '<Add your APP ID from Agora console>',
      useStringUserId: true,
    })
  );

  return (
    <RTMProvider client={client}>
      <Signaling />
    </RTMProvider>
  );
}
```

### Add event listeners

The event listeners enable you to implement the processing logic in response to Signaling events. Use the following code to handle event notifications or display received messages:

```tsx
// Get the SDK instance
const engine = useRtm();

useRtmEvent(engine, 'message', (evt) => {
  const msg = new MessageEvent(evt);
  setMessages((prev) => [
    ...prev,
    {
      id: Date.now(),
      text: msg.message ?? '',
      sender: msg.publisher || 'remote',
      timestamp: msg.timestamp,
    },
  ]);
});

useRtmEvent(engine, 'linkState', (eventData) => {
  console.log('Link state changed:', eventData);
});
```

### Log in to <Vg k="SIG"/>

To connect to <Vg k="SIG"/> and access <Vg k="SIG"/> network resources, such as sending messages, and subscribing to channels, use the `useLogin` hook.

During a login operation, the client attempts to establish a connection with <Vg k="SIG"/>. Once the connection is established, the client transmits heartbeat information to the <Vg k="SIG"/> server at fixed intervals to keep the client active until the client actively logs out or is disconnected. The connection is interrupted when timeout occurs. During this period, users may freely access the <Vg k="SIG"/> network resources subject to their own permissions and usage restrictions.

```tsx
useLogin(engine, { token: TOKEN });
```

### Publish a message

To distribute a message to all subscribers of a message channel, call `publish`. The following code sends a string type message.

<CodeBlock language="tsx" showLineNumbers>
{`const sendMessage = async () => {
  // Subscribes to messages from the Signaling channel
  await subscribe();
  // Send a message
  try {
    await engine.publish(CHANNEL_ID, message, {
      channelType: RTM_CHANNEL_TYPE.RTM_CHANNEL_TYPE_MESSAGE,
      messageType: RTM_MESSAGE_TYPE.RTM_MESSAGE_TYPE_STRING,
    });
  } catch (err) {
    console.warn('Send error:', err);
  }
};`}
</CodeBlock>

<Admonition type="info">
Before calling `publish` to send a message, serialize the message payload as a string. 
</Admonition>
 
### Subscribe and unsubscribe

To subscribe to a channel, call `subscribe`. When you subscribe to a channel, you receive all messages published to the channel.

<CodeBlock language="tsx" showLineNumbers>
{`// Subscribes to messages from the Signaling channel
const subscribe = async () => {
  try {
    await engine.subscribe(CHANNEL_ID, { withMessage: true });
  } catch (err) {
    console.warn('Subscribe error:', err);
  }
};`}
</CodeBlock>

When you no longer need to receive messages from a channel, call `unsubscribe` to unsubscribe from the channel:

<CodeBlock language="tsx" showLineNumbers>
{`// Unsubscribes from the Signaling channel
const unSubscribe = async () => {
    try {
      await engine.unsubscribe(CHANNEL_ID);
    } catch (err) {
      console.warn('Unsubscribe error:', err);
    }
};`}
</CodeBlock>

For more information about subscribing and sending messages, see [Message channels](../core-functionality/message-channel) and [Stream channels](../core-functionality/stream-channel).

### Log out of Signaling

When a user no longer needs to use <Vg k="SIG" />, call `logout`. Logging out means closing the connection between the client and <Vg k="SIG" />. The user is automatically logged out or unsubscribed from all message and stream channels. Other users in the channel receive an `onPresenceEvent` notification of the user leaving the channel.

<CodeBlock language="tsx" showLineNumbers>
{`useEffect(() => {
  return () => {
    unsubscribe();
    engine.logout();
    engine.release();
  };
}, []);`}
</CodeBlock>


</PlatformWrapper>