---
title: Receive event notifications
sidebar_position: 2
platform_selector: false
description: >
  Receive notification of Conversational AI Engine events.
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import MultiCodeBlock, { CodeGroup, CodeItem } from '@app/mdx-components/MultiCodeBlock';

A webhook is an HTTP-based callback mechanism that allows a server to actively push data. Agora's message notification service uses webhooks to send notifications for specific events. 

## Understand the tech
When an event you subscribe to occurs, the Agora business server sends the event message to the Agora message notification server, which then delivers the event notification to your server via an HTTPS POST request.

![](/images/conversational-ai/convo-ai-notifications.svg)

The Agora message notification service offers low latency, high concurrency, stability, and reliability. In high-concurrency scenarios with conversational AI agents, the service maintains a real-time synchronized agent state machine at the business layer, enabling the following functions:

- Monitor agent join and leave events in real time.
- Monitor agent error events in real time.

## Prerequisites

Before you begin, make sure that you have:

- A valid Agora developer account and Agora console project. See [Enable Conversational AI](../get-started/manage-agora-account) for details .
- Servers that meet the following requirements:
    - Support HTTPS protocol. To improve security, Agora message notification service no longer supports HTTP server addresses.
    - Support HTTPS connection reuse (recommended), also known as keep-alive mode, to reduce message delivery delay. Agora recommends the following settings:
        - `MaxKeepAliveRequests`: greater than or equal to 100.
        - `KeepAliveTimeout`: Greater than or equal to 10 seconds.

## Configure event notification service

Follow these steps to activate and configure the event notification service:  

1. Log in to the Agora Console. Click **All Products** in the left navigation bar and select **Conversational AI Engine**.  

2. Open **Notifications**.  
   - On the product page, navigate to the **Webhook** tab.  

3. **Add a new event**.  
   - In the **Configuration** area, click **Add Event**.  
   - In the **New Webhook** pop-up, fill in the following details and click **Save**:  

   - **Event Notification Receiving Area**: The region where your event notification server is located. Agora will route requests through the nearest Agora node based on your selection.  

   - **Event Notification Receiving URL**: The HTTPS server address that will receive event notifications.  

   - **Subscription Events**: The events you want to subscribe to. See [Conversational AI Engine Event Types](#) for details.  
     - If you need to configure high-QPS (requests per second) events, ensure your server has sufficient processing power.  
     - To avoid repeated configurations and health checks, subscribe to all required events at once.  

   - **IP Whitelist**: If your server is behind a firewall, enable this option and follow the instructions to add all Agora notification server IP addresses to the firewall whitelist.  

    <details>
    <summary>Configure IP whitelisting</summary>

    If your server is behind a firewall, call the RESTful API to retrieve the event notification server's IP addresses and add them to your firewall whitelist.  

    Agora may update the IP addresses of its event notification servers. To avoid service disruptions, best practice is to query and update the firewall configuration at least once every 24 hours.  

    The following Java example retrieves the list of Agora event notification server IPs and updates the firewall configuration automatically every 24 hours.  

    ```java
    import java.io.IOException;
    import java.net.URI;
    import java.net.http.HttpClient;
    import java.net.http.HttpRequest;
    import java.net.http.HttpResponse;
    import java.util.Base64;
    import java.util.concurrent.Executors;
    import java.util.concurrent.ScheduledExecutorService;
    import java.util.concurrent.TimeUnit;

    public class AgoraIPWhitelistUpdater {

        public static void main(String[] args) throws IOException {

            // Customer ID
            // Set the AGORA_CUSTOMER_KEY environment variable
            final String customerKey = System.getenv("AGORA_CUSTOMER_KEY");
            
            // Customer Secret
            // Set the AGORA_CUSTOMER_SECRET environment variable
            final String customerSecret = System.getenv("AGORA_CUSTOMER_SECRET");

            ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();

            // Concatenate Customer ID and Secret, then encode in Base64
            String plainCredentials = customerKey + ":" + customerSecret;
            String base64Credentials = new String(Base64.getEncoder().encode(plainCredentials.getBytes()));

            // Create authorization header
            String authorizationHeader = "Basic " + base64Credentials;

            // Build the HTTP request
            HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create("https://api.agora.io/v2/ncs/ip"))
                .GET()
                .header("Authorization", authorizationHeader)
                .header("Content-Type", "application/json")
                .build();

            // Schedule the task to run every 24 hours
            executor.scheduleAtFixedRate(() -> {
                try {
                    HttpClient client = HttpClient.newHttpClient();
                    // Send the HTTP request
                    HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
                    System.out.println(response.body());
                } catch (IOException | InterruptedException e) {
                    e.printStackTrace();
                }
            }, 0, 24, TimeUnit.HOURS);
        }
    }
    ```

    </details>

## Test Event Notification Integration

<Admonition type="info">
Performing a health check is required to activate the event notification service. Activation is successful only if the check passes.
</Admonition>

Follow these steps to complete the health check:

1. Agora will generate test events based on your subscribed events and send event callbacks to your server. In these test event callbacks:
   - `channelName` is set to `test_webhook`.
   - `uid` is set to `12121212`.

2. Your server must respond to each test event callback within **10 seconds**. The response must:
   - Have an HTTP status code of **200**.
   - Be in JSON format.
   - Contain an empty body (optional).

### Sample Code (JavaScript)
```javascript
const express = require('express');
const app = express();
const bodyParser = require('body-parser');

// Use body-parser middleware to parse request body
app.use(bodyParser.json());

// Handle incoming POST requests
app.post('/', express.json({ type: 'application/json' }), (req, res) => {
    const event = req.body;
    
    // Respond within 5 seconds
    setTimeout(() => {
        res.status(200).json({ message: 'Success' });
    }, 5000);
    
    // Perform any long-running tasks after sending the response
});
```

### Troubleshooting Common Errors
If the health check fails, follow the prompts in the Agora Console to troubleshoot. Common issues include:

- **Request Timeout:** Your server did not return a **200** response within **10 seconds**.
  - Ensure your server processes event callbacks promptly.
  - If your response time is correct, contact Agora support to check network connectivity.

- **Certificate Error:** Your HTTPS certificate is invalid.
  - Verify that your SSL certificate is correct and not expired.
  - If your server is behind a firewall, ensure that all Agora event notification IPs are whitelisted.

- **Domain Name Unreachable:** The domain name is invalid or cannot resolve to the correct IP address.
  - Double-check your server deployment and DNS configuration.

- **Response Error:** Your server returned an incorrect status code.
  - Review the Agora Console for specific status codes and troubleshooting tips.

Once the health check passes, click **Save Configuration** in the Agora Console.

After approval, the **Event Notification Service** status will be marked as **Enabled**.

## Receive Event Notification Callback

After you successfully activate Agora's event notification service, when a subscribed channel event occurs, the Agora event server sends an event notification callback to your server via an HTTPS `POST` request. For details, see [Conversational AI Engine Event Types](#).

### Respond to Requests

After receiving an event notification callback, your server must respond to the Agora event server within **10 seconds**. The response body must be in JSON format, but the body content is optional.

If the Agora event server does not receive a response within 10 seconds or the response status code is not `200`, the notification is considered **failed**. When a failure occurs, Agora immediately retries the notification. The retry interval increases progressively with each failure, and the retries stop after three attempts.

### Verify the Signature

To enhance security, you can use a signature mechanism to verify that the request is from Agora.

When Agora sends an event notification callback, it generates a signature using **HMAC/SHA1** and **HMAC/SHA256** algorithms with a secret key. The signature values are included in the `Agora-Signature` and `Agora-Signature-V2` fields in the HTTPS request header.

Follow these steps to verify the signature:

1. Get the Key

    When you configure the Agora event notification service, Agora generates a key. To obtain the key:

    1. Log in to the [Agora Console](https://console.agora.io).
    2. In the left navigation bar, select **All Products** > **Conversational AI Engine**.
    3. Go to the **Webhook** tab and click **Copy** to get the key.

2. Calculate the Signature

    After receiving the callback, use the key and the parameters in the request body to compute the signature value using the **HMAC/SHA1** or **HMAC/SHA256** algorithm.

3. Compare the Signature
    
    Compare your calculated signature with the corresponding field in the request header:

    - **HMAC/SHA1**: Compare the computed value with the `Agora-Signature` field. If they match, the request is from Agora.
    - **HMAC/SHA256**: Compare the computed value with the `Agora-Signature-V2` field. If they match, the request is from Agora.

    Agora provides sample code for signature verification in multiple languages for your reference.

<Tabs>
<TabItem value="python" label="Python" default>

- HMAC/SHA256

    <CodeBlock language="python" showLineNumbers>
    {`#!/usr/bin/env python2
    # !-*- coding: utf-8 -*-
    import hashlib
    import hmac

    # Obtain the raw request body of the event notification and compute its signature. 
    # In other words, the request_body in the following code is the binary byte array before deserialization, 
    # not the dictionary after deserialization.
    request_body = '{"eventType":10,"noticeId":"4eb720f0-8da7-11e9-a43e-53f411c2761f","notifyMs":1560408533119,"payload":{"a":"1","b":2},"productId":1}'

    secret = 'secret'
    signature2 = hmac.new(secret, request_body, hashlib.sha256).hexdigest()

    # Print the computed signature
    print(signature2)  # de96da5acf03b0021ac3b4fa2225e7ae6f3533a30d50bb02c08ea4fa748bda24
    `}
    </CodeBlock>

- HMAC/SHA1

    <CodeBlock language="python" showLineNumbers>
    {`#!/usr/bin/env python2
    # !-*- coding: utf-8 -*-
    import hashlib
    import hmac

    # Obtain the raw request body of the event notification and compute its signature. 
    # In other words, the request_body in the following code is the binary byte array before deserialization, 
    # not the dictionary after deserialization.
    request_body = '{"eventType":10,"noticeId":"4eb720f0-8da7-11e9-a43e-53f411c2761f","notifyMs":1560408533119,"payload":{"a":"1","b":2},"productId":1}'

    secret = 'secret'
    signature = hmac.new(secret, request_body, hashlib.sha1).hexdigest()

    # Print the computed signature
    print(signature)  # 5a3bb6a6d9fad2ea9ae3fb707a14c9d7f3136df1
    `}
    </CodeBlock>
</TabItem>

<TabItem value="Javascript" label="Javascript" default>

- HMAC/SHA256

    <CodeBlock language="js" showLineNumbers>
    {`const crypto = require('crypto');
    // Obtain the raw request body of the event notification and compute its signature. 
    // In other words, the requestBody in the following code is the binary byte array before deserialization, 
    // not the object after deserialization.
    const requestBody = '{"eventType":10,"noticeId":"4eb720f0-8da7-11e9-a43e-53f411c2761f","notifyMs":1560408533119,"payload":{"a":"1","b":2},"productId":1}';

    const secret = 'secret';

    // Compute the HMAC signature using SHA-256
    const signature2 = crypto.createHmac('sha256', secret).update(requestBody, 'utf8').digest('hex');

    // Print the computed signature
    console.log(signature2); // de96da5acf03b0021ac3b4fa2225e7ae6f3533a30d50bb02c08ea4fa748bda24
    `}
    </CodeBlock>

- HMAC/SHA1

    <CodeBlock language="js" showLineNumbers>
    {`const crypto = require('crypto');
    // Obtain the raw request body of the event notification and compute its signature. 
    // In other words, the requestBody in the following code is the binary byte array before deserialization, 
    // not the object after deserialization.
    const requestBody = '{"eventType":10,"noticeId":"4eb720f0-8da7-11e9-a43e-53f411c2761f","notifyMs":1560408533119,"payload":{"a":"1","b":2},"productId":1}';

    const secret = 'secret';

    // Compute the HMAC signature using SHA-1
    const signature = crypto.createHmac('sha1', secret).update(requestBody, 'utf8').digest('hex');

    // Print the computed signature
    console.log(signature); // 5a3bb6a6d9fad2ea9ae3fb707a14c9d7f3136df1`}
    </CodeBlock>
</TabItem>

<TabItem value="Java" label="Java">

- HMAC/SHA256

    <CodeBlock language="java" showLineNumbers>
    {`import javax.crypto.Mac;
    import javax.crypto.SecretKey;
    import javax.crypto.spec.SecretKeySpec;

    public class HmacSha {

        // Convert the encrypted byte array into a hexadecimal string
        public static String bytesToHex(byte[] bytes) {
            StringBuffer sb = new StringBuffer();
            for (int i = 0; i < bytes.length; i++) {
                String hex = Integer.toHexString(bytes[i] & 0xFF);
                if (hex.length() < 2) {
                    sb.append(0);
                }
                sb.append(hex);
            }
            return sb.toString();
        }

        // HMAC/SHA256 encryption, returns the encrypted string
        public static String hmacSha256(String message, String secret) {
            try {
                SecretKeySpec signingKey = new SecretKeySpec(secret.getBytes("utf-8"), "HmacSHA256");
                Mac mac = Mac.getInstance("HmacSHA256");
                mac.init(signingKey);
                byte[] rawHmac = mac.doFinal(message.getBytes("utf-8"));
                return bytesToHex(rawHmac);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }

        public static void main(String[] args) {
            // Obtain the raw request body of the event notification and compute its signature.
            // In other words, the request_body in the following code is the binary byte array before deserialization, 
            // not the object after deserialization.
            String request_body = "{\"eventType\":10,\"noticeId\":\"4eb720f0-8da7-11e9-a43e-53f411c2761f\",\"notifyMs\":1560408533119,\"payload\":{\"a\":\"1\",\"b\":2},\"productId\":1}";

            String secret = "secret";

            // Print the computed HMAC/SHA256 signature
            System.out.println(hmacSha256(request_body, secret)); 
            // Expected output: de96da5acf03b0021ac3b4fa2225e7ae6f3533a30d50bb02c08ea4fa748bda24
        }
    }`}
    </CodeBlock>

- HMAC/SHA1

    <CodeBlock language="java" showLineNumbers>
    {`import javax.crypto.Mac;
    import javax.crypto.SecretKey;
    import javax.crypto.spec.SecretKeySpec;

    public class HmacSha {

        // Convert the encrypted byte array into a hexadecimal string
        public static String bytesToHex(byte[] bytes) {
            StringBuffer sb = new StringBuffer();
            for (int i = 0; i < bytes.length; i++) {
                String hex = Integer.toHexString(bytes[i] & 0xFF);
                if (hex.length() < 2) {
                    sb.append(0);
                }
                sb.append(hex);
            }
            return sb.toString();
        }

        // HMAC/SHA1 encryption, returns the encrypted string
        public static String hmacSha1(String message, String secret) {
            try {
                SecretKeySpec signingKey = new SecretKeySpec(secret.getBytes("utf-8"), "HmacSHA1");
                Mac mac = Mac.getInstance("HmacSHA1");
                mac.init(signingKey);
                byte[] rawHmac = mac.doFinal(message.getBytes("utf-8"));
                return bytesToHex(rawHmac);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }

        public static void main(String[] args) {
            // Obtain the raw request body of the event notification and compute its signature.
            // In other words, the request_body in the following code is the binary byte array before deserialization, 
            // not the object after deserialization.
            String request_body = "{\"eventType\":10,\"noticeId\":\"4eb720f0-8da7-11e9-a43e-53f411c2761f\",\"notifyMs\":1560408533119,\"payload\":{\"a\":\"1\",\"b\":2},\"productId\":1}";

            String secret = "secret";

            // Print the computed HMAC/SHA1 signature
            System.out.println(hmacSha1(request_body, secret)); 
            // Expected output: 5a3bb6a6d9fad2ea9ae3fb707a14c9d7f3136df1
        }
    }`}
    </CodeBlock>
</TabItem>

<TabItem value="php" label="PHP" default>

- HMAC/SHA256

    <CodeBlock language="php" showLineNumbers>
    {`<?php
    function assertEqual($expect, $actual)
    {
        if ($expect != $actual) {
            echo("\\n assert failed");
            echo("\\n  expect:\\n    " . $expect);
            echo("\\n  actual:\\n    " . $actual);
            echo("\\n");
        } else {
            echo("assert ok\\n");
            echo("\\n");
        }
    }

    // Obtain the raw request body from the notification and compute its signature.
    // In other words, the requestBody in the following code is the binary byte array before deserialization, 
    // not the object after deserialization.
    $request_body = '{"eventType":10,"noticeId":"4eb720f0-8da7-11e9-a43e-53f411c2761f","notifyMs":1560408533119,"payload":{"a":"1","b":2},"productId":1}';
    $secret = 'secret';

    // The value of Agora-Signature-V2 in the request header
    $sha256 = 'de96da5acf03b0021ac3b4fa2225e7ae6f3533a30d50bb02c08ea4fa748bda24';

    $res2 = (hash_hmac('sha256', $request_body, $secret));
    assertEqual($res2, $sha256);
    ?>`}
    </CodeBlock>

- HMAC/SHA1

    <CodeBlock language="php" showLineNumbers>
    {`<?php
    function assertEqual($expect, $actual)
    {
        if ($expect != $actual) {
            echo("\\n assert failed");
            echo("\\n  expect:\\n    " . $expect);
            echo("\\n  actual:\\n    " . $actual);
            echo("\\n");
        } else {
            echo("assert ok\\n");
            echo("\\n");
        }
    }

    // Obtain the raw request body from the notification and compute its signature.
    // In other words, the requestBody in the following code is the binary byte array before deserialization, 
    // not the object after deserialization.
    $request_body = '{"eventType":10,"noticeId":"4eb720f0-8da7-11e9-a43e-53f411c2761f","notifyMs":1560408533119,"payload":{"a":"1","b":2},"productId":1}';
    $secret = 'secret';

    // The value of Agora-Signature in the request header
    $sha1 = '5a3bb6a6d9fad2ea9ae3fb707a14c9d7f3136df1';

    $res1 = (hash_hmac('sha1', $request_body, $secret));
    assertEqual($res1, $sha1);
    ?>`}
    </CodeBlock>
</TabItem>

<TabItem value="go" label="Go" default>
- HMAC/SHA256

    <CodeBlock language="php" showLineNumbers>
    {`package main
    import (
      "crypto/hmac"
      "crypto/sha256"
      "encoding/hex"
      "fmt"
    )
    func main() \{
      // Obtain the raw request body of the message notification and compute its signature.
      // In other words, the \`request_body\` in the code below is the binary byte array before deserialization,
      // not the dictionary after deserialization.
      request_body := \`\{"eventType":10,"noticeId":"4eb720f0-8da7-11e9-a43e-53f411c2761f","notifyMs":1560408533119,"payload":\{"a":"1","b":2},"productId":1}\`
      secret := "secret"
      fmt.Println(calcSignatureV2(secret, request_body)) // de96da5acf03b0021ac3b4fa2225e7ae6f3533a30d50bb02c08ea4fa748bda24
    }
    func calcSignatureV2(secret, payload string) string \{
      mac := hmac.New(sha256.New, []byte(secret))
      mac.Write(\[]byte(payload))
      return hex.EncodeToString(mac.Sum(nil))
    }`}
    </CodeBlock>

- HMAC/SHA1

    <CodeBlock language="php" showLineNumbers>
    {`package main
    import (
      "crypto/hmac"
      "crypto/sha1"
      "encoding/hex"
      "fmt"
    )
    func main() {
      // Obtain the raw request body of the message notification and compute its signature.
      // In other words, the \`request_body\` in the code below is the binary byte array before deserialization,
      // not the dictionary after deserialization.
      request_body := \`{\"eventType\":10,\"noticeId\":\"4eb720f0-8da7-11e9-a43e-53f411c2761f\",\"notifyMs\":1560408533119,\"payload\":{\"a\":\"1\",\"b\":2},\"productId\":1}\`
      secret := "secret"
      fmt.Println(calcSignatureV1(secret, request_body))  // 5a3bb6a6d9fad2ea9ae3fb707a14c9d7f3136df1
    }
    func calcSignatureV1(secret, payload string) string {
      mac := hmac.New(sha1.New, []byte(secret))
      mac.Write([]byte(payload))
      return hex.EncodeToString(mac.Sum(nil))
    }`}
    </CodeBlock>
</TabItem>

</Tabs>
