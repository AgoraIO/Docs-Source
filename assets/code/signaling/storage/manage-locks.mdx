<PlatformWrapper platform='android'>

    ```java
    fun setLock (lockName: String, ttl: Long) {
        // ttl is the lock expiration time in case the user goes offline
        signalingEngine?.lock?.setLock(channelName, channelType, lockName, ttl, object: ResultCallback<Void?> {
            override fun onSuccess(responseInfo: Void?) {
                notify("Lock set successfully")
            }

            override fun onFailure(errorInfo: ErrorInfo) {
                notify(errorInfo.toString())
            }
        })
    }

    fun acquireLock(lockName: String, retry: Boolean) {
        signalingEngine?.lock?.acquireLock(channelName, channelType, lockName, retry, object: ResultCallback<Void?> {
            override fun onSuccess(responseInfo: Void?) {
                notify("Lock acquired successfully")
            }

            override fun onFailure(errorInfo: ErrorInfo) {
                notify(errorInfo.toString())
            }
        })
    }

    fun releaseLock(lockName: String, retry: Boolean) {
        signalingEngine?.lock?.releaseLock(channelName, channelType, lockName, object: ResultCallback<Void?> {
            override fun onSuccess(responseInfo: Void?) {
                notify("Lock released successfully")
            }

            override fun onFailure(errorInfo: ErrorInfo) {
                notify(errorInfo.toString())
            }
        })
    }

    fun removeLock(lockName: String) {
        signalingEngine?.lock?.releaseLock(channelName, channelType, lockName, object: ResultCallback<Void?> {
            override fun onSuccess(responseInfo: Void?) {
                notify("Lock released successfully")
            }

            override fun onFailure(errorInfo: ErrorInfo) {
                notify(errorInfo.toString())
            }
        })
    }

    fun getLocks() {
        signalingEngine?.lock?.getLocks(channelName, channelType, object: ResultCallback<ArrayList<LockDetail?>> {
            override fun onSuccess(lockDetail: ArrayList<LockDetail?>) {
                var summary = "Lock details:\n"
                for (lock in lockDetail) {
                    if (lock != null) {
                        summary += "Lock: ${lock.lockName}, Owner:${lock.lockOwner}"
                    }
                }
                notify(summary)
            }

            override fun onFailure(errorInfo: ErrorInfo) {
                notify(errorInfo.toString())
            }
        })
    }
    ```

</PlatformWrapper>

<PlatformWrapper platform='ios'>


</PlatformWrapper>

<PlatformWrapper platform = 'web'>

    ```javascript
    const setLock = async function (channelName, channelType, lockName, ttl) {
      // Create a new lock
      try{
        const result = await signalingManager
        .getSignalingEngine().lock.setLock(
            channelName, channelType, lockName, { ttl: ttl }
        );
      } catch (status) {
        messageCallback(status.reason);
      }
    }

    const acquireLock = async function (channelName, channelType, lockName, retry) {
      // Acquire exclusive use of the named lock
      try{
        const result = await signalingManager
        .getSignalingEngine().lock.acquireLock(
            channelName, channelType, lockName,  {retry: retry}
        );
      } catch (status) {
        messageCallback(status.reason);
      }
    }

    const releaseLock = async function (channelName, channelType, lockName) {
      // Release a lock after use to make it available for others
      try{
        const result = await signalingManager
        .getSignalingEngine().lock.releaseLock(
            channelName, channelType, lockName,
        );
      } catch (status) {
        messageCallback(status.reason);
      }
    }

    const removeLock = async function (channelName, channelType, lockName) {
      // Delete a lock
      try{
        const result = await signalingManager
        .getSignalingEngine().lock.removeLock(
            channelName, channelType, lockName,
        );
      } catch (status) {
        messageCallback(status.reason);
      }
    }

    const getLock = async function (channelName, channelType) {
      // Get details of all current locks in the channel
      try{
        const result = await signalingManager
        .getSignalingEngine().lock.getLock(
            channelName, channelType
        );
        messageCallback(`getLock succeeded. Total ${result.totalLocks } locks: ${JSON.stringify(result.lockDetails)}`)
      } catch (status) {
        messageCallback(status.reason);
      }
    }
    ```     
</PlatformWrapper>

