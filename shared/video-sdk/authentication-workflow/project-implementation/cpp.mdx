1. **Import <Vpd k="SDK" /> classes and interfaces**

    ```cpp
    #include "afxinet.h"
    ```
2.  **Declare variables for your request to the token server**

    ``` cpp
    int tokenRole = 1; // The token role: Broadcaster or Audience
    std::string serverUrl = "<The base URL to your token server>"; //For example, "https://agora-token-service-production-92ff.up.railway.app"
    int expireTime = 60; //Expire time in Seconds.
    uid_t uid = 1; // An integer that identifies the user
    ```

4. **Retrieve a token from the server**

    Use a GET request to retrieve an authentication token for a specific channel from the token server:

    ```cpp
    std::string fetchToken(std::string& serverUrl, const std::string& channelName, int tokenRole, size_t uid, int expireTime) 
    {
        CInternetSession session;
        CHttpConnection* pConnection = NULL;
        std::string httpsPrefix = "https://";
        std::string serverUrlWithoutHTTPS;
        if (serverUrl.find(httpsPrefix) == 0) 
        {
            serverUrlWithoutHTTPS = serverUrl.substr(httpsPrefix.length());
        }
        CString baseURL(serverUrlWithoutHTTPS.c_str());
        std::string rest_url = "/rtc/" + channelName + "/" + std::to_string(tokenRole) + "/uid/" + std::to_string(uid) + "/?expiry=" + std::to_string(expireTime);
        CString restURL(rest_url.c_str());
        std::string token = "";
        try 
        {
            pConnection = (CHttpConnection*)session.GetHttpConnection(baseURL, (INTERNET_PORT)INTERNET_DEFAULT_HTTP_PORT);
            if (pConnection) 
            {
                CHttpFile* pHTTPFile = NULL;
                pHTTPFile = pConnection->OpenRequest(CHttpConnection::HTTP_VERB_GET, restURL);
                if (pHTTPFile)
                {
                    pHTTPFile->SendRequest();
                    DWORD dwRet = 0;
                    char result[1024];
                    memset(result, 0, sizeof(result));
                    pHTTPFile->QueryInfoStatusCode(dwRet);
                    if (dwRet == HTTP_STATUS_OK) 
                    {
                        int bytesRead = pHTTPFile->Read((void*)result, 1024);
                        result[bytesRead] = '\0';
                        char* tokenStart = strstr(result, "\"rtcToken\":\"");
                        if (tokenStart != NULL) 
                        {
                            tokenStart += strlen("\"rtcToken\":\"");
                            char* tokenEnd = strchr(tokenStart, '\"');
                            if (tokenEnd != NULL) 
                            {
                                *tokenEnd = '\0';
                                token = std::string(tokenStart);
                            }
                        }
                    }
                    else 
                    {
                        CString errorCode;
                        pHTTPFile->QueryInfo(HTTP_QUERY_STATUS_TEXT, errorCode);    // Status String - eg OK, Not Found
                        AfxMessageBox(errorCode);
                    }
                    pHTTPFile->Close();
                    delete pHTTPFile;
                }
                pConnection->Close();
                delete pConnection;
            }
        }
        catch (CInternetException* e) 
        {
            char strErrorBuf[255];
            e->GetErrorMessage((LPTSTR)strErrorBuf, 255, NULL);
            AfxMessageBox((LPCTSTR)strErrorBuf, MB_ICONINFORMATION);
        }
        session.Close();
        return token;
    }
    ```
5. **Join a channel using a token from the token server**

    ```cpp
    if (token == "")
    {
        // Fetch new token 
        token = fetchToken(serverUrl, channelName, tokenRole, uid, expireTime);
        if (token == "")
        {
            AfxMessageBox(L"Invalid Token.");
            return;
        }
    }
    if (0 == agoraEngine->joinChannel(token.c_str(), channelName.c_str(), NULL, uid))
    {
        isJoin = true;
    }
    ```

1.  **Renew an expiring token**

    A token expires after the `expireTime` specified in the call to the token server, or after 24 hours if the time
    is not specified. In order for you to renew the token, the `onTokenPrivilegeWillExpire` event receives a callback
    when the current token is about to expire.

      ```cpp
      LRESULT CAgoraImplementationDlg::OnEIDTokenPrivilegeWillExpire(WPARAM wParam, LPARAM lParam)
      {
          // Fetch a new token
          token = fetchToken(serverUrl, channelName, tokenRole, uid, expireTime);
          if (token == "")
          {
              AfxMessageBox(L"Invalid Token");
              ::PostMessage(GetParent()->GetSafeHwnd(), WM_MSGID(ON_TOKEN_PRIVILEGE_WILL_EXPIRE), TRUE, 0);
              return 0;
          }
          // Renew Agora engine token by the new one
          if (0 == agoraEngine->renewToken(token.c_str()))
          {
              AfxMessageBox(L"Token Renewed");
          }

          ::PostMessage(GetParent()->GetSafeHwnd(), WM_MSGID(ON_TOKEN_PRIVILEGE_WILL_EXPIRE), TRUE, 0);
          return 0;
      }
      ```
