<PlatformWrapper platform="linux-cpp">

### Initialize the service

Create the Agora service using `createAgoraService`. Then initialize it with media configuration options and logging settings.

```cpp
auto service = createAgoraService();

agora::base::AgoraServiceConfiguration service_config;
service_config.enableAudioDevice = false;
service_config.enableAudioProcessor = true;
service_config.enableVideo = true;
service_config.appId = config.appId.c_str();
service_config.useStringUid = config.UseStringUid;

service->initialize(service_config);
service->setLogFile("./io.agora.rtc_sdk/agorasdk.log", 1024 * 1024 * 5);
```

### Create the recorder instance

Call `createAgoraMediaComponentFactory` and use it to create a `IAgoraMediaRtcRecorder` instance. Then initialize the recorder with the service and recording mode.

```cpp
agora::rtc::IMediaComponentFactory* factory = createAgoraMediaComponentFactory();
agora::agora_refptr<agora::rtc::IAgoraMediaRtcRecorder> recorder = factory->createMediaRtcRecorder();

// Set the recording mode
// - false: Record each user's audio and video stream separately (single stream recording)
// - true: Record all users' audio and video streams together (composite recording)

bool isMix = false;
// Initialize recorder
recorder->initialize(service, isMix);
```

### Register the event handler

Call `registerRecorderEventHandle` to register a user-defined event handler that receives recorder callbacks.

```cpp
std::unique_ptr<RecorderEventHandler> eventHandler{new RecorderEventHandler(recorder, config)};
recorder->registerRecorderEventHandle(eventHandler.get());
```

<Admonition type="info" >
`RecorderEventHandler` is a custom class that implements your recorder event-handling logic.
</Admonition>

### Subscribe to audio and video streams

Call `subscribeAllAudio` and `subscribeAllVideo` to receive all audio and video streams in the channel.

```cpp
recorder->subscribeAllAudio();
recorder->subscribeAllVideo(options);
```

### Configure recording

Call `setRecorderConfig` to define recording parameters such as resolution, frame rate, audio settings, and the storage location.

<Admonition type="info" >
Ensure that the directory specified in `storagePath` exists. If not, the recording will fail.
</Admonition>

```cpp
// Set recording configuration
agora::media::MediaRecorderConfiguration recorder_config;

recorder_config.width = config.video.width;
recorder_config.height = config.video.height;
recorder_config.fps = config.video.fps;
recorder_config.storagePath = config.recorderPath.c_str();
recorder_config.sample_rate = config.audio.sampleRate;
recorder_config.channel_num = config.audio.numOfChannels;
// Set recording stream type: audio stream, video stream, or audio and video stream
recorder_config.streamType = static_cast<agora::media::MediaRecorderStreamType>(config.recorderStreamType);
// Set the maximum recording duration
recorder_config.maxDurationMs = config.maxDuration * 1000;

recorder->setRecorderConfig(recorder_config);
```

### Join the channel and start recording

Call `joinChannel` to join the specified channel and `startRecording` to begin recording.

```cpp
recorder->joinChannel(config.token.c_str(), config.ChannelName.c_str(), config.UserId.c_str());
recorder->startRecording();
```

### Stop recording and release resources

Call the cleanup methods to end recording, unsubscribe from streams, and release memory.

```cpp
recorder->unsubscribeAllAudio();
recorder->unsubscribeAllVideo();
recorder->stopRecording();

recorder->unregisterRecorderEventHandle(eventHandler.get());
eventHandler = nullptr;

recorder->leaveChannel();
recorder = nullptr;

service->release();
```

### Complete sample code

The following example shows the full implementation of an On-Premise Recording workflow.

<details>
<summary>Complete sample code for On-Premise Recording</summary>

```cpp
// Create and initialize the Agora service, and configure logging
auto service = createAgoraService();
agora::base::AgoraServiceConfiguration service_config;
service_config.enableAudioDevice = false;
service_config.enableAudioProcessor = true;
service_config.enableVideo = true;
service_config.appId = config.appId.c_str();
service_config.useStringUid = config.UseStringUid;
service->initialize(service_config);
service->setLogFile("./io.agora.rtc_sdk/agorasdk.log", 1024 * 1024 * 5);

// Create the media recorder instance
agora::rtc::IMediaComponentFactory* factory = createAgoraMediaComponentFactory();
agora::agora_refptr<agora::rtc::IAgoraMediaRtcRecorder> recorder = factory->createMediaRtcRecorder();

// Initialize the recorder
// Set to true for mixed recording or false for individual streams
bool isMix = false;
recorder->initialize(service, isMix);

// Register the event handler for recorder callbacks
std::unique_ptr<RecorderEventHandler> eventHandler{new RecorderEventHandler(recorder, config)};
recorder->registerRecorderEventHandle(eventHandler.get());

// Subscribe to all audio and video streams
recorder->subscribeAllAudio();
recorder->subscribeAllVideo(options); // 'options' should be properly defined before use

// Configure recorder settings
agora::media::MediaRecorderConfiguration recorder_config;
recorder_config.width = config.video.width;
recorder_config.height = config.video.height;
recorder_config.fps = config.video.fps;
recorder_config.storagePath = config.recorderPath.c_str();
recorder_config.sample_rate = config.audio.sampleRate;
recorder_config.channel_num = config.audio.numOfChannels;
recorder_config.streamType = static_cast<agora::media::MediaRecorderStreamType>(config.recorderStreamType);
recorder_config.maxDurationMs = config.maxDuration * 1000;

recorder->setRecorderConfig(recorder_config);

// Join the channel and start recording
recorder->joinChannel(config.token.c_str(), config.ChannelName.c_str(), config.UserId.c_str());
recorder->startRecording();

// Stop recording and clean up
recorder->unsubscribeAllAudio();
recorder->unsubscribeAllVideo();
recorder->stopRecording();

recorder->unregisterRecorderEventHandle(eventHandler.get());
eventHandler = nullptr;

recorder->leaveChannel();
recorder = nullptr;

service->release();
```

</details>

</PlatformWrapper>