<PlatformWrapper platform="android">
    ```kotlin
    internal class PushingTask(private val manager: CustomVideoAudioManager) : Runnable {
        override fun run() {
            Process.setThreadPriority(Process.THREAD_PRIORITY_URGENT_AUDIO)
            while (manager.pushingAudio) {
                val before = System.currentTimeMillis()
                manager.agoraEngine?.pushExternalAudioFrame(manager.readBuffer(),
                    System.currentTimeMillis(),
                    manager.sampleRate,
                    manager.numberOfChannels,
                    Constants.BytesPerSample.TWO_BYTES_PER_SAMPLE,
                    manager.customAudioTrackId
                )
                val now = System.currentTimeMillis()
                val consuming = now - before
                if (consuming < manager.pushInterval) {
                    try {
                        Thread.sleep(manager.pushInterval - consuming)
                    } catch (e: InterruptedException) {
                        e.printStackTrace()
                    }
                }
            }
        }
    }
    ```
    - <Link to="{{Global.API_REF_ANDROID_ROOT}}/class_irtcengine.html#api_imediaengine_pushaudioframe">pushExternalAudioFrame</Link>
</PlatformWrapper>
<PlatformWrapper platform={["ios","macos"]}>
    ```swift
    func audioFrameCaptured(buf: CMSampleBuffer) {
        agoraEngine.pushExternalAudioFrameSampleBuffer(buf)
    }
    ```
    <PlatformWrapper platform="ios">
    - <Link to="{{Global.API_REF_IOS_ROOT_RTC_ENGINE_KIT}}/pushexternalaudioframesamplebuffer(_:)">pushExternalAudioFrameSampleBuffer(_:)</Link>
    </PlatformWrapper>
    <PlatformWrapper platform="macos">
    - <Link to="{{Global.API_REF_MACOS_ROOT_RTC_ENGINE_KIT}}/pushexternalaudioframesamplebuffer(_:)">pushExternalAudioFrameSampleBuffer(_:)</Link>
    </PlatformWrapper>
</PlatformWrapper>
<PlatformWrapper platform ="unity">
    ```csharp
    private void StartPushAudioFrame()
    {
        // 1-sec-length buffer
        var bufferLength = SAMPLE_RATE * CHANNEL;
        _audioBuffer = new RingBuffer<byte>(bufferLength, true);
        _startConvertSignal = true;
        _pushAudioFrameThread = new Thread(PushAudioFrameThread);
        _pushAudioFrameThread.Start();
    }
    private void PushAudioFrameThread()
    {
        var bytesPerSample = 2;
        var type = AUDIO_FRAME_TYPE.FRAME_TYPE_PCM16;
        var channels = CHANNEL;
        var samples = SAMPLE_RATE / PUSH_FREQ_PER_SEC;
        var samplesPerSec = SAMPLE_RATE;

        var freq = 1000 / PUSH_FREQ_PER_SEC;

        var audioFrame = new AudioFrame
        {
            bytesPerSample = BYTES_PER_SAMPLE.TWO_BYTES_PER_SAMPLE,
            type = type,
            samplesPerChannel = samples,
            samplesPerSec = samplesPerSec,
            channels = channels,
            RawBuffer = new byte[samples * bytesPerSample * CHANNEL],
            renderTimeMs = freq
        };

        double startMillisecond = GetTimestamp();
        long tick = 0;

        while (true)
        {
            lock (_rtcLock)
            {
                if (agoraEngine == null)
                {
                    break;
                }

                int nRet = -1;
                lock (_audioBuffer)
                {
                    if (_audioBuffer.Size > samples * bytesPerSample * CHANNEL)
                    {
                        for (var j = 0; j < samples * bytesPerSample * CHANNEL; j++)
                        {
                            audioFrame.RawBuffer[j] = _audioBuffer.Get();
                        }
                        nRet = agoraEngine.PushAudioFrame(audioFrame, audioTrackID);
                        //Debug.Log("PushAudioFrame returns: " + nRet);

                    }
                }

                if (nRet == 0)
                {
                    tick++;
                    double nextMillisecond = startMillisecond + tick * freq;
                    double curMillisecond = GetTimestamp();
                    int sleepMillisecond = (int)Math.Ceiling(nextMillisecond - curMillisecond);
                    //Debug.Log("sleepMillisecond : " + sleepMillisecond);
                    if (sleepMillisecond > 0)
                    {
                        Thread.Sleep(sleepMillisecond);
                    }
                }
            }

        }
    }
    ```
</PlatformWrapper>