<PlatformWrapper platform="android">
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Since June 2023, Agora has introduced the RTM v2 series to meet market and industry demands, providing innovative enhancements in functionality, performance, and user experience:

- **Extended Functionality**: This version introduces functional modules such as `Channel`, `Message`, `Topic`, `Presence`, `Storage`, and `Lock`, expanding coverage for various business scenarios, allowing you to focus more on your business innovations.

- **Performance Improvement**: With a backend architecture overhaul and optimized network connections, the new version delivers long-term low-latency, high-reliability, high-concurrency, and easily scalable real-time network access, alleviating concerns about business quality.

- **Enhanced User Experience**: The API interfaces have been redesigned and streamlined, and documentation, including user guides and API references, has been optimized. Comprehensive example programs support developers in learning to use the SDK efficiently and quickly integrate it into their projects.

This document outlines the main differences between RTM v1 and v2, providing relevant example code to facilitate a smooth transition from v1 to v2.

## Enabling Service

The steps to enable v2 and v1 are the same:

1. Register and log in to the Agora Console.
2. Create an Agora project.
3. Enter the Feature Configuration section and enable the RTM service.
4. Obtain the necessary development parameters, such as the App ID.

If you don't have an Agora account, [register an account](https://console.agora.io/). For details on how to enable the service and create a project, refer to [Enabling Service](../develop/get-started-sdk#prerequisites).

## SDK Integration

Note that the SDK package names for v2 and v1 are different. Both support integration through CDN and Maven Central. The integration methods are as follows:

- For v1:
    ```java
    dependencies {
        // Replace x.y.z with the specific SDK version, e.g., 1.5.1
        implementation 'io.agora.rtm:rtm-sdk:x.y.z'
    }
    ```

- For v2:
    ```java
    dependencies {
        // Replace x.y.z with the specific SDK version, e.g., 2.1.9
        implementation 'io.agora:agora-rtm:x.y.z'
    }
    ```
    <Admonition type="info" title="Info">
    The v2 SDK package name is `agora-rtm`, while the v1 SDK package name is `rtm-sdk`.
    </Admonition>

## Initializing Instance

Compared to v1, v2 has made adjustments to initialization parameters, introducing new features such as end-to-end encryption and cloud proxy. Refer to the [API Reference](../reference/api) for details. Additionally, v2 provides richer error information when invoking interfaces, allowing you to quickly identify issues. Combine this with [Error Codes](../reference/api#troubleshooting) for efficient troubleshooting.

- Example code for v1:
    ```java
    try {
        rtmClient = RtmClient.createInstance(getBaseContext(), "your_appId", new RtmClientListener() {
            @Override
            public void onConnectionStateChanged(int state, int reason) {
            }
            
            @Override
            public void onMessageReceived(RtmMessage rtmMessage, String peerId) {
            }
            
            @Override
            public void onTokenExpired() {
            }
            
            @Override
            public void onTokenPrivilegeWillExpire() {
            }
            
            @Override
            public void onPeersOnlineStatusChanged(Map<String, Integer> status) {
            }
        });
    } catch (Exception e) {
        throw new RuntimeException("RTM initialization failed!");
    }
    ```

- Example code for v2:
    
    ```java
    RtmConfig rtmConfig = new RtmConfig.Builder("your_appId", "your_userId")
        .eventListener(eventListener)
        .build();
    try {
        rtmClient = RtmClient.create(rtmConfig);
    } catch (Exception e) {
        e.printStackTrace();
    }
    ```

## Logging into Service

The login method for v2 differs from v1:

- Example code for v1:
    
    ```java
    rtmClient.login("your_token", "your_userId", new ResultCallback<Void>() {
        @Override
        public void onSuccess(Void responseInfo) {
            // Handle login result
        }
        @Override
        public void onFailure(ErrorInfo errorInfo) {
            // Handle errors
        }
    });
    ```

- Example code for v2:

    ```java
    rtmClient.login("your_token", new ResultCallback<Void>() {
        @Override
        public void onSuccess(Void responseInfo) {
            // Handle login result
        }
        
        @Override
        public void onFailure(ErrorInfo errorInfo) {
            // Handle errors
        }
    });
    ```

## Event Notifications

Compared to v1, v2 has redesigned the system event notification mechanism and API interfaces, providing more detailed classification and aggregation of event notification types, and optimizing the payload data structure.

V2 introduces 7 types of event notifications, as listed below:

| Event Type                                                      | Description                                                            |
|-----------------------------------------------------------------|------------------------------------------------------------------------|
| `onMessageEvent`               | Message Event Notification: Receives notifications for all message events in subscribed Message Channels and Topics.                    |
| `onPresenceEvent`              | User Presence and Custom State Change Event Notification (Presence Event Notification): Receives notifications for Presence events in subscribed Message Channels and joined Stream Channels, including user online/offline status and custom temporary state changes.   |
| `onTopicEvent`                 | Topic Change Event Notification: Receives notifications for Topic changes in joined Stream Channels.                               |
| `onStorageEvent`               | Channel and User Property Event Notification: Receives notifications for Channel Metadata events in subscribed Message Channels and joined Stream Channels, as well as User Metadata events for subscribed users.|
| `onLockEvent`                  | Lock Change Event Notification: Receives notifications for Lock events in subscribed Message Channels and joined Stream Channels.      |
| `onConnection`                | Network Connection State Change Event Notification: Receives notifications for changes in client network connection status.              |
| `onTokenWillExpire`            | Receives notifications for when the client's token is about to expire.                                                                |

For more information on event notifications and payload data structures, see [Event listeners](../reference/api#event-listeners).

Taking the example of listening to channel message events `onMessageEvent`, the example code for v1 is as follows:

- For v1:
    ```java
    rtmChannel = rtmClient.createChannel("channelName", new RtmChannelListener() {
        @Override
        public void onMessageReceived(final RtmMessage message, final RtmChannelMember fromMember) {
            // Handle message event
        }
    // Add other event notifications
    });
    ```

- For v2:
    ```java
    RtmEventListener eventListener = new RtmEventListener() {
        @Override
        public void onMessageEvent(MessageEvent event) {
            // Handle message event
        }
    // Add other event notifications
    };
    
    // Option 1: Add event listener when initializing RTM Client instance with create method
    RtmConfig rtmConfig = new RtmConfig.Builder("your_appId", "your_userId")
        .eventListener(eventListener)
        .build();
    try {
        rtmClient = RtmClient.create(rtmConfig);
    } catch (Exception e) {
        e.printStackTrace();
    }
    
    // Option 2: Add event listener at any time during the app's lifecycle
    rtmClient.addEventListener(eventListener);
    ```
The above example code demonstrates significant differences:

- In v1, channel message event notifications are bound to specific channel instances. Users need to call the `createChannel()` method to create a `channel` instance, then register the `onMessageReceived` callback to handle events. The SDK notifies the handler through this callback when a message is received. If multiple channels are involved, this process needs to be repeated for each. In v2, message event notifications are bound to the client instance globally. You call the `addEventListener()` method to register the callback program once, and it applies to all subscribed channels or topics. This simplifies the implementation for handling message events across multiple channels or topics.

- The payload data structure for message event notifications in v2 contains more information, aiding in better implementation of custom business logic.

## Channel Messages

In v1, sending channel messages involved the following steps:

1. Create a channel instance.
1. Join the channel.
1. Send the channel message.

This design had a drawback: you couldn't send a message without receiving it because sending and receiving messages were coupled. V2 adopts a new design based on Pub/Sub, decoupling the sending and receiving of channel messages. You can send messages to a specific channel without joining, and you can subscribe to a specific channel to receive messages without affecting sending.

- Example code for v1:

    ```java
    // Create channel
    rtmChannel = rtmClient.createChannel("channelName", new RtmChannelListener() {
        @Override
        public void onMessageReceived(final RtmMessage message, final RtmChannelMember fromMember) {
            // Handle message event
        }
        // Add other event notifications
    });
    
    // Join channel
    rtmChannel.join(new ResultCallback<Void>() {
        @Override
        public void onSuccess(Void responseInfo) {
            // Handle join channel result
        }
        
        @Override
        public void onFailure(ErrorInfo errorInfo) {
            // Handle errors
        }
    });
    
    // Send message
    RtmMessage message = rtmClient.createMessage();
    message.setText("Hello World!");
    rtmChannel.sendMessage(message, new ResultCallback<Void>() {
        @Override
        public void onSuccess(Void aVoid) {
            // Handle message send result
        }
        
        @Override
        public void onFailure(ErrorInfo errorInfo) {
            // Handle errors
        }
    });
    ```

- Example code for v2:

    ```java
    // Send message in Message Channel
    String message = "Hello world";
    PublishOptions options = new PublishOptions();
    options.customType = 'PlainText';
    rtmClient.publish("channelName", message, options, new ResultCallback<Void>() {
        @Override
        public void onSuccess(Void responseInfo) {
            // Handle message send result
        }
        @Override
        public void onFailure(ErrorInfo errorInfo) {
            // Handle errors
        }
    });
    
    // Subscribe to Message Channel
    SubscribeOptions options = new SubscribeOptions();
    options.setWithMessage(true);
    rtmClient.subscribe("channelName", options, new ResultCallback<Void>() {
        @Override
        public void onSuccess(Void responseInfo) {
            // Handle subscribe result
        }
        @Override
        public void onFailure(ErrorInfo errorInfo) {
            // Handle errors
        }
    });
    
    // Handle received messages
    rtmClient.addEventListener(new RtmEventListener() {
        @Override
        public void onMessageEvent(MessageEvent event) {
            String channelName = event.getChannelId();
            String content = event.getMessage();
            // Handle received message
        }
        // Add other event notifications
    });
    ```

## Peer-to-Peer Messaging
In v1, the API for peer-to-peer messaging is used to send messages to specific users. For example, if you want to send a message to a user with the ID `Tony`, you can achieve it as follows:
```java
// v2
// 1. Subscribe to your own inbox
String channelName = "inbox_Tony";
SubscribeOptions options = new SubscribeOptions();
options.setWithMessage(true);
rtmClient.subscribe(channelName, options, new ResultCallback<Void>() {
    @Override
    public void onSuccess(Void responseInfo) {
        // Handle subscription result
    }

    @Override
    public void onFailure(ErrorInfo errorInfo) {
        // Handle errors
    }
});

// 2. Send a message to Lily
String channelName = "inbox_Lily";
String message = "This is a message";
PublishOptions options = new PublishOptions();
rtmClient.publish(channelName, message, options, new ResultCallback<Void>() {
    @Override
    public void onSuccess(Void responseInfo) {
        // Handle message send result
    }

    @Override
    public void onFailure(ErrorInfo errorInfo) {
        // Handle errors
    }
});
```

The reason for designing this interface in v1 is to meet the scenario requirement of end-to-end message transmission. That is, user A only wants to send a message to a specific user B, and user B only wants to receive this message without paying attention to other events. The channel mechanism in v1 is a structure design based on the Room mode, and this design cannot achieve the decoupling of sending and receiving messages. Therefore, it cannot meet the requirements of the scenario mentioned earlier.

V2 has redesigned the distribution mode of channel messages, adopting the Pub/Sub mode to decouple sending and receiving messages. Based on this, peer-to-peer messages can be implemented using channel messages. The implementation is as follows:

1. Each user subscribes to a private channel named `inbox_` + `UserID` after initialization. This channel is referred to as the inbox, and only the user can subscribe to it; others cannot.

1. When you need to send a peer-to-peer message to a user, you only need to send the message to the user's inbox.

- Example code for v2:
    ```java
    // v2
    // 1. Subscribe to your own inbox
    String channelName = "inbox_Tony";
    SubscribeOptions options = new SubscribeOptions();
    options.setWithMessage(true);
    rtmClient.subscribe(channelName, options, new ResultCallback<Void>() {
        @Override
        public void onSuccess(Void responseInfo) {
            // Handle subscription result
        }
        
        @Override
        public void onFailure(ErrorInfo errorInfo) {
            // Handle errors
        }
    });
    
    // 2. Send a message to Lily
    String channelName = "inbox_Lily";
    String message = "This is a message";
    PublishOptions options = new PublishOptions();
    rtmClient.publish(channelName, message, options, new ResultCallback<Void>() {
        @Override
        public void onSuccess(Void responseInfo) {
            // Handle message send result
        }
        
        @Override
        public void onFailure(ErrorInfo errorInfo) {
            // Handle errors
        }
    });
    ```
    <Admonition type="info" title="Info">
    To receive messages, you also need to implement the `{config.onmessageevent[frontMatter.ag_platform]}` event listener function.
    </Admonition>

## Image and File Messages

Starting from version 1.5.0, to comply with data privacy protection and cost optimization considerations, RTM no longer directly supports the transmission of image and file messages, and related APIs have been deprecated. You can combine RTM with third-party object storage services (such as Amazon S3 or Alibaba Cloud OSS) to build image and file messaging functionality. This approach not only provides an excellent real-time messaging experience but also enables more flexible technical construction solutions, such as implementing CDN static resource acceleration, image text review, and other business requirements. The following example code shows how to use v2 and the Amazon S3 object storage service to build and send image and file messages:
```java
// 1. Upload the file to Amazon S3

// 2. Notify RTM
JSONObject jsonObject = new JSONObject();
// File type, the receiving party can parse the message packet structure based on this field
jsonObject.put("type", "file");
// Your bucket name on Amazon S3, the receiving party needs this field to download the file
jsonObject.put("bucket", "uploadParams.Bucket");
// The Key under which the file is stored on Amazon S3, the receiving party needs this field to download the file
jsonObject.put("key", "uploadParams.Key");
// File content type
jsonObject.put("contentType", "uploadParams.ContentType");
// File URL address
jsonObject.put("url", "data.Location");

PublishOptions options = new PublishOptions();
rtmClient.publish("receiver", jsonObject.toString(), options, new ResultCallback<Void>() {
    @Override
    public void onSuccess(Void responseInfo) {
        // Handle message send result
    }

    @Override
    public void onFailure(ErrorInfo errorInfo) {
        // Handle errors
    }
});
```
<Admonition type="info" title="Info">
When using Amazon S3 for static file storage, you need to enter the Amazon S3 console and set the correct user permissions and access policies. Refer to [Access Control Best Practices](https://docs.aws.amazon.com/zh_en/AmazonS3/latest/userguide/access-control-best-practices.html) for details.
</Admonition>

## User Presence and Custom State

In v1, you could subscribe to or query the online status of multiple users, query the number of users or the list of online members in a channel, and more. V2 not only retains these capabilities but also upgrades and extends them based on v1, introducing the Presence module. The Presence module provides the ability to monitor user online and offline events, user temporary state changes, and allows you to obtain real-time information such as:

- When a user joins or leaves a specific channel
- Custom temporary user states and their changes
- Query which channels a specified user has joined or subscribed to
- Query which users have joined a specified channel and their temporary user state data

You can call the `whereNow` method to instantly query the number of online users, the list of online users, and the temporary state of online users in a specified channel.

```java
// v2
PresenceOptions options = new PresenceOptions();
options.setIncludeUserId(true);
options.setIncludeState(true);
options.setPage("yourBookMark");

rtmClient.getPresence().whoNow("channelName", RtmChannelType.MESSAGE, options, new ResultCallback<WhoNowResult>() {
    @Override
    public void onSuccess(WhoNowResult result) {
        // Handle the whoNow call result
    }

    @Override
    public void onFailure(ErrorInfo errorInfo) {
        // Handle errors
    }
});
```

You can call the `whereNow` method to instantly obtain the list of channels in which a specified user is located.
```java
// v2
rtmClient.getPresence().whereNow("Tony", new ResultCallback<ArrayList<ChannelInfo>>() {
    @Override
    public void onSuccess(ArrayList<ChannelInfo> channels) {
        // Handle the whereNow call result
    }

    @Override
    public void onFailure(ErrorInfo errorInfo) {
        // Handle errors
    }
});
```
To meet the requirements of setting user states for business scenarios, v2 provides the ability to set temporary user states. You can use the `setState` method to customize temporary user states. Users can add scores, game states, locations, moods, and custom states such as linking status.

```java
// v2
ArrayList<StateItem> stateItems = new ArrayList<>();
stateItems.add(new StateItem("mood", "pumped"));

rtmClient.getPresence().setState("channelName", RtmChannelType.MESSAGE, stateItems, new ResultCallback<Void>() {
    @Override
    public void onSuccess(Void responseInfo) {
        // Handle the setState call result
    }

    @Override
    can someone please explain this to me

    public void onFailure(ErrorInfo errorInfo) {
        // Handle errors
    }
});
```
You can also use the `getstate` method to get a user's online status at any time, or use the `removestate` method to delete a user's state. After a user's temporary state changes, the RTM server triggers the `REMOTE_STATE_CHANGED` type of `onpresenceevent` event notification. See Temporary User State for specific usage.

n v2, it is more convenient to real-time monitor notifications of users joining, leaving, timing out, or changing temporary states in a channel. You only need to follow these steps:

1. Implement the Presence event listener.

1. When subscribing to a channel, turn on the `withPresence` switch.

```java
// v2
// 1. Implement the Presence event listener
RtmEventListener eventListener = new RtmEventListener() {
        @Override
        public void onPresenceEvent(PresenceEvent event) {
            // Handle Precense event notifications
        }
    };
rtmClient.addEventListener(eventListener);

// 2. When subscribing to a channel, turn on the withPresence switch
SubscribeOptions options = new SubscribeOptions();
options.setWithPresence(true);
rtmClient.subscribe("channelName", options, new ResultCallback<Void>() {
    @Override
    public void onSuccess(Void responseInfo) {
        // Handle message subscription result
    }

    @Override
    public void onFailure(ErrorInfo errorInfo) {
        // Handle errors
    }
});
```
V2 has completely redesigned real-time notifications, adopting two modes to notify Presence events to subscribing users in a channel: **Real-time Notification Mode (Announce)** and **Interval Notification Mode (Interval)**. You can determine the conditions for switching between the two modes through the **Announce Max** size in the project settings on the console. The Interval Notification Mode can prevent event clutter caused by too many online users in a channel; see [Event Notification Modes](../reference/api#enumvpresencetypepropsag_platform) for details.

## User and Channel Properties

Based on the user and channel property functionality in v1, v2 has added capabilities such as version control and lock control, and optimized the API interface to make functionality usage simpler. In v2, user properties and channel properties are placed under the Storage module. Taking setting channel properties as an example, the code snippet is as follows:
```java
// v2
// Create a Metadata instance
Metadata metadata = rtmClient.getStorage().createMetadata();
// Set Major Revision
metadata.setMajorRevision(174298270);
// Add a Metadata Item
metadata.setMetadataItem(new MetadataItem("Apple", "100", 174298200));
// Add another Metadata Item
metadata.setMetadataItem(new MetadataItem("Banana", "200", 174298100));
// Record the timestamp and user ID when setting Metadata Items
MetadataOptions options = new MetadataOptions();
options.setRecordTs(true);
options.setRecordUserId(true);

rtmClient.getStorage().setChannelMetadata("channelName", RtmChannelType.MESSAGE, metadata, options, "lockName", new ResultCallback<Void>() {
    @Override
    public void onSuccess(Void responseInfo) {
        // Handle setChannelMetadata result
    }

    @Override
    public void onFailure(ErrorInfo errorInfo) {
        // Handle errors
    }
});
```
For details on how to get, update, delete channel properties, and how to use CAS control, lock control, etc., refer to [Channel Properties](../develop/storage#set-channel--metadata). The usage of user properties is similar to channel properties, as seen in [User Properties](../develop/storage#set-local-user-metadata).

V2 distributes channel properties and user properties to users through event notifications of the `onstorageevent` type. The steps to listen for `onstorageevent` event notifications are as follows:

1. Implement the Storage event listener.

1. When subscribing to a channel, turn on the `withMetadata` switch.
```java
// v2
// 1. Implement the Storage event listener
RtmEventListener eventListener = new RtmEventListener() {
        @Override
        public void onStorageEvent(StorageEvent event) {
            // Handle Storage event notifications
        }

        // Add other event notifications
    };
rtmClient.addEventListener(eventListener);

// 2. When subscribing to a channel, turn on the withMetadata switch
SubscribeOptions options = new SubscribeOptions();
options.setWithMetadata(true);
rtmClient.subscribe("channelName", options, new ResultCallback<Void>() {
    @Override
    public void onSuccess(Void responseInfo) {
        // Handle message subscription result
    }

    @Override
    public void onFailure(ErrorInfo errorInfo) {
        // Handle errors
    }
});
```

## Access Region Restriction
RTM supports the access region restriction feature to comply with laws and regulations in different countries or regions. When the access region restriction feature is enabled, regardless of where users use your app, the SDK will only access Agora servers in the specified region. The code to implement access region restriction is different between v2 and v1.

- Example code for v1:
    ```java
    // v1
    RtmServiceContext context = new RtmServiceContext();
    context.areaCode = RtmAreaCode.AREA_CODE_GLOB;
    setRtmServiceContext(context);
    ```

- Example code for v2:
    ```java
    // v2
    RtmConfig rtmConfig = new RtmConfig.Builder(appId, userId)
                    .areaCode(EnumSet.of(RtmAreaCode.AS))
                    .eventListener(eventListener)
                    .build();
    ```
    
## Other New Features

In addition to the differences in functionality between the versions mentioned above, v2 has also added many widely validated and used new features. You can choose and use them according to the needs of your project. It is believed that the innovative version v2 can help you quickly integrate into the real-time interactive field. The functional features that v2 possesses are explained in the [Product Overview](../overview/product-overview).

</PlatformWrapper>
