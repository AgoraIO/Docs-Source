<PlatformWrapper platform="react-native">

1. **Implement a client for Video Call**
    
    1. Create the UI

        Create the user interface (UI) for video call in the layout file of your project. For video call, we recommend adding the following elements into the UI:

        1. The start-call button
        1. The end-call button
        1. The local video view
        1. The remote video view

        You can create a `components` folder under the root directory of your project, add a `Style.ts` file under that folder, and add the code that defines the styles of the UI elements as follows to the file:

        ```typescript
        import {Dimensions, StyleSheet} from 'react-native'

        const dimensions = {
            width: Dimensions.get('window').width,
            height: Dimensions.get('window').height,
        }

        export default StyleSheet.create({
            max: {
                flex: 1,
            },
            buttonHolder: {
                height: 100,
                alignItems: 'center',
                flex: 1,
                flexDirection: 'row',
                justifyContent: 'space-evenly',
            },
            button: {
                paddingHorizontal: 20,
                paddingVertical: 10,
                backgroundColor: '#0093E9',
                borderRadius: 25,
            },
            buttonText: {
                color: '#fff',
            },
            fullView: {
                width: dimensions.width,
                height: dimensions.height - 100,
            },
            remoteContainer: {
                width: '100%',
                height: 150,
                position: 'absolute',
                top: 5
            },
            remote: {
                width: 150,
                height: 150,
                marginHorizontal: 2.5
            },
            noUserText: {
                paddingHorizontal: 10,
                paddingVertical: 5,
                color: '#0093E9',
            },
        })
        ```

    1. Import classes

        Open the `App.tsx` file, and delete all code. Add the following code to the beginning of the `App.tsx` file:

        ```typescript
        import React, {Component} from 'react';
        import {
            Platform,
            ScrollView,
            Text,
            TouchableOpacity,
            View,
            PermissionsAndroid,
        } from 'react-native';
        // Import the RtcEngine class and view rendering components into your project.
        import RtcEngine, {
            RtcLocalView,
            RtcRemoteView,
            VideoRenderMode,
        } from 'react-native-agora';
        // Import the UI styles.
        import styles from './components/Style';
        ```

    1. Add project permissions
    
        1. Android
            Add the following code to the `App.tsx` file to set a prompt box for getting permissions to use the microphone and camera on an Android device:

            ```typescript
            const requestCameraAndAudioPermission = async () => {
            try {
                const granted = await PermissionsAndroid.requestMultiple([
                PermissionsAndroid.PERMISSIONS.CAMERA,
                PermissionsAndroid.PERMISSIONS.RECORD_AUDIO,
                ]);
                if (
                granted['android.permission.RECORD_AUDIO'] ===
                    PermissionsAndroid.RESULTS.GRANTED &&
                granted['android.permission.CAMERA'] ===
                    PermissionsAndroid.RESULTS.GRANTED
                ) {
                console.log('You can use the cameras & mic');
                } else {
                console.log('Permission denied');
                }
            } catch (err) {
                console.warn(err);
            }
            };
            ```
        1. iOS
            In Xcode, open the info.plist file. Add the following contents to add permissions for your device:

            | Key 	                                 | Type   | Value                                                                                       |
            |----------------------------------------|--------|---------------------------------------------------------------------------------------------|
            | Privacy - Microphone Usage Description | String | The purpose for accessing the microphone, such as for a call or interactive live streaming. |
            | Privacy - Camera Usage Description     | String | The purpose for accessing the camera, such as for a call or interactive live streaming.     |

    1. Create an App Component

        When creating an App component, you need to define your `App ID`, `token`, and `channel name`, which will be used for initializing the RtcEngine object and joining the channel.

        - appId: The App ID of your Agora project. See [Get an App ID](../reference/manage-agora-account#get-the-app-id) for details.

        - channelName: The unique channel name for the AgoraRTC session. Users with the same App ID and channel name can join the same channel.

        - token: Pass a token that identifies the role and privilege of the user. The token must be generated using the preceding App ID and channel name. You can set it to one of the following values:
            A temporary token generated in Console. A temporary token is valid for 24 hours. For details, see [Get a Temporary Token](../reference/manage-agora-account#generate-a-temporary-token).
            A token generated at the server. This applies to scenarios with high-security requirements. For details, see Generate a token from Your Server.

        If your project has enabled the app certificate, ensure that you provide a token.

        Add the following code to the `App.tsx` file to create variables for initializing RtcEngine and joining a channel.

        ```typescript
        // Define a Props interface.
        interface Props {
        }

        // Define a State interface.
        interface State {
            appId: string,
            channelName: string,
            token: string,
            joinSucceed: boolean,
            peerIds: number[],
        }

        // Create an App component, which extends the properties of the Pros and State interfaces.
        export default class App extends Component<Props, State> {
            _engine?: RtcEngine
            // Add a constructorï¼Œand initialize this.state. You need:
            // Replace yourAppId with the App ID of your Agora project.
            // Replace yourChannel with the channel name that you want to join.
            // Replace yourToken with the token that you generated using the App ID and channel name above.
            constructor(props) {
                super(props)
                this.state = {
                    appId: 'yourAppId',
                    channelName: 'yourChannel',
                    token: 'yourToken',
                    joinSucceed: false,
                    peerIds: [],
                }
                if (Platform.OS === 'android') {
                    requestCameraAndAudioPermission().then(() => {
                        console.log('requested!')
                    })
                }
            }
            // Other code. See next steps.
        }
        ```

    1. Initialize RtcEngine

        Create and initialize the RtcEngine object before calling any other Agora APIs. Add the following code after the `// Other code line` in `App.tsx`:
        <ProductWrapper product="video-calling">
        ```typescript
        // Mount the App component into the DOM.
        componentDidMount() {
            this.init()
        }
        // Pass in your App ID through this.state, create and initialize an RtcEngine object.
        init = async () => {
            const {appId} = this.state
            this._engine = await RtcEngine.create(appId)
            // Enable the video module.
            await this._engine.enableVideo()

            // Listen for the UserJoined callback.
            // This callback occurs when the remote user successfully joins the channel.
            this._engine.addListener('UserJoined', (uid, elapsed) => {
                console.log('UserJoined', uid, elapsed)
                const {peerIds} = this.state
                if (peerIds.indexOf(uid) === -1) {
                    this.setState({
                        peerIds: [...peerIds, uid]
                    })
                }
            })

            // Listen for the UserOffline callback.
            // This callback occurs when the remote user leaves the channel or drops offline.
            this._engine.addListener('UserOffline', (uid, reason) => {
                console.log('UserOffline', uid, reason)
                const {peerIds} = this.state
                this.setState({
                    // Remove peer ID from state array
                    peerIds: peerIds.filter(id => id !== uid)
                })
            })

            // Listen for the JoinChannelSuccess callback.
            // This callback occurs when the local user successfully joins the channel.
            this._engine.addListener('JoinChannelSuccess', (channel, uid, elapsed) => {
                console.log('JoinChannelSuccess', channel, uid, elapsed)
                this.setState({
                    joinSucceed: true
                })
            })
        }
        ```
        </ProductWrapper>
        <ProductWrapper product="interactive-live-streaming">
        ```typescript
        // Mount the App component into the DOM.
        componentDidMount() {
            this.init()
        }
        // Pass in your App ID through this.state, create and initialize an RtcEngine object.
        init = async () => {
            const {appId} = this.state
            this._engine = await RtcEngine.create(appId)
            // Enable the video module.
            await this._engine.enableVideo()

            // Listen for the UserJoined callback.
            // This callback occurs when the remote user successfully joins the channel.
            this._engine.addListener('UserJoined', (uid, elapsed) => {
                console.log('UserJoined', uid, elapsed)
                const {peerIds} = this.state
                if (peerIds.indexOf(uid) === -1) {
                    this.setState({
                        peerIds: [...peerIds, uid]
                    })
                }
            })

            // Listen for the UserOffline callback.
            // This callback occurs when the remote user leaves the channel or drops offline.
            this._engine.addListener('UserOffline', (uid, reason) => {
                console.log('UserOffline', uid, reason)
                const {peerIds} = this.state
                this.setState({
                    // Remove peer ID from state array
                    peerIds: peerIds.filter(id => id !== uid)
                })
            })

            // Listen for the JoinChannelSuccess callback.
            // This callback occurs when the local user successfully joins the channel.
            this._engine.addListener('JoinChannelSuccess', (channel, uid, elapsed) => {
                console.log('JoinChannelSuccess', channel, uid, elapsed)
                this.setState({
                    joinSucceed: true
                })
            })
        }
        ```
        </ProductWrapper>

    1. Join a channel

        After initializing the `RtcEngine` object, you can call `joinChannel` to join a channel. Add this after the `init = async () => {` code block:

        ```typescript
        // Pass in your token and channel name through this.state.token and this.state.channelName.
        // Set the ID of the local user, which is an integer and should be unique. If you set uid as 0, 
        // the SDK assigns a user ID for the local user and returns it in the JoinChannelSuccess callback.
        startCall = async () => {
            await this._engine?.joinChannel(this.state.token, this.state.channelName, null, 0)
        }
        ```

    1. Render UI elements

        Call the `render()` method in the App component to render the UI elements and handle the button click event. Add the following code after `startCall` to the `App.tsx` file.

        ```typescript
        render() {
            return (
                <View style={styles.max}>
                    <View style={styles.max}>
                        <View style={styles.buttonHolder}>
                            <TouchableOpacity
                                onPress={this.startCall}
                                style={styles.button}>
                                <Text style={styles.buttonText}> Start Call </Text>
                            </TouchableOpacity>
                            <TouchableOpacity
                                onPress={this.endCall}
                                style={styles.button}>
                                <Text style={styles.buttonText}> End Call </Text>
                            </TouchableOpacity>
                        </View>
                        {this._renderVideos()}
                    </View>
                </View>
            )
        }
        ```
    
    1. Render the local video view

        Configure the video view of the local user. After joining the channel, the user can see themselves. You can also call `startPreview` to start the local video preview before joining the channel. Add the following code after `render()` in `App.tsx`:
        ```typescript
        // Set the rendering mode of the video view as Hidden, 
        // which uniformly scales the video until it fills the visible boundaries.
        _renderVideos = () => {
                const {joinSucceed} = this.state
                return joinSucceed ? (
                    <View style={styles.fullView}>
                        <RtcLocalView.SurfaceView
                            style={styles.max}
                            channelId={this.state.channelName}
                            renderMode={VideoRenderMode.Hidden}/>
                        {this._renderRemoteVideos()}
                    </View>
                ) : null
            }
        ```

    1. Render the remote video view

        In a video call, you should be able to see other users. After joining the channel, pass in the uid of the remote user sending the video, and set the video view of the remote user. Add the following code after `_renderVideos()` in `App.tsx`:

        ```typescript
        // Set the rendering mode of the video view as Hidden, 
        // which uniformly scales the video until it fills the visible boundaries.
        _renderRemoteVideos = () => {
                const {peerIds} = this.state
                return (
                    <ScrollView
                        style={styles.remoteContainer}
                        contentContainerStyle={{paddingHorizontal: 2.5}}
                        horizontal={true}>
                        {peerIds.map((value, index, array) => {
                            return (
                                <RtcRemoteView.SurfaceView
                                    style={styles.remote}
                                    uid={value}
                                    channelId={this.state.channelName}
                                    renderMode={VideoRenderMode.Hidden}
                                    zOrderMediaOverlay={true}/>
                            )
                        })}
                    </ScrollView>
                )
            }
        ```
    
    1. Leave the channel

        Call `leaveChannel` to leave the current channel according to your scenario. For example, when the video call ends, when you need to close the app, or when your app runs in the background. Add the following code after `_renderRemoteVideos()` in `App.tsx`:

        ```typescript
        endCall = async () => {
            await this._engine?.leaveChannel()
            this.setState({peerIds: [], joinSucceed: false})
        }
        ```

    1. Release resources

        When the user closes the <Vpl k="CLIENT" />, release all resources used by the Agora SDK. Add the following code after `componentDidMount()` in the `App.tsx` file.

        ```typescript
        // When the component is being uninstalled
        componentWillUnmount() {
            this._engine?.unregisterEventHandler(this);
            this._engine?.release();
        }
        ```
</PlatformWrapper>