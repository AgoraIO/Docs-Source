<PlatformWrapper platform="react-js">

This guide includes [complete sample code](#complete-sample-code) that demonstrates implementing basic real-time interaction. To understand the core API calls in the sample code, review the following implementation steps.

### Import Agora hooks and components

To use <Vpd k="SDK"/> in your component, include the following imports:


```jsx
import {
  LocalUser, // Plays the microphone audio track and the camera video track
  RemoteUser, // Plays the remote user audio and video tracks
  useIsConnected, // Returns whether the SDK is connected to Agora's server
  useJoin, // Automatically join and leave a channel on mount and unmount
  useLocalMicrophoneTrack, // Create a local microphone audio track
  useLocalCameraTrack, // Create a local camera video track
  usePublish, // Publish the local tracks
  useRemoteUsers, // Retrieve the list of remote users
} from "agora-rtc-react";
import AgoraRTC, { AgoraRTCProvider } from "agora-rtc-react";
import { useState } from "react";
```

### Initialize the client

Use the `createClient` method provided by the SDK to create a client object for the `<AgoraRTCProvider />` component. Wrap the `<Basics />` component with `<AgoraRTCProvider />` to enable state management and access operation-related hooks.

Set the channel profile, client role, and audience latency level according to your use case. 

| Use case | Channel profile | Client role | Latency level |
|----------|-----------------|-------------|---------------|
| **Voice calling** | `"rtc"` | — | `2`: Ultra low latency (default) |
| **Video calling** | `"rtc"` | — | `2`: Ultra low latency (default) |
| **Interactive live streaming** |  `"live"` | `"host"` or `"audience"` | `2`: Ultra low latency (default) |
| **Broadcast streaming** | `"live"` | `"host"` or `"audience"` | `1`: Low latency |

<Admonition type="info" title="Note">
**Key considerations before joining a channel:**

- **Publishing permissions**: Only hosts can publish media. Audience members cannot publish until promoted to host.

- **Channel profile selection**: Choose `rtc` mode for small group calls, typically under 17 participants, where all users publish. Use `live` mode for larger events where you manage hosts and audience separately.

- **Latency and pricing**: Latency settings only apply to audience members. Choosing low latency instead of ultra-low latency affects your [pricing](/realtime-communication/overview/pricing#basic-service) tier.
</Admonition>

The following example shows a live-streaming audience configuration. Adjust the mode, role, and latency values according to your use case.

```jsx
export const RealtimeCommunication = () => {
  // Example: interactive live streaming as an audience member
  const client = AgoraRTC.createClient({ mode: "live", codec: "vp8" });

  client.setClientRole("audience", { level: 2 });

  // For voice or video calling:
  // use mode: "rtc" and do not set a client role

  // For broadcast streaming:
  // client.setClientRole("audience", { level: 1 });

  // To join as a host:
  // client.setClientRole("host");

  return (
    <AgoraRTCProvider client={client}>
      <Basics />
    </AgoraRTCProvider>
  );
};
```

### Join a channel

To join a channel, use the `useJoin` hook. You can specify the following `joinOptions`:

- **App ID**: [`appid`](../get-started/manage-agora-account#get-the-app-id) identifies the project you created in <Vg k="CONSOLE" />.

- **Channel name**: The name of the `channel` to join. Clients that pass the same channel name join the same channel. If a channel with the specified name does not exist, it is created when the first user joins.

- **Authentication token**: A `token` is a dynamic key that authenticates a user when the client joins a channel. In a production environment, you obtain a token from a [token server](../token-authentication/deploy-token-server) in your security infrastructure. For the purpose of this guide [Generate a temporary token](../get-started/manage-agora-account#generate-temporary-tokens).

- **User ID**: `uid` is a 32-bit signed integer that identifies a user in the channel. You can specify a unique user ID for each user yourself. If you do not set a user ID or set it to `0` when joining a channel, the SDK generates a random number for the user ID and returns the value. 

Add the following to `Basics`:

```jsx
const [appId, setAppId] = useState("<-- Insert App ID -->");
const [channel, setChannel] = useState("<-- Insert Channel Name -->");
const [token, setToken] = useState("<-- Insert Token -->");
const [calling, setCalling] = useState(false);

useJoin({appid: appId, channel: channel, token: token ? token : null}, calling);
```

### Create local audio and video tracks

To create local audio and video tracks, use the `useLocalMicrophoneTrack` and `useLocalCameraTrack` hooks. Add the following to `Basics`

```jsx
const { localMicrophoneTrack } = useLocalMicrophoneTrack(micOn);
const { localCameraTrack } = useLocalCameraTrack(cameraOn);
```

### Publish tracks in the channel

After joining a channel, publish the local audio and video tracks using the `usePublish` hook. Add the following to `Basics`:

```jsx
const [micOn, setMic] = useState(true);
const [cameraOn, setCamera] = useState(true);
const { localMicrophoneTrack } = useLocalMicrophoneTrack(micOn);
const { localCameraTrack } = useLocalCameraTrack(cameraOn);

usePublish([localMicrophoneTrack, localCameraTrack]);
```

### Display the local video

To display the local video, use the `LocalUser` hook, which provides properties to manage local audio and video tracks. Assign the local video track to `videoTrack` and the audio track to `audioTrack`. Use the `micOn` and `cameraOn` parameters to toggle audio and video. Include the following code in the markup of your `Basics` component:

```jsx
<LocalUser
  audioTrack={localMicrophoneTrack}
  cameraOn={cameraOn}
  micOn={micOn}
  videoTrack={localCameraTrack}
  style={{width: '50%', height: 300 }}
>
```

### Display remote video

To manage and display the list of remote users connected to a channel, use the `useRemoteUsers` hook. To show each user's video, pass the user object to the `RemoteUser` component along with the required properties. Follow these steps to implement the logic:

1. **Retrieve the list of remote users**

   Use the `useRemoteUsers` hook to get the current list of remote users:

   ```jsx
   const remoteUsers = useRemoteUsers();
   ```

2. **Render the remoteUser component**

    Loop through the `remoteUsers` list and nest the `RemoteUser` component where you want to display each user's video. Include the following code in the markup of your `Basics` component:

    ```jsx
    {remoteUsers.map((user) => (
      <div key={user.uid}>
        <RemoteUser user={user} style={{ width: '50%', height: 300 }}>
          <samp>{user.uid}</samp>
        </RemoteUser>
      </div>
    ))}
    ```

### Leave the channel​

To leave a channel, destroy the component, close the browser window, or refresh the browser tab. The `useJoin` hook automatically handles the destruction of the React component.

### Complete sample code

A complete code sample demonstrating the basic process of real-time interaction is provided for your reference. To use the complete sample, add the following to your `src/App.tsx` file.

<details>
<summary>Complete sample code for real-time <Vpd k="PRODUCT"/></summary>

```jsx
import {
  LocalUser,
  RemoteUser,
  useIsConnected,
  useJoin,
  useLocalMicrophoneTrack,
  useLocalCameraTrack,
  usePublish,
  useRemoteUsers,
} from "agora-rtc-react";
import { useState } from "react";
import AgoraRTC, { AgoraRTCProvider } from "agora-rtc-react";


export const RealtimeCommunication = () => {
  const client = AgoraRTC.createClient({ mode: "live", codec: "vp8" });
  return(
        <AgoraRTCProvider client={client}>
          <Basics />
        </AgoraRTCProvider>
  );
}

const Basics = () => {
  const [calling, setCalling] = useState(false);
  const isConnected = useIsConnected(); // Store the user's connection status
  const [appId, setAppId] = useState("<-- Insert App ID -->");
  const [channel, setChannel] = useState("<-- Insert Channel Name -->");
  const [token, setToken] = useState("<-- Insert Token -->");
  const [micOn, setMic] = useState(true);
  const [cameraOn, setCamera] = useState(true);

  
  const { localMicrophoneTrack } = useLocalMicrophoneTrack(micOn);
  const { localCameraTrack } = useLocalCameraTrack(cameraOn);

  useJoin({appid: appId, channel: channel, token: token ? token : null}, calling);
  usePublish([localMicrophoneTrack, localCameraTrack]);

  const remoteUsers = useRemoteUsers();

  return (
    <>
      <div>
        {isConnected ? (
          <div>
            <div>
              <LocalUser
                audioTrack={localMicrophoneTrack}
                cameraOn={cameraOn}
                playAudio={false} // Plays the local user's audio track. You use this to test your mic before joining a channel.
                micOn={micOn}
                videoTrack={localCameraTrack}
                style={{width: '90%', height: 300 }}
              >
                <samp>You</samp>
              </LocalUser>
            </div>
            {remoteUsers.map((user) => (
              <div key={user.uid}>
                <RemoteUser user={user} style={{width: '90%', height: 300 }}>
                  <samp>{user.uid}</samp>
                </RemoteUser>
              </div>
            ))}
          </div>
        ) : (
          <div>
            <input
              onChange={e => setAppId(e.target.value)}
              placeholder="<Your app ID>"
              value={appId}
            />
            <input
              onChange={e => setChannel(e.target.value)}
              placeholder="<Your channel Name>"
              value={channel}
            />
            <input
              onChange={e => setToken(e.target.value)}
              placeholder="<Your token>"
              value={token}
            />

            <button
              disabled={!appId || !channel}
              onClick={() => setCalling(true)}
            >
              <span>Join Channel</span>
            </button>
          </div>
        )}
      </div>
      {isConnected && (
        <div style={{padding: "20px"}}>
          <div>
            <button onClick={() => setMic(a => !a)}>
              {micOn ? "Disable mic" : "Enable mic" }
            </button>
            <button onClick={() => setCamera(a => !a)}>
              {cameraOn ? "Disable camera " : "Enable camera" }
            </button>
            <button
              onClick={() => setCalling(a => !a)}
              >
              {calling ? "End calling" : "Start calling"}
            </button>
          </div>
        </div>
      )}
    </>
  );
};
  
export default RealtimeCommunication;
```

</details>

</PlatformWrapper>
