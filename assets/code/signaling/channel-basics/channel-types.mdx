<PlatformWrapper platform='android'>
<Vg k="AGORA_BACKEND" /> channels can be categorized into three types according to their usage and message delivery methods, namely **Message Channel**, **User Channel**, and **Stream Channel** which are distinguished by the `channelType` parameter in the API. The main differences between the three channel types are as follows:

    - **Message Channel**: This channel type uses a common communication method that follows a **publish-subscribe** model to deliver messages, similar to the **MQTT protocol**. When using this model, there is no need to create a channel in advance, just publish messages to a specific channel or subscribe to a specific channel to receive messages. Due to its flexibility, users can easily implement different topologies such as one-to-one channels, group channels, broadcast channels, unicast channels, and so on. Because this channel type usually has a large number of subscribers, there is no guarantee that all subscribers will send delivery receipts when they receive a message.
    - **User Channel**: This channel type is used to send peer-to-peer messages to a specified `userId`. When you use it, just set the `channelType` parameter in the `publish` method to `USER` and the `channelName` parameter to the `userId` of the other party. You don't need to subscribe to receive messages, you just need to implement the `onMessageEvent` event listener. Because it is one-to-one message sending and receiving, this channel type supports the **delivery receipt** function. That is, after the sender sends a message, if the receiver is online and receives the message successfully, it will return `success`; if the receiver is not online or the reception fails, it will return `failure` or `timeout`. This channel type can only implement a one-to-one topology. Although you can judge whether the other party is online or not by the return value, we recommend using the `Presence` function for this.
    - **Stream Channel**: This is a special type of channel that follows the room concept similar to the observer pattern. In this type of channel, users cannot send messages directly. User needs to call the `joinTopic` method first to register as the publisher of the topic before they can send messages. If the user wants to receive messages, they need to subscribe to the specified message publisher (identified by `userId`) in the specified topic. In addition, client-side messages support delivery at higher QPS. This channel type is often recommended for meta-universe, parallel driving, and cloud gaming scenarios.

In addition, `Presence`, `Storage`, and `Lock` functions can be enabled in both **Message Channel** and **Stream Channel** as needed. However, **User Channels** cannot utilize these features and can be treated as a simple message pass-through channel.
</PlatformWrapper>
<PlatformWrapper platform={['ios','macos']}>
<Vg k="AGORA_BACKEND" /> channels can be categorized into three types according to their usage and message delivery methods, namely **Message Channel**, **User Channel**, and **Stream Channel** which are distinguished by the `channelType` parameter in the API. The main differences between the three channel types are as follows:

    - **Message Channel**: This channel type uses a common communication method that follows a publish-subscribe model to deliver messages, similar to the MQTT protocol. When using this model, there is no need to create a channel in advance, just publish messages to a specific channel or subscribe to a specific channel to receive messages. Due to its flexibility, users can easily implement different topologies such as one-to-one channels, group channels, broadcast channels, unicast channels, and so on. Because this channel type usually has a large number of subscribers, there is no guarantee that all subscribers will send delivery receipts when they receive a message.
    - **User Channel**: This channel type is used to send peer-to-peer messages to a specified `userId`. When you use it, just set the `channelType` parameter in the `publish` method to `AgoraRtmChannelTypeUser` and the `channelName` parameter to the `userId` of the other party. You don't need to subscribe to receive messages, you just need to implement the `didReceiveMessageEvent` event listener. Because it is one-to-one message sending and receiving, this channel type supports the **delivery receipt** function. That is, after the sender sends a message, if the receiver is online and receives the message successfully, it will return `success`; if the receiver is not online or the reception fails, it will return `failure` or `timeout`. This channel type can only implement a one-to-one topology. Although you can judge whether the other party is online or not by the return value, we recommend using the `Presence` function for this.
    - **Stream Channel**: This is a special type of channel that follows the room concept similar to the observer pattern. In this type of channel, users cannot send messages directly. User needs to call `joinTopic` method first to register as the publisher of the Topic before they can send messages. If the user wants to receive messages, they need to subscribe to the specified message publisher (identified by `userId`) in the specified Topic. In addition, client-side messages support delivery at higher QPS. This channel type is often recommended for meta-universe, parallel driving, and cloud gaming scenarios.

In addition, `Presence`, `Storage`, and `Lock` functions can be enabled in both **Message Channel** and **Stream Channel** as needed. However, **User Channels** cannot utilize these features and can be treated as a simple message pass-through channel.
</PlatformWrapper>

<PlatformWrapper platform = 'web'>
There are two types of channels in the <Vg k="AGORA_BACKEND" />, namely **Message** and **Stream**, which are distinguished in the API by `channelType`. The main differences between the two channel types are as follows:

|Channel type |Main characteristics |Applicable scenarios |
|:------------|:--------------------|:--------------------|
|Message      |Following the industry-standard **Pub/Sub (publish/subscribe) model** to deliver messages and events, channels do not need to be created in advance and are available on demand. There is no cap (upper limit) on the number of publishers and subscribers in a channel, but there is a limit on the upstream QPS (queries per second) for a single channel. |Common applications based on pub/sub scenarios and multi-device access applications, such as multi-device management and command sending/receiving in the IoT industry, multi-terminal management and command sending/receiving location tracking in smart devices, large communities, and so on. |
|Stream       |Following the room concept similar to the observer pattern in the industry, users need to join the channel in order to send and receive event notifications. Messages are managed and delivered via topics within the channel, and a single channel allows up to 1000 users to join at the same time. It supports co-channel and synchronous transmission of audio and video data with <Vg k="COMPANY" />. In addition, it also supports client-side message delivery with higher QPS. |High-frequency and high-concurrency data transmission scenarios as well as scenarios where <Vg k="COMPANY" /> audio and video data are synchronously transmitted in the same channel, for example, metaverse, parallel driving, cloud gaming, and so on. |

A channel can be thought of as a conduit that controls the flow of messages. **Message** and **Stream** channels use different strategies for controlling the message flow:

    - In a **Message Channel**, a publisher can simply deliver a message to a specific channel, and then any device or user subscribed to that channel can receive that message or event notification.
    - In a **Stream Channel**, users cannot send messages directly. Users need to call `joinTopic` method to register as the publisher of the topic before they can send messages. If a user wants to receive messages, they need to subscribe to a specific message publisher (identified by user ID) in a given topic in order to receive the messages from that publisher.

Except for messages, the mechanism and usage of **Message Channel** and **Stream Channel** for notification of other events such as **Presence**, **Storage**, **Lock**, and others are the same.
</PlatformWrapper>
<PlatformWrapper platform='unity'>
There are two types of channels in the <Vg k="AGORA_BACKEND" />, namely **Message** and **Stream**, which are distinguished in the API by `RTM_CHANNEL_TYPE`. The main differences between the two channel types are as follows:

|Channel type |Main characteristics |Applicable scenarios |
|:------------|:--------------------|:--------------------|
|Message      |Following the industry-standard pub/sub (publish/subscribe) model to deliver messages and events, channels do not need to be created in advance and are available on demand. There is no cap (upper limit) on the number of publishers and subscribers in a channel, but there is a limit on the upstream QPS (queries per second) for a single channel. |Common applications based on pub/sub scenarios and multi-device access applications, such as multi-device management and command sending/receiving in the IoT industry, multi-terminal management and command sending/receiving location tracking in smart devices, large communities, and so on. |
|Stream       |Following the room concept similar to the observer pattern in the industry, users need to join the channel in order to send and receive event notifications. Messages are managed and delivered via topics within the channel, and a single channel allows up to 1000 users to join at the same time. It supports co-channel and synchronous transmission of audio and video data with <Vg k="COMPANY" />. In addition, it also supports client-side message delivery with higher QPS. |High-frequency and high-concurrency data transmission scenarios as well as scenarios where <Vg k="COMPANY" /> audio and video data are synchronously transmitted in the same channel, for example, metaverse, parallel driving, cloud gaming, and so on. |

A channel can be thought of as a conduit that controls the flow of messages. **Message** and **Stream** channels use different strategies for controlling the message flow:

    - In a **Message Channel**, a publisher can simply deliver a message to a specific channel, and then any device or user subscribed to that channel can receive that message or event notification.
    - In a **Stream Channel**, users cannot send messages directly. Users need to call `JoinTopicAsync` method to register as the publisher of the topic before they can send messages. If a user wants to receive messages, they need to subscribe to a specific message publisher (identified by user ID) in a given topic in order to receive the messages from that publisher.

Except for messages, the mechanism and usage of **Message Channel** and **Stream Channel** for notification of other events such as **Presence**, **Storage**, **Lock**, and others are the same.
</PlatformWrapper>
<PlatformWrapper platform='linux-cpp'>
There are two types of channels in the <Vg k="AGORA_BACKEND" />, namely **Message** and **Stream**, which are distinguished in the API by `RTM_CHANNEL_TYPE`. The main differences between the two channel types are as follows:

|Channel type |Main characteristics |Applicable scenarios |
|:------------|:--------------------|:--------------------|
|Message      |Following the industry-standard pub/sub (publish/subscribe) model to deliver messages and events, channels do not need to be created in advance and are available on demand. There is no cap (upper limit) on the number of publishers and subscribers in a channel, but there is a limit on the upstream QPS (queries per second) for a single channel. |Common applications based on pub/sub scenarios and multi-device access applications, such as multi-device management and command sending/receiving in the IoT industry, multi-terminal management and command sending/receiving location tracking in smart devices, large communities, and so on. |
|Stream       |Following the room concept similar to the observer pattern in the industry, users need to join the channel in order to send and receive event notifications. Messages are managed and delivered via topics within the channel, and a single channel allows up to 1000 users to join at the same time. It supports co-channel and synchronous transmission of audio and video data with <Vg k="COMPANY" />. In addition, it also supports client-side message delivery with higher QPS. |High-frequency and high-concurrency data transmission scenarios as well as scenarios where <Vg k="COMPANY" /> audio and video data are synchronously transmitted in the same channel, for example, metaverse, parallel driving, cloud gaming, and so on. |

A channel can be thought of as a conduit that controls the flow of messages. **Message** and **Stream** channels use different strategies for controlling the message flow:

    - In a **Message Channel**, a publisher can simply deliver a message to a specific channel, and then any device or user subscribed to that channel can receive that message or event notification.
    - In a **Stream Channel**, users cannot send messages directly. Users need to call `joinTopic` method to register as the publisher of the topic before they can send messages. If a user wants to receive messages, they need to subscribe to a specific message publisher (identified by user ID) in a given topic in order to receive the messages from that publisher.

Except for messages, the mechanism and usage of **Message Channel** and **Stream Channel** for notification of other events such as **Presence**, **Storage**, **Lock**, and others are the same.
</PlatformWrapper>
