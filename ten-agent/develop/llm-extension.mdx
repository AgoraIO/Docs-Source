---
title: 'Create an extension with a predefined type'
sidebar_position: 2
type: docs
description: >
  Deploy your customized agent by creating a release docker image.
---

## Extension types

When developing Extensions, we often notice that implementations for Extensions of the same category share similarities. For example, the Extensions for Gemini and OpenAI have similar implementation logic, but they also differ in certain details. To improve development efficiency, these similar Extension implementations can be abstracted into a generic Extension type. During actual development, you only need to inherit from this type and implement a few specific methods.

Currently, TEN Agent supports the following Extension types:

- `AsyncLLMBaseExtension`: Designed for implementing large language model Extensions, such as those similar to OpenAI.
- `AsyncLLMToolBaseExtension`: Used to implement tool Extensions for large language models. These are Extensions that provide tool capabilities based on Function Call mechanisms.

This abstraction helps standardize development while reducing repetitive work.

You can execute the following command in the TEN project to install the abstract base class library:

```bash
tman install system ten_ai_base@0.1.0
```

## Extension behavior

### LLM Extension and LLMTool Extension

Any LLMTool Extension can be connected with an LLM Extension. When the LLMTool is started, it will automatically connect to the LLM Extension.

When the LLM Extension detects a Function Call, it will pass the Function Call to the LLMTool Extension for processing. Once the LLMTool Extension has completed the processing, it will return the result to the LLM Extension.


## LLM Extension

### Creating AsyncLLMBaseExtension using tman

Run the following command,

```bash
tman install extension default_async_llm_extension_python --template-mode --template-data package_name=llm_extension --template-data class_name_prefix
=LLMExtension
```

### Abstract APIs to implement

`on_data_chat_completion(self, ten_env: TenEnv, **kargs: LLMDataCompletionArgs) -> None`

This method is called when the LLM Extension receives a data completion request. It's used when data is passed in via data protocol in streaming mode.

`on_call_chat_completion(self, ten_env: TenEnv, **kargs: LLMCallCompletionArgs) -> any`

This method is called when the LLM Extension receives a call completion request. It's used when data is passed in via call protocol in non-streaming mode.

This method is called when the LLM Extension receives a call completion request.

`on_tools_update(self, ten_env: TenEnv, tool: LLMToolMetadata) -> None`

This method is called when the LLM Extension receives a tool update request.

### APIs

#### `cmd_in: tool_register`

This API is used to consume the tool registration request. An array of LLMToolMetadata will be received as input. The tools will be appended to `self.available_tools` for future use.

#### `cmd_out: tool_call`

This API is used to send the tool call request. You can connect this API to any LLMTool extension destination to get the tool call result.

## LLM Tool Extension


### Creating AsyncLLMToolBaseExtension by using tman

Run the following command,

```bash
tman install extension default_async_llm_tool_extension_python --template-mode --template-data package_name=llm_tool_extension --template-data class_name_prefix
=LLMToolExtension
```

### Abstract APIs to implement

`get_tool_metadata(self, ten_env: TenEnv) -> list[LLMToolMetadata]`

This method is called when the LLM Extension is going to register itself to any connected LLM. It should return a list of LLMToolMetadata.

`run_tool(self, ten_env: AsyncTenEnv, name: str, args: dict) -> LLMToolResult`

This method is called when the LLM Extension receives a tool call request. It should execute the tool function and return the result.

### APIs

#### `cmd_out: tool_register`

This API is used to send the tool registration request. An array of LLMToolMetadata returned from `get_tool_metadata` will be sent as output.

#### `cmd_in: tool_call`

This API is used to consume the tool call request. The `run_tool` will be executed when the cmd_in is received.
