<PlatformWrapper platform="unity">

### Implement the user interface

To create a simple interface to test this feature, you add two buttons to the UI.

    1. In **Sample Scene**, right-click **Canvas**, then click **UI** > **Button - TextMeshPro**. A button appears in the **Scene** Canvas.

    2. In **Inspector**, rename **Button** to `realTimeTranscription`, and then change the following coordinates:

        * **Pos X** - -140
        * **Pos Y** - -172
        * **Width** - 250

    3. Select the **Text(TMP)** sub-item of `realTimeTranscription`, and in **Inspector**, change **Text** to *Start transcription*.

    4. Use the same procedure to create a button called `queryRealTimeTranscription` with a **Text(TMP)** sub-item where its **Text** says *Query real-time transcription*.

    5. To adjust the position and size of `queryRealTimeTranscription`, in **Inspector**, change the following coordinates:

        * **Pos X** - 110
        * **Pos Y** - -172
        * **Width** - 240

### Handle the system logic

To integrate HTTP and JSON capabilities into your <Vpl k="CLIENT" /> for real-time transcription:

1. **Add the required namespaces**

    To start, stop, and query a real-time transcription task, in your script file, add the following to the list of namespaces:

    ```csharp
    using System.IO;
    using System.Net;
    using System.Text;
    using System;
    ```

1. **Define variables to manage a real-time transcription task**

    In your script file, add the following declarations to `NewBehaviourScript`:

    ```csharp
    private string baseUrl = "https://api.agora.io";
    private string apiKey = "<your API key from Agora console>";
    private string apiSecret = "<your API secret from Agora console>";
    private string instanceID = "Test-1";
    private string authorizationHeader, builderToken;
    private string realTimeTranscriptionTaskId = ""; // Returned by the start method.
    private bool isRealTimeTranscriptionRunning = false;
    int Uid = 1;
    ```

### Manage a real-time transcription

Take the following steps to start, stop and query a real-time transcription task in your <Vpl k="CLIENT" />.

1. **Get a `builderToken`**

    To [acquire a builderToken](#acquire-a-buildertoken), you:

    1. Generate a Base64-encoded credential from the API key and secret associated with your <Vg k="COMPANY" /> project.
    1. Add this credential to the request header as a parameter named `Authorization`.
    1. In the request body, you pass the `instanceID` that you use to identify the instance.

    To [acquire a `builderToken`](#acquire-a-buildertoken), in your script file, add the following method to `NewBehaviourScript`:

    ```csharp
    public void fetchBuilderToken()
    {
        string url = baseUrl + "/v1/projects/"+ _appID +"/rtsc/speech-to-text/builderTokens";
        // Concatenate customer key and customer secret and use base64 to encode the concatenated string
        string plainCredentials = apiKey + ":" + apiSecret;
        // Encode the credentials to base64
        var plainTextBytes = Encoding.UTF8.GetBytes(plainCredentials);
        string encodedCredential = Convert.ToBase64String(plainTextBytes);
        // Create an authorization header.
        authorizationHeader = "Authorization: Basic " + encodedCredential;
        // Create a request object.
        WebRequest request = WebRequest.Create(url);
        // Specify the request method.
        request.Method = "POST";
        Debug.Log(authorizationHeader);
        // Add the authorization header to the request.
        request.Headers.Add(authorizationHeader);
        request.ContentType = "application/json";
        using (var streamWriter = new StreamWriter(request.GetRequestStream()))
        {
            string json = @"
            {
                ""instanceId"":""" + instanceID + @"""
            }";
            streamWriter.Write(json);
        }
        // Send request and receive a response.
        WebResponse response = request.GetResponse();
        using (Stream dataStream = response.GetResponseStream())
        {
            // Read the response and extract the token.
            StreamReader reader = new StreamReader(dataStream);
            string responseFromServer = reader.ReadToEnd();
            Debug.Log(responseFromServer);
            if(((HttpWebResponse)response).StatusDescription != "OK")
            {
                Debug.Log("Request failed! Make sure request parameters are correct");
                return;
            }
            responseFromServer = responseFromServer.Replace("{", "");
            responseFromServer = responseFromServer.Replace("}", "");
            String[] list1 = responseFromServer.Split(",");
            String[] list2 = list1[2].Split(":");
            builderToken = list2[1];
            builderToken = builderToken.Replace("\"", "");
            Debug.Log(builderToken);
        }
        response.Close();
    }
    ```
    To execute this method at startup, in your script file, add the following at the end of `SetupVideoSDKEngine`:

    ```csharp
    fetchBuilderToken();
    ```
    A `builderToken` is usable for 5 minutes. After the time has expired, you must generate a new token.

1. **Start a real-time transcription task**

    To [start a real-time transcription task](#start-a-real-time-transcription-task), you:
    1. Create a JSON configuration and pass it in the body of a `POST` request.
    1. Add the `builderToken` as a query parameter to the URL.
    1. Make a POST call to  <Vg k="AGORA_BACKEND" />.
    On success, the method returns a `taskId` that you use to query or stop the task.

    To start a task, in your script file, add the following method to `NewBehaviourScript`:

    ```csharp
    public void startRealTimeTranscription()
    {
        if(isRealTimeTranscriptionRunning)
        {
            stopRealTimeTranscription();
            return;
        }
        string url = baseUrl + "/v1/projects/" + _appID + "/rtsc/speech-to-text/tasks?" + "builderToken=" + builderToken;
        Debug.Log(url);
        // Create a request object
        WebRequest request = WebRequest.Create(url);
        // Specify the request type.
        request.Method = "POST";
        // Add the authorization header.
        request.Headers.Add(authorizationHeader);
        request.ContentType = "application/json";
        using (var streamWriter = new StreamWriter(request.GetRequestStream()))
        {
            // Setup a JSON string to specify a real-time transcription configuration.
            string json = @"
            {
                ""audio"": 
                {
                    ""subscribeSource"": ""AGORARTC"",
                    ""agoraRtcConfig"": 
                    {
                        ""channelName"": """ + _channelName + @""",
                        ""uid"": """ + Uid + @""",
                        ""token"": """ + _token + @""",
                        ""channelType"": ""LIVE_TYPE"",
                        ""subscribeConfig"": 
                        {
                            ""subscribeMode"": ""CHANNEL_MODE""
                        },
                        ""maxIdleTime"": 60
                    }
                },
                ""config"": 
                {
                    ""features"": 
                    [
                        ""RECOGNIZE""
                    ],
                    ""recognizeConfig"": 
                    {
                        ""language"": ""ENG"",
                        ""model"": ""Model"",
                        ""output"":
                        {
                            ""destinations"": 
                            [
                                ""AgoraRTCDataStream"",
                                ""Storage""
                            ],
                            ""agoraRTCDataStream"": 
                            {
                                ""channelName"": """ + _channelName + @""",
                                ""uid"": """ + Uid + @""",
                                ""token"": """ + _token + @"""
                            },
                            ""cloudStorage"":
                            [
                                {
                                    ""format"": ""HLS"",
                                    ""storageConfig"": 
                                    {
                                        ""vendor"": 0,
                                        ""region"": 0,
                                        ""bucket"":""<YourBucket>"",
                                        ""accessKey"":""<YourOssAccessKey>"",
                                        ""secretKey"":""<YourOssSecretKey>""
                                    },
                                    ""fileNamePrefix"":
                                    [
                                        ""directory1"",
                                        ""directory2""
                                    ]
                                }
                           ]
                        }
                    }
                }
            }";
            streamWriter.Write(json);
        }
        WebResponse response = request.GetResponse();
        using (Stream dataStream = response.GetResponseStream())
        {
            // Read response and learn about the status of the real-time transcription task.
            StreamReader reader = new StreamReader(dataStream);
            string responseFromServer = reader.ReadToEnd();
            Debug.Log(responseFromServer);
            if(((HttpWebResponse)response).StatusDescription != "OK")
            {
                Debug.Log("Request failed! Make sure request parameters are correct");
                return;
            }
            responseFromServer = responseFromServer.Replace("{", "");
            responseFromServer = responseFromServer.Replace("}", "");
            String[] list1 = responseFromServer.Split(",");
            String[] tempList= list1[1].Split(":");
            string status = tempList[1];
            status = status.Replace("\"", "");
            if(status == "STARTED"|| status == "IN_PROGRESS")
            {
                Debug.Log("Real-time transcription service has been enabled");
                String[] list2 = list1[2].Split(":");
                realTimeTranscriptionTaskId = list2[1];
                realTimeTranscriptionTaskId = realTimeTranscriptionTaskId.Replace("\"", "");
                isRealTimeTranscriptionRunning = true;
            }
            else
            {
                isRealTimeTranscriptionRunning = false;
                realTimeTranscriptionTaskId = "";
                Debug.Log("Real-time transcription status: " + status + "");
            }
        }
        response.Close();
    }
    ```

1. **Query task status**

    You [query the status](#query-the-status-of-real-time-transcription) of a real-time transcription task using a `GET` request containing the `taskId` and `builderToken` to notify the user of any change. To do this, in your script file, add the following method to `NewBehaviourScript`:

    ```csharp
    public void queryRealTimeTranscription()
    {
        string url = baseUrl + "/v1/projects/" + _appID
            + "/rtsc/speech-to-text/tasks/" + realTimeTranscriptionTaskId
            + "?builderToken=" + builderToken;
        // Create a request object.
        WebRequest request = WebRequest.Create(url);
        // Specify the request type.
        request.Method = "GET";
        // Add the authorization header.
        request.Headers.Add(authorizationHeader);
        request.ContentType = "application/json";
        WebResponse response = request.GetResponse();
        using (Stream dataStream = response.GetResponseStream())
        {  
            // Parse the response to get the query results.
            StreamReader reader = new StreamReader(dataStream);
            string responseFromServer = reader.ReadToEnd();
            Debug.Log(responseFromServer);
            if(((HttpWebResponse)response).StatusDescription != "OK")
            {
                Debug.Log("Request failed! Make sure request parameters are correct");
                return;
            }
            responseFromServer = responseFromServer.Replace("{", "");
            responseFromServer = responseFromServer.Replace("}", "");
            String[] list1 = responseFromServer.Split(",");
            String[] tempList= list1[1].Split(":");
            string status = tempList[1];
            status = status.Replace("\"", "");
            if(status == "STARTED"|| status == "IN_PROGRESS")
            {
                Debug.Log("Real-time transcription service is running");
                isRealTimeTranscriptionRunning = true;
            }
            else
            {
                isRealTimeTranscriptionRunning = false;
                realTimeTranscriptionTaskId = "";
                Debug.Log("Real-time transcription service is not running: " + status + "");
            }
        }
        response.Close();
    }
    ```

1. **Stop the task**

    To [stop real-time transcription](#stop-real-time-transcription), you send a `DELETE` request with the, `appId`, `taskId` and `builderToken` in the URL. In your script file, add the following method to `NewBehaviourScript`:

    ```csharp
    public void stopRealTimeTranscription()
    {
        String url = baseUrl + "/v1/projects/" + _appID
            + "/rtsc/speech-to-text/tasks/" + realTimeTranscriptionTaskId
            + "?builderToken=" + builderToken;
        // Create request object
        WebRequest request = WebRequest.Create(url);
        // Specify the request type.
        request.Method = "DELETE";
        // Add the authorization header.
        request.Headers.Add(authorizationHeader);
        request.ContentType = "application/json";
        WebResponse response = request.GetResponse();
        if(((HttpWebResponse)response).StatusDescription != "OK")
        {
            Debug.Log("Request failed! Make sure request parameters are correct");
            return;
        }
        if(((HttpWebResponse)response).StatusDescription == "OK")
        {
            Debug.Log("Real-time transcription task stopped");
            isRealTimeTranscriptionRunning = false;
            realTimeTranscriptionTaskId = "";
        }
        else
        {
            Debug.Log("Error while stopping real-time transcription:" + ((HttpWebResponse)response).StatusDescription);
        }
        response.Close();
    }
    ```
1. **Receive and display the text stream**

    When you set one of the `destinations` in the starting configuration as `AgoraRTCDataStream`, the real-time transcription conversion output stream is pushed to your channel  and you receive it using `OnStreamMessage`.

    To receive this stream and display the text in your <Vpl k="CLIENT" />, in your script file, add the following code before `public override void OnUserJoined(RtcConnection connection, uint uid, int elapsed)`:

    ```csharp
    public override void OnStreamMessage(RtcConnection connection, uint remoteUid, int streamId, byte[] data, uint length, UInt64 sentTs)
    {
        Debug.Log(Encoding.Default.GetString(data));
    }
    ```

1. **Enable a user to start, query and stop a task**

    In this example, you use buttons to manage a real-time transcription-to-text task. When a user presses the real-time transcription-to-text button, the <Vpl k="CLIENT" /> calls `startRealTimeTranscription` and starts a real-time transcription-to-text task using the `builderToken`. If a task is already running, the <Vpl k = "CLIENT"/> stops the task. When the user presses the query button, the <Vpl k="CLIENT"/> calls `queryRealTimeTranscription` and informs you of the current status of the real-time transcription-to-text task. To implement this logic, in your script file, add the following at the end of `SetupUI`:

    ```csharp
    go = GameObject.Find("realTimeTranscription");
    go.GetComponent<Button>().onClick.AddListener(startRealTimeTranscription);
    go = GameObject.Find("queryRealTimeTranscription");
    go.GetComponent<Button>().onClick.AddListener(queryRealTimeTranscription);
    GameObject.Find("realTimeTranscription").GetComponentInChildren<TextMeshProUGUI>().fontSize = 16;
    GameObject.Find("queryRealTimeTranscription").GetComponentInChildren<TextMeshProUGUI>().fontSize = 16;
    ```
</PlatformWrapper>
