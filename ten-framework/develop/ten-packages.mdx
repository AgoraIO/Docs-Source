---
title: 'TEN packages'
sidebar_position: 15
platform_selector: false
description: >
  TEN package structure
---

A basic TEN framework software package has the following structure:

```text
.
├── bin/
├── src/
├── manifest.json
├── manifest-lock.json
├── property.json
└── ten_packages/
    ├── extension/
    │   ├── <extension_foo>/
    │   └── <extension_bar>/
    ├── extension_group/
    │   └── <extension_group_x>/
    ├── protocol/
    │   └── <protocol_a>/
    └── system/
        ├── <system_package_1>/
        └── <system_package_2>/
```

Depending on the programming language, there may be additional required files. For example, a C++ project using the `ten_gn` build system includes a `BUILD.gn` file. A Go project includes files such as `go.mod` and `go.sum`. A Python project might include a `requirements.txt` file.

## TEN Framework package types

TEN Framework software packages fall into the following types:

| Type            | Description                     |
| :-------------- | :------------------------------ |
| App             | Contains a TEN app.             |
| Extension group | Contains a TEN extension group. |
| Extension       | Contains a TEN extension.       |
| Protocol        | Contains a TEN protocol.        |
| System          | Contains a TEN system package.  |

## App

An app is a container in the TEN world that contains groups and extensions. An app can function as a process placed inside a Docker container (primarily used in the cloud).
An app can also function as a thread embedded within an existing app (on client or server).
TEN can perform localized modifications (minor enhancements) on an existing project without requiring the entire project to be rewritten according to TEN.

![Run TEN as a process or a thread](/images/ten-framework/run_ten_as_process_or_thread.png)

![Different modes of app running](/images/ten-framework/different_mode_of_app_runnings.png)

### TEN App folder structure

In the TEN framework, you can create TEN packages using various programming languages. Regardless of the language used, the overall folder structure of a TEN app remains consistent, ensuring uniformity across different implementations.

![TEN package folder structure](/images/ten-framework/ten_package_folder_structure.png)

## Extensions

### Extension life cycle

The life cycle of an extension is divided into the following stages:

1. `on_configure`
2. `on_init`
3. `on_start`
4. `on_stop`
5. `on_deinit`

At each stage, the extension can send messages. If the message is a command type, the extension can also receive the result of the command it sends. In other words, there is no point where the extension _cannot_ send messages or receive the results of its own commands. This helps implement dependencies between extensions.

Each life cycle stage corresponds to a callback function, and there is a corresponding `on_xxx_done()` function to mark the end of that life cycle stage.

| Life cycle callback | End of life cycle function |
| ------------------- | -------------------------- |
| `on_configure`      | `on_configure_done`        |
| `on_init`           | `on_init_done`             |
| `on_start`          | `on_start_done`            |
| `on_stop`           | `on_stop_done`             |
| `on_deinit`         | `on_deinit_done`           |

The following figure shows the stage transition graph.

![](/images/ten-framework/stage-transition-graph.png)

#### `on_configure`

Used to set the initial values of the extension's properties. This allows the `get_property` API from `ten_env` to be used in other lifecycle stages to retrieve properties set during the `on_configure()` stage. The `on_configure_done()` function is called to mark the end of the `on_configure` stage.

```cpp
void on_configure(ten::ten_env_t &ten_env) override {
  // Set the initial values of the extension's properties.
  ten_env.init_property_from_json(
    R"({
         "ten": {
           "uri": "msgpack://127.0.0.1:8001/",
           "log_level": 2
         }
       })", nullptr);
  ten_env.on_configure_done();
}
```

#### `on_init`

Used to initialize the extension. Since the extension is not ready until `on_init_done()` is called, the TEN runtime queues all messages sent to the extension until it is ready. Once ready, the queued messages are delivered to the extension. It is important to note that if the result is from a command sent by the extension itself, it is _not_ subject to this restriction; the TEN runtime directly passes the command's result back to the extension. This is because sending a command is a self-initiated action by the extension, so it must be prepared to receive and handle the result of its own commands.

#### `on_start`

This stage marks the runtime starting to send messages into the extension. The `on_start_done` function doesn't have a special purpose, but for consistency with other life cycle stages and to reduce learning complexity, the TEN framework includes it. Typically, `on_start_done` is invoked at the end of the `on_start` callback function. The TEN runtime starts delivering messages from other extensions to this extension after receiving its `on_start_done()`.

```cpp
  void on_start(ten::ten_env_t &ten_env) override {
    // Some operations.
    ten_env.on_start_done();
  }
```

#### `on_stop`

There are situations where the extension needs to stop, such as when the app or engine containing the extension is terminating. When the extension is about to stop, the TEN runtime uses the `on_stop` callback to notify the extension that it has entered the `on_stop` life cycle stage. The extension can then perform any necessary actions for termination.

#### `on_deinit`

After the extension calls `on_stop_done()`, it enters the `on_deinit` stage. During this stage, because the resources within the extension may no longer be fully available, the TEN runtime does not pass any messages from other extensions to this one.

### Relationship between extensions at different life cycle stages

There is no inherent relationship between extensions at different life cycle stages. Each extension operates independently, switching between its own life cycle stages. Extensions are independent of one another, and any dependencies between them must be explicitly implemented by the extensions themselves. The TEN runtime does not make any assumptions or guarantees. For example, if extension A needs to wait for extension B to complete its initialization before finishing its own, extension A can send a command to extension B during its `on_init`. Once extension B completes initialization and receives the command, it can reply with a result, and when extension A receives the result, it can call `on_init_done`.

![](/images/ten-framework/extension-sequence.png)

In all other life cycle stages, if you want to implement the order of different extensions, you can achieve it using a similar approach.

### Interface with TEN Runtime

Extensions interact with the TEN runtime primarily through three interfaces:

1. **Lifecycle callbacks**

   - These include callbacks like `on_init`, `on_deinit`, `on_start`, and `on_stop`.

2. **Callbacks for receiving messages**

   - These include callbacks such as `on_cmd`, `on_data`, `on_audio_frame`, and `on_video_frame`, which handle incoming messages to the extension.

3. **Functions for sending messages**

   - These include functions like `send_cmd`, `send_data`, `send_audio_frame`, and `send_video_frame`, which send messages out of the extension.

### Lifecycle callbacks

The different stages of an extension's lifecycle and their connection to message handling are as follows:

- **`on_init` ~ `on_init_done`**: Handles the extension's own initialization. At this stage, the extension can send messages and receive the results of commands it sends, but cannot receive messages actively sent by other extensions.

- **`on_start` ~ `on_start_done`**: At this stage, the extension can send messages and receive the results of commands it sends, but cannot receive messages actively sent by other extensions. Since properties are initialized during `on_configure`, you can perform actions that depend on these properties being set up. However, as this is still part of the initialization phase, the extension does receive messages initiated by others, avoiding the need for various checks. Active message sending is allowed.

- **After `on_start_done` ~ `on_stop_done`**: During this phase, the extension can normally send and receive all types of messages and their results.

- **`on_deinit` ~ `on_deinit_done`**: Handles the extension's de-initialization. Similar to the `on_init` stage, at this stage, the extension can send messages and receive the results of commands it sends, but cannot receive messages actively sent by other extensions.

### Implementing extensions in different languages

Within the TEN framework, you can implement extensions in various languages such as C++, Go, and Python. Use the same conceptual approach to implement extensions in different languages. Learning how to develop an extension in one language makes it relatively easy to do so in other languages as well.

### Asynchronous message processing in extensions

Extensions process messages asynchronously. When the TEN runtime delivers a message to an extension through callbacks like `on_cmd`, `on_data`, `on_audio_frame`, or `on_video_frame`, the extension is not required to process the message immediately within the callback. Instead, the extension can delegate the message to other threads, processes, or even machines for processing. This allows for full utilization of multi-core and distributed computing resources.

![Asynchronous Message Processing](/images/ten-framework/asynchronous_message_processing.png)

After processing is complete, the results are sent back to the TEN runtime through callbacks such as `send_cmd`, `send_data`, `send_audio_frame`, or `send_video_frame`. The entire process is asynchronous, meaning the extension doesn't need to send the processed results back before the `on_cmd`, `on_data`, `on_audio_frame`, or `on_video_frame` callbacks return. The results can be transmitted when they are ready, using the appropriate send functions.


### Python async extension

TEN's Python async extension provide a powerful way to handle long-running tasks asynchronously. By integrating Python’s `asyncio` framework, the extensions ensure that operations such as network calls or file handling are efficient and non-blocking. 
If you want to wrap existing Python code that use `asyncio` into a TEN extension, using the Python async extension is the simplest and most convenient option.

**Example: The Default Python Async Extension**

A Python async extension is structured as follows:

```python
import asyncio
from ten_runtime import AsyncExtension, AsyncTenEnv

class DefaultAsyncExtension(AsyncExtension):
    async def on_configure(self, ten_env: AsyncTenEnv) -> None:
        # Mock async operation, e.g. network, file I/O.
        await asyncio.sleep(0.5)

    async def on_init(self, ten_env: AsyncTenEnv) -> None:
        # Mock async operation, e.g. network, file I/O.
        await asyncio.sleep(0.5)

    async def on_start(self, ten_env: AsyncTenEnv) -> None:
        # Mock async operation, e.g. network, file I/O.
        await asyncio.sleep(0.5)

    async def on_deinit(self, ten_env: AsyncTenEnv) -> None:
        # Mock async operation, e.g. network, file I/O.
        await asyncio.sleep(0.5)

    async def on_cmd(self, ten_env: AsyncTenEnv, cmd: Cmd) -> None:
        cmd_json = cmd.to_json()
        ten_env.log_debug(f"DefaultAsyncExtension on_cmd: {cmd_json}")

        # Mock async operation, e.g. network, file I/O.
        await asyncio.sleep(0.5)

        # Send a new command to other extensions and wait for the result. The
        # result will be returned to the original sender.
        new_cmd = Cmd.create("hello")
        cmd_result = await ten_env.send_cmd(new_cmd)
        ten_env.return_result(cmd_result, cmd)
```

Each method simulates a delay using `await asyncio.sleep()`.

#### Aysnc loop for event handling

- Create a queue using `asyncio.Queue`.
- Create an async task for event handling.

Refer to the following sample code:

```python
import asyncio
from ten_runtime import AsyncExtension, AsyncTenEnv

class DefaultAsyncExtension(AsyncExtension):
    queue = asyncio.Queue()
    loop:asyncio.AbstractEventLoop = None

    async def on_start(self, ten_env: AsyncTenEnv) -> None:
        self.loop = asyncio.get_event_loop()

        self.loop.create_task(self._consume())

    async def on_stop(self, ten_env: AsyncTenEnv) -> None:
        self.queue.put(None)

    async def _consume(self) -> None:
        while True
            try:
                value = await self.queue.get()
                if value is None:
                    self.ten_env.log_info("async loop exit")
                    break

                # Code for processing values retrieved from the queue.

            except Exception as e:
                self.ten_env.log_error(f"Failed to handle {e}")
```

## Development and release packages

A TEN package can be categorized as either a:

- Release package
- Development package

The relationship between the two package types is as follows:

- A release package is generated from a development package through a build process.
- Adding source-related content to a release package makes it a development package.
- Removing source-related content from a development package makes it a release package.

The directory structures of development and release packages are very similar. The main difference is that a development package includes source-related content, whereas a release package does not.

### Development package

A development package is primarily used to create or modify TEN software packages. For example, to develop a new TEN extension, you can modify an existing development package. Development packages include all source-related content, which enables you to create new TEN software packages from them.

### Release package

A release package is primarily used to create and run graphs. It does not require any build tasks, so you can use it directly for these operations. A development package can also be used to perform the same tasks. However, a development package has a broader application scope than a release package.