---
title: 'Schema system'
sidebar_position: 10
platform_selector: false
description: >
  TEN framework schema system: define and validate data structures for extensions, messages, and properties with type safety and consistency.
---

The TEN framework uses a schema system to define and validate data structures throughout the runtime environment. Schemas provide type definitions for extension properties and messages. The schema system offers the following key benefits:

- **Type safety** - Prevents runtime errors by validating data types before processing
- **Data consistency** - Ensures all extensions interpret data structures identically
- **Clear contracts** - Provides explicit interface definitions between components
- **Automatic validation** - Validates data at runtime without manual checking
- **Cross-language compatibility** - Maintains consistent data handling across C++, Go, and Python extensions

TEN schemas differ from standard JSON Schema - they define metadata specific to the TEN runtime's type system and validation requirements, using JSON only as the representation format. Schemas are defined in manifest files and applied automatically when extensions exchange data or access properties.

## Schema design principles

The TEN framework schema system follows three core design principles that ensure consistency and prevent conflicts across all schema definitions.

- **Object principle**
   The schema for every field in the TEN framework must be defined as an object. This ensures a structured and consistent format across all schema definitions.

   ```json
   {
     "foo": {
       "type": "int8"
     }
   }
   ```

   Incorrect format:

   ```json
   {
     "foo": "int8"
   }
   ```

- **Metadata-only principle**
   The schema defines only metadata, not actual data values. This separation ensures that the schema remains a template for validation and does not mix with data content.

- **Conflict prevention principle**
   In any JSON level containing a TEN schema, all fields must be user-defined, except for reserved fields like `ten`. This prevents conflicts between user-defined fields and system-defined fields.

   Example with user-defined fields:

  ```json
  {
    "user_timeout": {
      "type": "int32"
    },
    "custom_setting": {
      "type": "string"
    }
  }
  ```

  Example with reserved `ten` field:

  ```json
  {
    "ten": {
      "framework_metadata": {}
    },
    "user_timeout": {
      "type": "int32"
    },
    "custom_setting": {
      "type": "string"
    }
  }
  ```

### Schema syntax and formatting
All TEN schemas follow consistent formatting rules:

- **Object structure**: Each field definition must be an object with a type property
- **Nested properties**: Objects use properties to define their field schemas
- **Array items**: Arrays use items to define the schema for their elements
- **Type specification**: The type field specifies the data type using TEN framework type names

The schema structure directly mirrors the data it describes, making it intuitive to understand the relationship between schema definitions and actual data values.

## Schema types and structure

The TEN framework supports both primitive and complex data types in schema definitions, allowing you to describe simple values as well as structured data.

### Primitive types

The TEN framework provides fundamental data types that correspond to common programming language primitives:

**Numeric types:**
- `int8`, `int16`, `int32`, `int64` - Signed integers of various sizes
- `uint8`, `uint16`, `uint32`, `uint64` - Unsigned integers of various sizes  
- `float32`, `float64` - Single and double precision floating-point numbers

**Other primitive types:**
- `string` - Unicode character sequences
- `bool` - Binary true/false values
- `buf` - Sequences of 8-bit unsigned bytes
- `ptr` - Pointers to memory addresses

**Primitive type schema syntax:**

```json
{
  "timeout": {
    "type": "int32"
  },
  "username": {
    "type": "string"
  },
  "enabled": {
    "type": "bool"
  }
}
```

### Complex types 
Complex types enable structured data representation for more sophisticated use cases.
Object type represents key-value pairs with string keys:

- **Object type** represents key-value pairs with string keys:

  ```json
  {
    "config": {
      "type": "object",
      "properties": {
        "host": {
          "type": "string"
        },
        "port": {
          "type": "int32"
        },
        "ssl_enabled": {
          "type": "bool"
        }
      }
    }
  }
  ```

- **Array** type represents collections of elements with the same type:

  ```json
  {
    "servers": {
      "type": "array",
      "items": {
        "type": "string"
      }
    }
  }
  ```

## Property schemas

Property schemas define the structure and types for extension configuration data stored in `property.json` files. These schemas enable type validation and ensure consistent property handling across your TEN application.

Property schemas are defined in the `api.property` section of your manifest file. Each property name maps to a schema definition that describes its expected type and structure.

For example, given this property data:

```json
{
  "database_config": {
    "host": "localhost",
    "port": 5432,
    "credentials": {
      "username": "admin",
      "password": "secret123"
    }
  }
}
```

The corresponding TEN property schema definition is as follows:

```json
{
  "api": {
    "property": {
      "database_config": {
        "type": "object",
        "properties": {
          "host": {
            "type": "string"
          },
          "port": {
            "type": "int32"
          },
          "credentials": {
            "type": "object",
            "properties": {
              "username": {
                "type": "string"
              },
              "password": {
                "type": "string"
              }
            }
          }
        }
      }
    }
  }
}
```

This schema ensures that:
- `host` must be a string value
- `port` must be a 32-bit integer
- `credentials` must be an object containing string values for `username` and `password`

The TEN runtime validates property data against this schema to ensure type safety and structural correctness.

## TEN schema for commands

**Input command example**

```json
{
  "ten": {
    "name": "cmd_foo",
    "seq_id": "123",
    "dest": [
      {
        "app": "msgpack://127.0.0.1:8001/",
        "graph": "default",
        "extension_group": "group_a",
        "extension": "extension_b"
      }
    ]
  },
  "foo": 3,
  "bar": "hello world"
}
```

**Corresponding TEN schema**

```json
{
  "api": {
    "cmd_in": [
      {
        "name": "cmd_foo",
        "ten": {
          "name": {
            "type": "string"
          },
          "seq_id": {
            "type": "string"
          },
          "dest": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "app": {
                  "type": "string"
                },
                "graph": {
                  "type": "string"
                },
                "extension_group": {
                  "type": "string"
                },
                "extension": {
                  "type": "string"
                }
              }
            }
          }
        },
        "property": {
          "foo": {
            "type": "int8"
          },
          "bar": {
            "type": "string"
          }
        }
      }
    ]
  }
}
```

To avoid redundancy, the TEN framework allows you to exclude the `ten` field from your schema definition, as it is reserved and defined by the runtime.

### Defining command results

Command results are defined similarly to commands, but are used to describe the expected response:

```json
{
  "api": {
    "cmd_in": [
      {
        "name": "cmd_foo",
        "property": {
          "foo": {
            "type": "int8"
          },
          "bar": {
            "type": "string"
          }
        },
        "result": {
          "property": {
            "aaa": {
              "type": "int8"
            },
            "bbb": {
              "type": "string"
            }
          }
        }
      }
    ]
  }
}
```

## TEN schema for data, video frames, and audio frames

The process for defining schemas for data, video frames, and audio frames is similar to that for commands but without the result field.

## Manifest schema overview

The `manifest.json` file contains the schema definitions for an extensionâ€™s properties and messages. These schemas ensure that the extension's configuration and communication follow the correct structure and type requirements.

**Sample `manifest.json`**

```json
{
  "type": "extension",
  "name": "A",
  "version": "1.0.0",
  "dependencies": [],
  "api": {
    "property": {
      "app_id": {
        "type": "string"
      },
      "channel": {
        "type": "string"
      },
      "log": {
        "type": "object",
        "properties": {
          "level": {
            "type": "uint8"
          },
          "redirect_stdout": {
            "type": "bool"
          },
          "file": {
            "type": "string"
          }
        }
      }
    },
    "cmd_in": [],
    "cmd_out": [],
    "data_in": [],
    "data_out": [],
    "video_frame_in": [],
    "video_frame_out": [],
    "audio_frame_in": [],
    "audio_frame_out": []
  }
}
```

The TEN framework schema system provides a robust and structured way to define and validate data structures, ensuring consistency and safety across extensions and their interactions within the TEN runtime. By adhering to the principles of object structure, metadata focus, and conflict prevention, the system facilitates clear and effective communication between components.