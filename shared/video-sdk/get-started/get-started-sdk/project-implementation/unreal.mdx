<PlatformWrapper platform="unreal">
### Implement the user interface

For a basic <Vpl k="NAME" /> <Vpl k="CLIENT" />, you need the following user widgets:

* Two image widgets: One to display the local video and one to display the remote video.

* Two button widgets: One to join the channel and one to leave the channel.

<ProductWrapper product="interactive-live-streaming">
* One selector to choose to join as the host or the audience
</ProductWrapper>

To implement this user interface, you need a `UserWidget` class. You use this class to create a blueprint that you use to add the required user widgets. To implement this workflow, do the following:

1. **Add a user widget class**

    In Unreal Editor, go to **Tools** > **New C++ Class**. The **Add C++ Class** window opens. Click **All Classes** and input `UserWidget` in the **Search** field. From the search results, select `UserWidget` and click **Next**, then click **Create Class**. A new C++ class is added to your project and the class source code opens in Visual Studio IDE.

2. **Create a blueprint for the user widget class**

    In **Content Browser**, go to **Add** > **Blueprint Class**. The **Pick Parent Class** window opens. Expand the **ALL CLASSES** dropdown and input `MyUserWidget` in the **Search** field. From the search results, select `MyUserWidget` and press **Select**. You see a new blueprint in the content folder called `NewBlueprint`.

3. **Add the join and leave buttons**

    In **Content Browser**, navigate to the content folder and double-click `NewBlueprint`. The blueprint opens in the editor. To add buttons to the UI, take the following steps:

    1. Add a canvas panel. Drag **Canvas Panel** from the **Panel** section of the **Palette Panel** to the **Graph**. You see a canvas panel appears in the **Graph**.

    1. Drag **Button** from the **Common** section of the **Palette Panel** to the canvas panel. You see a button appears on the canvas panel.
    
    1. In **Details**, rename **Button_0** to `JoinBtn`, then change the following coordinates:

        * **Position X** - 1000
        * **Position Y** - 960
        * **Size X** - 130
        * **Size Y** - 60

    1. Use the same procedure to create a button called `LeaveBtn` and change the following properties in **Details**.

        * **Position X** - 1150
        * **Position Y** - 960
        * **Size X** - 130
        * **Size Y** - 60

    The sample code uses **Text** as a button label. You need two **Text** widgets, one for the join button and one for the leave button.

    5. To add **Text**, drag **Text** from the **Common** section of the **Palette Panel** to the canvas panel, then change the following properties in **Details**.

        * **Position X** - 1030
        * **Position Y** - 972
        * **Size X** - 96
        * **Size Y** - 40

    1. To change the **Text** widget text, in **Details**, input `Join` in the **Text** field.

    1. Use the same procedure and add one more **Text**, then change the following coordinates in **Details**.

        * **Position X** - 1168
        * **Position Y** - 972

    1. In **Details**, input `Leave` in the **Text** field.

2. **Add the local and remote video views**

    You use **Image Widget** to display the local and remote video streams. To add image widgets in your <Vpl k = "CLIENT"/>, take the following steps:

    1. For local video, drag **Image** from the **Common** section of the **Palette Panel** to the canvas panel.

    2. In **Details**, rename **Image_0** to **localView**, and change the following coordinates:

        * **Position X** - 442
        * **Position Y** - 336
        * **Size X** - 400
        * **Size Y** - 400

    3. For remote video, use the same procedure to create an **Image** called **remoteView** with the following coordinates:

        * **Pos X** - 924
        * **Pos Y** - 336
        * **Size X** - 400
        * **Size Y** - 400

<ProductWrapper product="interactive-live-streaming">
3. **Enable the user to join a channel as the host or the audience**

    1. Drag **Check Box** from the **Common** section of the **Palette Panel** to the canvas panel, and change the following properties in **Details**.

        * **Pos X** - 1040
        * **Pos Y** - 772

    1. In **Details**, rename **CheckBox_0** to `hostToggle`.

    1. Use the same procedure to create a **Check Box** called **audienceToggle**, then change the following coordinates in **Details**:
        
        * **Pos X** - 1040 
        * **Pos Y** - 820     

    1. Add a text widget for `hostToggle`. Drag **Text** from **Palette Panel** to the canvas panel and change the following properties in **Details**.

        * **Pos X** - 1070
        * **Pos Y** - 772

    1. To change the text of the text widget, in **Details**, input `Host` in the **Text** field.

    1. Use the same procedure and a text widget for `audienceToggle` where the **Text** field says `Audience`, then change the following properties in **Details**:

        * **Pos X** - 1070
        * **Pos Y** - 820

    
</ProductWrapper>
    Click **Compile**. You see the question mark on the **Compile** button turns to a green tick. This means you have successfully added new widgets to the blueprint.

3. **Add the widget blueprint to viewport**

    Once you have created and laid out your widget blueprint, in order for it to be displayed in your game, you need to call it by using the **Create Widget** and **Add to Viewport** nodes inside **Level Blueprint**. To implement this workflow, take the following steps:

    1. In the list of world blueprints, click **Open Level Blueprint**. The **Event Graph** window opens.

    1. Right-click in the **Event Graph** window and input `event beginplay` in the **Search** field. From the search results, choose **Event BeginPlay**. You see a node appears in **Level Blueprint**.

    1. Use the same procedure and add the **Create Widget** node and the **Add to Viewport** node to **Level Blueprint**.

    1. Connect **Event BeginPlay** to the left connectors of the **Construct None** node.

    1. Connect the two right pins of the **Construct NONE** node to the **Add to Viewport** left pins.

    1. Set the **Class** field on the **Construct NONE** node to `NewBlueprint`.

    1. Click **Compile** in the **Event Graph** window. The yellow question mark turns green.

    Your **Event Graph** looks like:
      
      ![image](/images/video-sdk/unreal-blueprint.png)

To check that you successfully added `NewBlueprint` to the view port. In Unreal Editor, click **Play**. You see the following UI:
<ProductWrapper product="video-calling">
![image](/images/video-sdk/unreal-video-calling-ui.png)
</ProductWrapper>
<ProductWrapper product="interactive-live-streaming">
![image](/images/video-sdk/unreal-ILS-ui.png)
</ProductWrapper>

### Handle the system logic

Import the necessary C++ libraries, set up your <Vpl k="CLIENT" /> to run on Android, and request permissions for the camera and microphone.

1. **Reference the user widgets**

    In Visual Studio, add the following property specifiers to `MyUserWidget.h` after `GENERATED_BODY()`:

    <ProductWrapper product="video-calling">
    ```cpp
    UPROPERTY(BlueprintReadWrite, meta = (BindWidget))
	UImage* remoteView = nullptr;
    UPROPERTY(BlueprintReadWrite, meta = (BindWidget))
	UImage* localView = nullptr;
    UPROPERTY(VisibleAnywhere, BlueprintReadWrite, meta = (BindWidget))
	UButton* JoinBtn = nullptr;
    UPROPERTY(VisibleAnywhere, BlueprintReadWrite, meta = (BindWidget))
	UButton* LeaveBtn = nullptr;
    ```
    </ProductWrapper>

    <ProductWrapper product="interactive-live-streaming">
    ```cpp
      UPROPERTY(BlueprintReadWrite, meta = (BindWidget))
		UImage* remoteView = nullptr;
      UPROPERTY(BlueprintReadWrite, meta = (BindWidget))
		UImage* localView = nullptr;
      UPROPERTY(VisibleAnywhere, BlueprintReadWrite, meta = (BindWidget))
		UButton* JoinBtn = nullptr;
      UPROPERTY(VisibleAnywhere, BlueprintReadWrite, meta = (BindWidget))
		UButton* LeaveBtn = nullptr;
      UPROPERTY(BlueprintReadWrite, meta = (BindWidget))
		UCheckBox* hostToggle = nullptr;
	  UPROPERTY(BlueprintReadWrite, meta = (BindWidget))
		UCheckBox* audienceToggle = nullptr;
    ```
    </ProductWrapper>

    To access the user widgets from the blueprint, in `MyUserWidget.h`, add the following before `#include "MyUserWidget.generated.h"`:
    <ProductWrapper product="video-calling">
    ```cpp
    #include "Components/Image.h"
    #include "Components/Button.h"
    ```
    </ProductWrapper>
    <ProductWrapper product="interactive-live-streaming">
    ```cpp
    #include "Components/Image.h"
    #include "Components/Button.h"
    #include "Components/CheckBox.h"
    ```
    </ProductWrapper>

1. **Setup event listeners for the buttons**

    In `MyUserWidget.h`, add the following to `UMyUserWidget` after `UButton* LeaveBtn = nullptr;`:
    <ProductWrapper product="video-calling">
    ```cpp
    UFUNCTION(BlueprintCallable)
	void OnLeaveButtonClick();
    UFUNCTION(BlueprintCallable)
	void OnJoinButtonClick();
    ```
    </ProductWrapper>
    <ProductWrapper product="interactive-live-streaming">
    ```cpp
    UFUNCTION(BlueprintCallable)
	void OnLeaveButtonClick();
    UFUNCTION(BlueprintCallable)
	void OnJoinButtonClick();
	UFUNCTION(BlueprintCallable)
	void OnCheckboxChanged(bool bIsChecked);
    ```
    </ProductWrapper>

3. **Manage Android permissions**

    1. Add the Unreal Android libraries. In `MyUserWidget.h`, add the following before `#include "MyUserWidget.generated.h"`:

        ```cpp
        #if PLATFORM_ANDROID
        #include "AndroidPermission/Classes/AndroidPermissionFunctionLibrary.h"
        #endif
        ```

    2. Setup a function to check permissions are granted. In `MyUserWidget.h`, add the following method declaration to `UMyUserWidget`:

        ``` cpp
        void CheckAndroidPermission();
        ```

    3. Add the logic of requesting permissions to `CheckAndroidPermission`. In `MyUserWidget.cpp`, add the following method before `setupVideoSDKEngine`:

        ```cpp
        void UMyUserWidget::CheckAndroidPermission() 
        {
            #if PLATFORM_ANDROID
            FString pathfromName = UGameplayStatics::GetPlatformName();
            if (pathfromName == "Android")
            {
                TArray<FString> AndroidPermission;
                AndroidPermission.Add(FString("android.permission.CAMERA"));
                AndroidPermission.Add(FString("android.permission.RECORD_AUDIO"));
                AndroidPermission.Add(FString("android.permission.READ_PHONE_STATE"));
                AndroidPermission.Add(FString("android.permission.WRITE_EXTERNAL_STORAGE"));
                UAndroidPermissionFunctionLibrary::AcquirePermissions(AndroidPermission);
            }
        #endif
        }
        ```

### Implement the channel logic

The following figure shows the API call sequence of implementing  <Vpd k="PRODUCT" />.

<ProductWrapper product="video-calling">
    ![image](/images/video-sdk/video-call-logic-unity.svg)
</ProductWrapper>

<ProductWrapper product="interactive-live-streaming">
    ![image](/images/video-sdk/ils-call-logic-unity.svg)
</ProductWrapper>

To implement this logic, take the following steps:

1. **Import the <Vg k="COMPANY"/> library**

    In `MyUserWidget.h`, add the following header file before `#include "MyUserWidget.generated.h"`:
    
    ```cpp
    #include "AgoraPluginInterface.h"
    ```

    To import the required <Vg k="COMPANY"/> namespaces, add the following before `UCLASS()`:

    ```cpp
    using namespace agora::rtc;
    using namespace agora;
    ```
1. **Import <Vg k = "COMPANY"/> dependency module**

    In `AgoraImplementation.Build.cs`, update the following line:

        ```cpp
        PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore", "Json"});
        ```

    With the following line:

        ```cpp
        PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore", "Json","AgoraPlugin"});
        ```

1. **Declare the variables that you use to create and join a channel**

    In `MyUserWidget.h`, add the following declarations to `UMyUserWidget`:

    <ProductWrapper product="video-calling">
    ```cpp
    protected:
    IRtcEngine* agoraEngine;
	std::string appId = "";
	std::string channelName = "";
	std::string token = "";
	bool isJoin = false;
	int remoteUId;
    ```
    </ProductWrapper>

    <ProductWrapper product="interactive-live-streaming">
    ``` csharp
    IRtcEngine* agoraEngine;
	std::string appId = "";
	std::string channelName = "";
	std::string token = "";
	bool isJoin = false;
	int remoteUId;
    std::string userRole;
    ```
    </ProductWrapper>

1. **Setup <Vg k="ENGINE"/>**

    To setup an instance of <Vg k="ENGINE"/>, take the following steps:

    1. Setup a function to add the logic of creating an engine instance. In `MyUserWidget.h`, add the following method declaration to `UMyUserWidget`:

        ```cpp
       	void setupVideoSDKEngine();
        ```

    2. Setup an instance of the <Vg k = "VSDK"/>. Add the following method to `MyUserWidget.cpp`:

        <ProductWrapper product="video-calling">
        ``` cpp
        void UMyUserWidget::setupVideoSDKEngine() 
        {
            // Create an engine instance.
            agoraEngine = createAgoraRtcEngine();
            // Specify a context for the engine.
            RtcEngineContext context;
            context.appId = appId.c_str();
            context.eventHandler = this;
            // Choose the communication profile for video calling.
            context.channelProfile = CHANNEL_PROFILE_TYPE::CHANNEL_PROFILE_COMMUNICATION;
            // Initialize the engine instance with the context.
            agoraEngine->initialize(context);
            // Enable the local audio capture to init the local video stream.
            agoraEngine->enableAudio();
            // Enable the local video capture to init the local video stream.
            agoraEngine->enableVideo();
            // Attach event listener functions to the button.
            LeaveBtn->OnClicked.AddDynamic(this, &UMyUserWidget::OnLeaveButtonClick);
            JoinBtn->OnClicked.AddDynamic(this, &UMyUserWidget::OnJoinButtonClick);
        }
        ```
        </ProductWrapper>
        <ProductWrapper product="interactive-live-streaming">
        ``` cpp
        void UMyUserWidget::setupVideoSDKEngine() 
        {
            // Create an engine instance.
            agoraEngine = createAgoraRtcEngine();
            // Specify a context for the engine.
            RtcEngineContext context;
            context.appId = appId.c_str();
            context.eventHandler = this;
            // Select the live broadcasting profile for interactive live streaming.
            context.channelProfile = CHANNEL_PROFILE_TYPE::CHANNEL_PROFILE_LIVE_BROADCASTING;
            // Initialize the engine instance with the context.
            agoraEngine->initialize(context);
            // Enable the local audio capture to init the local video stream.
            agoraEngine->enableAudio();
            // Enable the local video capture to init the local video stream.
            agoraEngine->enableVideo();
            LeaveBtn->OnClicked.AddDynamic(this, &UMyUserWidget::OnLeaveButtonClick);
            JoinBtn->OnClicked.AddDynamic(this, &UMyUserWidget::OnJoinButtonClick);
            hostToggle->OnCheckStateChanged.AddDynamic(this, &UMyUserWidget::OnCheckboxChanged);
            audienceToggle->OnCheckStateChanged.AddDynamic(this, &UMyUserWidget::OnCheckboxChanged);
        }
        ```
        </ProductWrapper>

1. **Handle and respond to <Vg k="ENGINE"/> events**

    To register the callbacks, inherit the `UMyUserWidget` with the `IRtcEngineEventHandler` class. In `MyUserWidget.h`, add the following after `class AGORAIMPLEMENTATION_API UMyUserWidget : public UUserWidget`:
    
      ```cpp
      , public IRtcEngineEventHandler
      ```

    To implement the required callbacks in your <Vpl k = "CLIENT"/>, take the following steps:

        1. Override the definition of necessary callbacks. In `MyUserWidget.h`, add the following callbacks to `UMyUserWidget` after `void setupVideoSDKEngine();`:

            ```cpp
            // Occurs when a remote user joins the channel.
            void onUserJoined(uid_t uid, int elapsed) override;
            // Occurs when a local user joins the channel.
	        void onJoinChannelSuccess(const char* channel, uid_t uid, int elapsed) override;
            // Occurs when you leave the channel.
	        void onLeaveChannel(const RtcStats& stats) override;
            // Occurs when the remote user drops offline.
	        void onUserOffline(uid_t uid, USER_OFFLINE_REASON_TYPE reason) override;
            ```
        2. Add your logic to the callbacks you declared in `UMyUserWidget`:

           ```cpp
           void UMyUserWidget::onLeaveChannel(const agora::rtc::RtcStats& stats) 
           {
                AsyncTask(ENamedThreads::GameThread, [=]()
                {
                    UE_LOG(LogTemp, Warning, TEXT("UMyUserWidget::onLeaveChannel"));
                    // Clean up the local view when the local user leave the channel.
                    VideoCanvas videoCanvas;
                    videoCanvas.view = nullptr;
                    videoCanvas.uid = 0;
                    videoCanvas.sourceType = VIDEO_SOURCE_TYPE::VIDEO_SOURCE_CAMERA;
                    if (agoraEngine != nullptr)
                    {
                        agoraEngine->setupLocalVideo(videoCanvas);
                    }
                    isJoin = false;
                });
           }
           void UMyUserWidget::onJoinChannelSuccess(const char* channel, uid_t uid, int elapsed)
           {
                AsyncTask(ENamedThreads::GameThread, [=]()
                {
                    UE_LOG(LogTemp, Warning, TEXT("JoinChannelSuccess uid: %u"), uid);
                    isJoin = TRUE;
                });
           }
           ```

1. **Join a channel to start <Vpd k="PRODUCT" />**

    When the user clicks **Join**, you call the `OnJoinButtonClick()` method. This method securely connects the local user to a channel using the authentication token. In `MyUserWidget.cpp`, add the following before `setupVideoSDKEngine`:
    <ProductWrapper product="video-calling">
    ``` csharp
    void UMyUserWidget::OnJoinButtonClick() 
    {
        // Setup a video canvas to render the local video.
	    VideoCanvas videoCanvas;
	    videoCanvas.view = localView;
	    videoCanvas.uid = 0;
	    videoCanvas.sourceType = VIDEO_SOURCE_TYPE::VIDEO_SOURCE_CAMERA;
	    agoraEngine->setupLocalVideo(videoCanvas);
        // Set the user role to Host.
        agoraEngine->setClientRole(agora::rtc::CLIENT_ROLE_TYPE::CLIENT_ROLE_BROADCASTER);
        // Join the channel.
	    agoraEngine->joinChannel(token.c_str(), channelName.c_str(), "", 0);
        isJoin = true;
    }
    ```
    </ProductWrapper>
    <ProductWrapper product="interactive-live-streaming">
    ``` csharp
        void UMyUserWidget::OnJoinButtonClick() 
    {
        if(userRole == NULL)
        {
            UE_LOG(LogTemp, Warning, TEXT("Select a role to join the channel"));
            return;
        }
        // Setup a video canvas to render the local video.
	    VideoCanvas videoCanvas;
	    videoCanvas.view = localView;
	    videoCanvas.uid = 0;
	    videoCanvas.sourceType = VIDEO_SOURCE_TYPE::VIDEO_SOURCE_CAMERA;
	    agoraEngine->setupLocalVideo(videoCanvas);
        // Set the user role to Host.
        agoraEngine->setClientRole(agora::rtc::CLIENT_ROLE_TYPE::CLIENT_ROLE_BROADCASTER);
        // Join the channel.
	    agoraEngine->joinChannel(token.c_str(), channelName.c_str(), "", 0);
        isJoin = true;
    }
    ```
    </ProductWrapper>

1. **View the remote user when they join a channel**

    When a remote user joins the channel, <Vg k="COMPANY"/> fires `OnUserJoined`. To catch this callback and start remote video, in `MyUserWidget.cpp`, add the following code after `OnJoinChannelSuccess`:
    <ProductWrapper product="video-calling">
    ``` csharp
    void UMyUserWidget::onUserJoined(uid_t uid, int elapsed) 
    {
        AsyncTask(ENamedThreads::GameThread, [=]()
        {
            UE_LOG(LogTemp, Warning, TEXT("UMyUserWidget::onUserJoined  uid: %u"), uid);
            // Setup a canvas to render the remote video.
            VideoCanvas videoCanvas;
            videoCanvas.view = remoteView;
            videoCanvas.uid = uid;
            remoteUId = uid;
            videoCanvas.sourceType = VIDEO_SOURCE_TYPE::VIDEO_SOURCE_REMOTE;
            RtcConnection connection;
            connection.channelId = channelName.c_str();
            // Render the remote video.
            ((IRtcEngineEx*)agoraEngine)->setupRemoteVideoEx(videoCanvas, connection);
            });
        }
    }
    ```
    </ProductWrapper>
    <ProductWrapper product="interactive-live-streaming">

    ``` csharp
    public override void OnUserJoined(RtcConnection connection, uint uid, int elapsed)
    {
        // Setup remote view.
        _videoSample.RemoteView.SetForUser(uid, connection.channelId, VIDEO_SOURCE_TYPE.VIDEO_SOURCE_REMOTE);
        if(_videoSample.clientRole == "Audience")
        {
            // Start rendering remote video.
            _videoSample.RemoteView.SetEnable(true);
        }
        _videoSample.remoteUid = uid;
    }
    ```
    </ProductWrapper>

<ProductWrapper product="interactive-live-streaming">
8. **Manage the user role**

    1. Change the `LocalView` and `RemoteView` visibility.
    When the user selects and un-selects the host or the audience check box, the `OnCheckStateChanged` event is fired. The <Vpl k = "CLIENT"/> catches the event and invoke `OnHostCheckboxChanged` or `OnAudienceCheckboxChanged` to change the `localView` and `remoteView` visibility. To implement this workflow, take the following steps:

        1. Setup callback functions for the host and audience check boxes. In `MyUserWidget.cpp`, add the following code at the end of `setupVideoSDKEngine`:

            ```cpp
            // When the host check box state changes, you call OnHostCheckboxChanged.
           	hostToggle->OnCheckStateChanged.AddDynamic(this, &UMyUserWidget::OnHostCheckboxChanged);
            // When the audience check box state changes, you call OnAudienceCheckboxChanged.
            audienceToggle->OnCheckStateChanged.AddDynamic(this, &UMyUserWidget::OnAudienceCheckboxChanged);
            ``` 

        2. Add the `remoteView` and `localView` visibility to `OnAudienceCheckboxChanged` and `OnHostCheckboxChanged`. In `MyUserWidget.cpp`, add the following before `setupVideoSDKEngine`:

            ```cpp
            void UMyUserWidget::OnHostCheckboxChanged(bool bIsChecked)
            {
                UE_LOG(LogTemp, Warning, TEXT("Role changed"));
                if (bIsChecked)
                {
                    if (isJoin == true && remoteUId != NULL)
                    {
                        agoraEngine->muteRemoteVideoStream(remoteUId, true);
                    }
                    userRole = "Host";
                    agoraEngine->enableLocalVideo(true);
                    agoraEngine->setClientRole(CLIENT_ROLE_TYPE::CLIENT_ROLE_BROADCASTER);
                    audienceToggle->SetCheckedState(ECheckBoxState::Unchecked);
                    UE_LOG(LogTemp, Warning, TEXT("User role changed to host"));
                }
            }
            void UMyUserWidget::OnAudienceCheckboxChanged(bool bIsChecked)
            {
                if (bIsChecked)
                {
                    if (isJoin == true && remoteUId != NULL)
                    {
                        agoraEngine->muteRemoteVideoStream(remoteUId, false);
                    }
                    userRole = "Audience";
                    agoraEngine->enableLocalVideo(true);
                    agoraEngine->setClientRole(CLIENT_ROLE_TYPE::CLIENT_ROLE_BROADCASTER);
                    hostToggle->SetCheckedState(ECheckBoxState::Unchecked);
                    UE_LOG(LogTemp, Warning, TEXT("User role changed to Audience"));
                }
            }
            ```
</ProductWrapper>
8. **Stop the remote video when a remote user leaves the channel**

    When a remote user leaves the channel or drops offline, <Vg k="COMPANY"/>  fires `OnUserOffline`. To catch this callback and stop remote video, in `MyUserWidget.cpp`, add the following callback method after `OnJoinChannelSuccess`:
    <ProductWrapper product="video-calling">
    ``` csharp
    // This callback is triggered when a remote user leaves the channel or drops offline.
    void UMyUserWidget::onUserOffline(uid_t uid, agora::rtc::USER_OFFLINE_REASON_TYPE reason) 
    {
        AsyncTask(ENamedThreads::GameThread, [=]()
        {
            UE_LOG(LogTemp, Warning, TEXT("UMyUserWidget::onUserOffline  uid: %u"), uid);
            // Clean up the remote video view.
            VideoCanvas videoCanvas;
            videoCanvas.view = nullptr;
            videoCanvas.uid = uid;
            videoCanvas.sourceType = VIDEO_SOURCE_TYPE::VIDEO_SOURCE_REMOTE;
            RtcConnection connection;
            connection.channelId = channelName.c_str();
            if (agoraEngine != nullptr)
            {
                ((IRtcEngineEx*)agoraEngine)->setupRemoteVideoEx(videoCanvas, connection);
            }
        });
    }
    ```
    </ProductWrapper>

    <ProductWrapper product="interactive-live-streaming">
    ``` csharp
    // This callback is triggered when a remote user leaves the channel or drops offline.
    void UMyUserWidget::onUserOffline(uid_t uid, agora::rtc::USER_OFFLINE_REASON_TYPE reason) 
    {
        AsyncTask(ENamedThreads::GameThread, [=]()
        {
            UE_LOG(LogTemp, Warning, TEXT("UMyUserWidget::onUserOffline  uid: %u"), uid);
            // Clean up the remote video view.
            VideoCanvas videoCanvas;
            videoCanvas.view = nullptr;
            videoCanvas.uid = uid;
            videoCanvas.sourceType = VIDEO_SOURCE_TYPE::VIDEO_SOURCE_REMOTE;
            RtcConnection connection;
            connection.channelId = channelName.c_str();
            if (agoraEngine != nullptr)
            {
                ((IRtcEngineEx*)agoraEngine)->setupRemoteVideoEx(videoCanvas, connection);
            }
            if(userRole == "Host")
			{
				agoraEngine->muteRemoteVideoStream(remoteUId, true);
			}
        });
    }
    ```
    </ProductWrapper>

1. **Leave the channel when a user ends the call**

    When a user clicks **Leave**, you call `OnLeaveButtonClick()` to exit the channel. In `MyUserWidget.cpp`, add the following before `onUserJoined`:
    ``` csharp
    void UMyUserWidget::OnLeaveButtonClick() 
    {
        UE_LOG(LogTemp, Warning, TEXT("UMyUserWidget:: OnLeaveButtonClick ======"));
        agoraEngine->leaveChannel();
        remoteUId = NULL;
        isJoin = false;
    }
    ```

### Start and stop your <Vpl k="CLIENT" />

In this implementation, you initiate and remove  <Vg k="ENGINE" /> when the app opens and closes. The local user joins and leaves a channel using the same  <Vg k="ENGINE" /> instance. In order to send video and audio streams to  <Vg k="COMPANY" />, you need to ensure that the local user gives permission to access the camera and microphone on the local device. To implement this functionality:

1. **Check that the <Vpl k="CLIENT" /> has the correct permissions to start**

    For Android, call `CheckAndroidPermission` and check that the permissions are granted. To execute `CheckAndroidPermission` at startup, call `CheckAndroidPermission` in the constructor of the `UMyUserWidget` class. To implement this workflow, take the following steps:

    1. Implement a constructor in `UMyUserWidget`. In `MyUserWidget.h`, add the following before `setupVideoSDKEngine`:

        ```cpp
        void NativeConstruct();
        ```

    2. Call `CheckAndroidPermission` in the constructor. In `MyUserWidget.cpp`, add the following code before `void setupVideoSDKEngine();`:

        ```cpp
        void UMyUserWidget::NativeConstruct()
        {
            CheckAndroidPermission();
        }
        ```
    3. After you check permissions, you call `setupVideoSDKEngine` to create an engine instance. In `MyUserWidget.cpp`, add the following at the end of `NativeConstruct`:

        ```cpp
        setupVideoSDKEngine();
        ```

3. **Clean up the resources used by your <Vpl k="CLIENT" />**

    When a user closes the <Vpl k="CLIENT" />, use `NativeDestruct` to clean up the resources you created in `setupVideoSDKEngine`. To implement this workflow, take the following steps:

    1. Implement a destructor for the `UMyUserWidget` class. In `MyUserWidget.h`, add the following before `void NativeConstruct();`:

        ```cpp
        void NativeDestruct();
        ```

    2. Add the resource clean up logic to `NativeDestruct`. In `MyUserWidget.cpp`, add the following before `NativeConstruct`:

        ```cpp
        void UMyUserWidget::NativeDestruct() 
        {
            Super::NativeDestruct();
            UE_LOG(LogTemp, Warning, TEXT("UMyUserWidget::NativeDestruct"));
            if (agoraEngine != nullptr)
            {
                agoraEngine->unregisterEventHandler(this);
                agoraEngine->release();
                delete agoraEngine;
                agoraEngine = nullptr;
            }
        }
        ```

</PlatformWrapper>