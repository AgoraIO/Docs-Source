<PlatformWrapper platform="ios">
        
Since June 2023, Agora has released several versions of the RTM `2.x` series (referred to as `2.x`) in response to market and industry demands. This series introduces innovative improvements in functionality, performance, and user experience:

- **Expanded Functionality**: The `2.x` version introduces functionality modules such as `Channel`, `Message`, `Topic`, `Presence`, `Storage`, and `Lock`, covering a broader range of business scenarios. This allows you to focus more on your business innovations.

- **Performance Enhancement**: The new version involves a backend architecture overhaul, optimizing network connections to further enhance performance. It provides real-time network access capabilities with long durations, low latency, high reliability, high concurrency, and easy scalability, alleviating concerns about business quality.

- **User Experience Optimization**: The API interfaces have been redesigned and simplified. Documentation, including user guides and API references, has been optimized, offering more comprehensive sample programs. This supports developers in learning and using the SDK at a low cost, enabling rapid integration and improving development efficiency.

This article provides the main differences and relevant example codes between RTM `1.x` and `2.x` to assist users in smoothly migrating from `1.x` to `2.x`.

## Activate Signaling

To activate Signaling `2.x`, take the following steps:

1. Log in to [<Vg k="CONSOLE"/>](https://console.agora.io/v2)
1. Create a new <Vg k="COMPANY"/> project or choose an existing project from the project list.
1. Select the project on the [Project Management](https://console.agora.io/v2/project-management) page and click the pencil icon to configure it.
1. Go to **All features > Signaling > Basic information** and select a data center in the dropdown.
1. Go to **Subscriptions > Signaling** and subscribe to a plan.
1. Copy the  App ID for your project for use in your code.

## Integration the SDK

The SDK package names and integration methods for `2.x` and `1.x` remain unchanged, supporting both CDN and Cocoapods integration methods. The `Podfile` content for Cocoapods integration is as follows:

```objc
platform :ios, '9.0'
target 'Your App' do
  # Replace x.y.z with the specific SDK version, such as 2.1.9
  pod 'AgoraRtm_iOS', 'x.y.z'
end
```

## Initialize RTM Client instance

Compared to `1.x`, `2.x` has made significant adjustments to the initialization parameters, adding many new features such as end-to-end encryption, cloud proxy, etc. For details, refer to the [API Reference](../reference/api). Additionally, `2.x` has enriched the error information for API calls. You can retrieve error codes, reasons, and API operation names through the `AgoraRtmErrorInfo` data structure, making it easier to troubleshoot issues. Combining with [Error Codes](../reference/api#troubleshooting) documentation, you can quickly find solutions.

- `1.x` example code:

   ```objc
   self.appID = @"your_appid";
   _kit = [[AgoraRtmKit alloc] initWithAppId:self.appID delegate:self];
   ```

- `2.x` example code:

   ```objc
   AgoraRtmClientConfig* rtm_cfg = [[AgoraRtmClientConfig alloc] initWithAppId:@"your_appid" userId:@"your_userid"];
   NSError* initError = nil;
   AgoraRtmClientKit* rtm = [[AgoraRtmClientKit alloc] initWithConfig:rtm_cfg delegate:handler error:&initError];
   ```


## Login to Signaling

The login method for `2.x` differs from `1.x`, as shown below:

- `1.x` example code:
    ```objc
    self.uid = self.UserIDTextField.text;
    self.token = @"your_token";
    [_kit loginByToken:(self.token) user:(self.uid) completion:^(AgoraRtmLoginErrorCode errorCode) {
        if (errorCode != AgoraRtmLoginErrorOk){
            self.text = [NSString stringWithFormat:@"Login failed for user %@. Code: %ld",self.uid, (long)errorCode];
            NSLog(@"%@", self.text);
        }
        else {
            NSLog(@"%@", self.text);
            self.text = [NSString stringWithFormat:@"Login successful for user %@. Code: %ld",self.uid, (long)errorCode];
        }
    }];
    ```

- `2.x` example code:
    ```objc
    [rtm loginByToken:@"token" completion:^(AgoraRtmCommonResponse * _Nullable response, AgoraRtmErrorInfo * _Nullable errorInfo) {
        if (errorInfo == nil) {
            NSLog(@"Login success!!");
        } else {
            NSLog(@"Login failed, errorCode %d, reason %@", errorInfo.errorCode, errorInfo.reason);
        }
    }];
    ```
## Event notifications

Compared to `1.x`, `2.x` has redesigned the system's event notification method and API interface, providing more detailed categorization and aggregation of event notification types, as well as optimizing the payload data structure.

There are 7 event notification types in `2.x`:

| Event Type                     | Description                                                                                     |
|:-----------------------------:| ----------------------------------------------------------------------------------------------- |
| `didReceiveMessageEvent`               | Message Event Notification: Receive notifications for all message events in subscribed Message Channels and Topics.                                     |
| `didReceivePresenceEvent`              | User Presence and Custom State Change Event Notification (Presence Event Notification): Receive notifications for all Presence events in subscribed Message Channels and joined Stream Channels.                                  |
| `didReceiveTopicEvent`                 | Topic Change Event Notification: Receive notifications for all Topic change events in joined Stream Channels.                                          |
| `didReceiveStorageEvent`               | Channel and User Property Event Notification: Receive notifications for all Channel Metadata events in subscribed Message Channels and joined Stream Channels, and User Metadata events for subscribed users.  |
| `didReceiveLockEvent`                  | Lock Change Event Notification: Receive notifications for all Lock events in subscribed Message Channels and joined Stream Channels.                        |
| `connectionChangedToState`           | Network Connection State Change Event Notification: Receive notifications for changes in client network connection status.                               |
| `tokenPrivilegeWillExpire`      | Receive notifications for client Token about to expire events.                                                   |

For more information on event notifications and payload data structures, see [Event listeners](../reference/api#event-listeners).

Taking the example of listening to channel messages `didReceiveMessageEvent`, the code examples are as follows:

- For `1.x`:
    ```objc
    @interface ChannelListener ()<AgoraRtmChannelDelegate>
    @end

    @implementation ChannelListener
    - (void)channel:(AgoraRtmChannel *)channel messageReceived:(AgoraRtmMessage *)message fromMember:(AgoraRtmMember *)member
        {
            self.text = [NSString stringWithFormat:@"Message received in channel: %@ from user: %@ content: %@",member.channelId, member.userId, message.text];
            [self AddMsgToRecord:(self.text)];
        }
    @end
    
    ChannelListener* handler =  [[ChannelListener alloc] init];
    channel = [rtm createChannelWithId:self.channelID delegate:handler];
    ```
- For `2.x`:
    ```objc
    @interface RtmListener : NSObject <AgoraRtmClientDelegate>
    @end

    @implementation RtmListener
        // Implementation of the Agora Real-Time Messaging (RTM) client delegate method
        -(void) rtmKit:(AgoraRtmClientKit *)rtmKit didReceiveMessageEvent:(AgoraRtmMessageEvent *)event {}
    @end

    // Approach 1: Adding event listener when initializing the RTM client instance using the initWithAppId method
    AgoraRtmClientConfig* rtm_cfg = [[AgoraRtmClientConfig alloc] initWithAppId:@"your_appid" userId:@"your_userid"];

    RtmListener* handler =  [[RtmListener alloc] init];
    NSError* initError = nil;
    AgoraRtmClientKit* rtm = [[AgoraRtmClientKit alloc] initWithConfig:rtm_cfg delegate:handler error:&initError];

    // Approach 2: Adding event listener at any time during the app's lifecycle
    [rtm addDelegate:handler];
    ```

From the above example codes, the significant differences are:

- In `1.x`, channel message event notification is bound to specific `channel` instances. Users need to create a `channel` instance by calling the `createChannelWithId:delegate` method, then register the `messageReceived` callback to handle events. The SDK notifies the handler through this callback when a message is received, and it needs to be bound multiple times for multiple channels. In `2.x`, message event notification is bound to the client instance globally. When creating and initializing the `AgoraRtmClientKit` instance, register the event listener instance once, and it can listen to all subscribed channels or topics.

- The payload data structure for `1.x`'s message event notification contains relatively fewer pieces of information, while `2.x`'s payload data structure contains more information, helping you better implement your business.

## Channel messages

In version `1.x`, the steps for sending channel messages are as follows:

1. Create a channel instance.

2. Join the channel.

3. Send channel messages.

This design has a drawback: you cannot send messages without receiving them. Because sending messages and receiving messages are not decoupled. `2.x` has adopted a new design based on Pub/Sub, decoupling the sending and receiving of channel messages: you can send messages to a specific channel without joining it, and you only need to subscribe to the specified channel to receive messages, and the two operations do not interfere with each other.

- For `1.x`:
    ```objc
    // Create an RTM channel
    _channel = [_kit createChannelWithId:self.channelID delegate:self];

    // Join the RTM channel
    [_channel joinWithCompletion:^(AgoraRtmJoinChannelErrorCode errorCode) {
	    if (errorCode == AgoraRtmJoinChannelErrorOk) {
		    self.text = [NSString stringWithFormat:@"Successfully joined channel %@. Code: %ld", self.channelID, (long)errorCode];
		    NSLog(@"%@", self.text);
	    } else {
		    self.text = [NSString stringWithFormat:@"Failed to join channel %@. Code: %ld", self.channelID, (long)errorCode];
		    NSLog(@"%@", self.text);
	    }
    }];

    // Send a channel message
    [_channel sendMessage:[[AgoraRtmMessage alloc] initWithText:self.channelMsg] sendMessageOptions:self.options completion:^(AgoraRtmSendChannelMessageErrorCode errorCode) {
	    if (errorCode == AgoraRtmSendChannelMessageErrorOk) {
		    self.text = [NSString stringWithFormat:@"Message sent to channel %@: %@", self.channelID, self.channelMsg];
	    } else {
		    self.text = [NSString stringWithFormat:@"Message failed to send to channel %@: %@ ErrorCode: %ld", self.channelID, self.channelMsg, (long)errorCode];
	    }
    }];
    ```
- For `2.x`:

    ```objc
    // Send a channel message
    NSString* message = @"Hello Agora!";
    NSString* channel = @"your_channel";
    [rtm publish:channel message:message option:nil completion:^(AgoraRtmCommonResponse * _Nullable response, AgoraRtmErrorInfo * _Nullable errorInfo) {
        if (errorInfo == nil) {
            NSLog(@"Publish success!!");
        } else {
            NSLog(@"Publish failed, errorCode %d, reason %@", errorInfo.errorCode, errorInfo.reason);
        }
    }];

    // Subscribe to a channel
    AgoraRtmSubscribeOptions* opt = [[AgoraRtmSubscribeOptions alloc] init];
    opt.features = AgoraRtmSubscribeChannelFeatureMessage | AgoraRtmSubscribeChannelFeaturePresence;
    [rtm subscribeWithChannel:@"your_channel" option:opt completion:^(AgoraRtmCommonResponse * _Nullable response, AgoraRtmErrorInfo * _Nullable errorInfo) {
        if (errorInfo == nil) {
            NSLog(@"Subscribe success!!");
        } else {
            NSLog(@"Subscribe failed, errorCode %d, reason %@", errorInfo.errorCode, errorInfo.reason);
        }
    }];
    ```


## Peer-to-Peer messaging

The point-to-point message API in `1.x` is used to send messages to specific users. For example, if you want to send a message to a user with the ID `Tony`, you can implement it as follows:
```objc
// `1.x`
self.peerMsg = self.PeerMsgTextField.text;
self.peerID = self.PeerIDTextField.text;

[_kit sendMessage:[[AgoraRtmMessage alloc] initWithText:self.peerMsg] toPeer:self.peerID completion:^(AgoraRtmSendPeerMessageErrorCode errorCode) {
    if (errorCode == AgoraRtmSendPeerMessageErrorOk)
    {
        self.text = [NSString stringWithFormat:@"Message sent from user: %@ to user: %@ content: %@", self.uid, self.peerID, self.peerMsg];
    }
    else
    {
        self.text = [NSString stringWithFormat:@"Message failed to send from user: %@ to user: %@ content: %@ Error: %ld", self.uid, self.peerID, self.peerMsg, (long)errorCode];
    }

}];
```

The reason for designing this interface in `1.x` is to meet the requirements of end-to-end message transmission, i.e., User A only wants to give a specific message to User B, and User B only wants to receive this message without paying attention to other events. The channel mechanism in `1.x` is designed based on the Room mode, and this design cannot decouple the sending and receiving of messages, so it cannot meet the requirements of the above scenario.

`2.x` has redesigned the distribution mode of channel messages, adopting the Pub/Sub mode, decoupling the sending and receiving of messages. On this basis, point-to-point messages can be uniformly implemented using channel messages. The implementation is as follows:

1. After each user initializes, subscribe to a private channel named `inbox_` + `UserID`, hereinafter referred to as the inbox. This channel can only be subscribed to by oneself, and others cannot subscribe.

2. When you need to send a point-to-point message to a user, simply send the message to that user's inbox.

Example code:
```objc
// `2.x`
// 1. Subscribe to your own inbox
[_kit subscribeWithChannel:"inbox_Tony" option:nil completion:^(AgoraRtmCommonResponse * _Nullable response, AgoraRtmErrorInfo * _Nullable errorInfo) {
    if(errorInfo == nil) {
        self.text = [NSString stringWithFormat:@"Successfully subscribe channel %@",self.channelID];
        NSLog(@"%@", self.text);
    } else {
        self.text = [NSString stringWithFormat:@"Failed to subscribe channel %@ Code: %ld",self.channelID, (long)errorInfo.errorCode];
        NSLog(@"%@", self.text);
    }
}];

// Message content
NSString* payload = @"{
    type: "PrivateMessage",
    message: "This is a message",
    sender: "Tony"
}";

// 2. Send a message to Lily
[rtm publish:"inbox_Lily" message:message option:nil completion:^(AgoraRtmCommonResponse * _Nullable response, AgoraRtmErrorInfo * _Nullable errorInfo) {
    if (errorInfo == nil) {
        NSLog(@"publish success!!");
    } else {
        NSLog(@"publish failed, errorCode %d, reason %@", errorInfo.errorCode, errorInfo.reason);
    }
}];
```

<Admonition type="info" title="Information">
To receive messages, you also need to implement the `didReceiveMessageEvent` event listener function.
</Admonition>

## Images and File Messages

Starting from version 1.5.0, for compliance with user data and privacy protection, as well as cost optimization, RTM no longer directly supports the transmission of image and file messages. The relevant APIs have also been deprecated. You can combine RTM with third-party object storage services (such as Amazon S3 or Alibaba Cloud OSS) to build image and file messaging functionality. This approach provides an excellent real-time message transmission experience while allowing for more flexible technical solutions, such as implementing CDN static resource acceleration, image text auditing, and other business requirements. The following example code shows how to use `2.x` and Amazon S3 object storage service to build and send image and file messages:

```objc
// After successful file upload, customize the RTM file message payload
NSString* imageMessagePayload = @"{
    // File type, the receiver can parse the message packet structure based on this field
    type:'File',
    // Your bucket name on Amazon S3, the receiver needs this field to download the file
    bucket:uploadParams.Bucket,
    // The key under which the file is stored on Amazon S3, the receiver needs this field to download the file
    key:uploadParams.Key,
    // File type
    contentType:uploadParams.ContentType,
    // File URL address
    url:data.Location,
    // Sender's user ID
    sender:userId
    }";

// Use RTM `2.x` to send file message payload
AgoraRtmPublishOptions* option = [[AgoraRtmPublishOptions alloc] init];
option.customType = @"File";

[rtm publish:channelName message:imageMessagePayload option:option completion:^(AgoraRtmCommonResponse * _Nullable response, AgoraRtmErrorInfo * _Nullable errorInfo) {
    if (errorInfo == nil) {
        NSLog(@"Publish success!!");
    } else {
        NSLog(@"Publish failed, errorCode %d, reason %@", errorInfo.errorCode, errorInfo.reason);
    }
}];
```
<Admonition type="info" title="Information">
When using Amazon S3 for static file storage, you need to go to the Amazon S3 console and set the correct user permissions and access policies. See [Access Control Best Practices](https://docs.aws.amazon.com/zh_en/AmazonS3/latest/userguide/access-control-best-practices.html) for details.
</Admonition>

## User presence and custom status

In `1.x`, you could subscribe or query the online status of multiple users, check channel statistics, or retrieve a list of online members in a channel. `2.x` not only retains these capabilities but also upgrades and expands on them, introducing the Presence module. The Presence module enables monitoring of user online and offline events, as well as temporary user state changes. You can obtain real-time information on:

- Users joining or leaving a specified channel
- Customized temporary user states and their changes
- Querying which channels a specific user has joined or subscribed to
- Querying which users have joined a specific channel along with their temporary user state data

You can use the `whoNow` method to real-time query the online user count, the list of online users, and their temporary states in a specified channel.

```objc
// `2.x`
AgoraRtmPresenceOptions* presence_opt = [[AgoraRtmPresenceOptions alloc] init];
presence_opt.includeState = false;
presence_opt.includeUserId = false;

[[rtm getPresence] whoNow:@"your_channel" channelType:AgoraRtmChannelTypeMessage options:presence_opt completion:^(AgoraRtmWhoNowResponse * _Nullable response, AgoraRtmErrorInfo * _Nullable errorInfo) {
    if (errorInfo == nil) {
        NSLog(@"whoNow success!!");
        int user_count = response.totalOccupancy;
    } else {
        NSLog(@"whoNow failed, errorCode %d, reason %@", errorInfo.errorCode, errorInfo.reason);
    }
}];
```
You can use the `whereNow` method to obtain the list of channels in which a specified user is currently present.

```objc
// `2.x`
[[rtm getPresence] whereNow:@"userId" completion:^(AgoraRtmWhereNowResponse * _Nullable response, AgoraRtmErrorInfo * _Nullable errorInfo) {
    if (errorInfo == nil) {
        NSLog(@"whereNow success!!");
        int channel_count = response.totalChannel;
        NSArray<AgoraRtmChannelInfo *> * channels = response.channels;
    } else {
        NSLog(@"whereNow failed, errorCode %d, reason %@", errorInfo.errorCode, errorInfo.reason);

    }
}];
```

To meet the setting requirements for user states in various business scenarios, `2.x` provides the capability to set temporary user states. You can use the `setState` method to customize temporary user states. Users can add custom states such as scores, gaming status, location, mood, or linking status.

```objc
// `2.x`
AgoraRtmStateItem* state1 = [[AgoraRtmStateItem alloc] init];
state1.key = @"key1";
state1.value = @"value1";
AgoraRtmStateItem* state2 = [[AgoraRtmStateItem alloc] init];
state2.key = @"key2";
state2.value = @"value2";
NSArray<AgoraRtmStateItem*>* states = @[state1, state2];

[[rtm getPresence] setState:@"your_channel" channelType:AgoraRtmChannelTypeMessage items:states completion:^(AgoraRtmCommonResponse * _Nullable response, AgoraRtmErrorInfo * _Nullable errorInfo) {
    if (errorInfo == nil) {
        NSLog(@"setState success!!");
    } else {
        NSLog(@"setState failed, errorCode %d, reason %@", errorInfo.errorCode, errorInfo.reason);
    }
}];
```

You can also use the `getState` method at any time to retrieve the online status of a user, or use the `removeState` method to delete a user's status. After the temporary user state changes, the RTM server will trigger the `AgoraRtmPresenceEventTypeRemoteStateChanged` type of `didReceivePresenceEvent` event notification. For specific usage, refer to [Temporary User State](../reference/api#presencesetstatepropsag_platform).

In `2.x`, real-time monitoring of user join, leave, timeout, or temporary status change notifications in a channel will be more convenient. You just need to follow these steps:

1. Implement a Presence event listener.

2. When joining a channel, enable the `withPresence` switch.

```objc
// `2.x`
// 1. Implement Presence event listener
@interface RtmListener : NSObject <AgoraRtmClientDelegate>

@end

@implementation RtmListener
// Presence event notification
-(void) rtmKit:(AgoraRtmClientKit *)rtmKit didReceivePresenceEvent:(AgoraRtmPresenceEvent *)event {
    // Implementation code
}
@end

// 2. When joining a channel, enable the withPresence switch
AgoraRtmSubscribeOptions* option = [[AgoraRtmSubscribeOptions alloc] init];
option.features = AgoraRtmSubscribeChannelFeaturePresence;
[rtm subscribeWithChannel:@"you_channel" option:opt completion:^(AgoraRtmCommonResponse * _Nullable response, AgoraRtmErrorInfo * _Nullable errorInfo) {
    if (errorInfo == nil) {
        NSLog(@"subscribe success!!");
    } else {
        NSLog(@"subscribe failed, errorCode %d, reason %@", errorInfo.errorCode, errorInfo.reason);
    }
}];
```
`2.x` introduces a completely new design for real-time notifications, adopting two modes to notify subscribed users of Presence events in channels: **Real-time Notification Mode (Announce)** and **Interval Notification Mode**. You can determine the conditions for switching between these two modes by setting the **Announce Max** size in the project settings on the console. The Interval Notification Mode helps prevent excessive event noise in channels with a large number of online users; for more details, refer to [Event Notification Modes](../reference/api#enumvpresencetypepropsag_platform).

## User metadata and channel metadata

Building upon the functionality of user and channel properties in `1.x`, `2.x` introduces capabilities such as version control and lock control. It also optimizes the API interface to make the usage of these features simpler. In `2.x`, user properties and channel properties are placed under the Storage module. Taking setting channel properties as an example, the sample code is as follows:

```objc
// `2.x`
// Create Metadata
AgoraRtmMetadata* metadata = [[rtm getStorage] createMetadata];

// Set Metadata Items
AgoraRtmMetadataItem* apple = [[AgoraRtmMetadataItem alloc] init];
apple.key = @"Apple";
apple.value = @"100";
apple.revision = 174298200;
AgoraRtmMetadataItem* banana = [[AgoraRtmMetadataItem alloc] init];
banana.key = @"Banana";
banana.value = @"200";
banana.revision = 174298100;
[metadata setMetadataItem:apple];
[metadata setMetadataItem:banana];
// Set Major Revision
[metadata setMajorRevision:174298270]

// Record Timestamp and User ID when setting Metadata Items
AgoraRtmMetadataOptions* metadata_opt = [[AgoraRtmMetadataOptions alloc] init];
metadata_opt.recordUserId = true;
metadata_opt.recordTs = true;

[[rtm getStorage] setChannelMetadata:@"channel_name" channelType:AgoraRtmChannelTypeMessage data:metadata options:metadata_opt lock:@"lockName" completion:^(AgoraRtmCommonResponse * _Nullable response, AgoraRtmErrorInfo * _Nullable errorInfo) {
    if (errorInfo == nil) {
        NSLog(@"setChannelMetadata success!!");
    } else {
        NSLog(@"setChannelMetadata failed, errorCode %d, reason %@", errorInfo.errorCode, errorInfo.reason);
    }
}];
```
For details on how to get, update, delete channel and user properties, and how to use CAS control, lock control, etc., see [Storage](../develop/storage).

In `2.x`, channel and user properties are distributed to users through events of type `didReceiveStorageEvent`. The steps to listen for   `didReceiveStorageEvent` events are as follows:

1. Implement the Storage event listener.

2. When joining a channel, enable the `withMetadata` switch.

```objc
// `2.x`
// 1. Implement the Storage event listener
@interface RtmListener : NSObject <AgoraRtmClientDelegate>
@end

@implementation RtmListener
// Storage event notification
-(void) rtmKit:(AgoraRtmClientKit *)rtmKit didReceiveStorageEvent:(AgoraRtmStorageEvent *)event {
    // Implementation code
}
@end

// 2. When joining a channel, add the Metadata feature
AgoraRtmSubscribeOptions* option = [[AgoraRtmSubscribeOptions alloc] init];
option.features = AgoraRtmSubscribeChannelFeatureMetadata;
[rtm subscribeWithChannel:@"your_channel" option:option completion:^(AgoraRtmCommonResponse * _Nullable response, AgoraRtmErrorInfo * _Nullable errorInfo) {
    if (errorInfo == nil) {
        NSLog(@"Subscribe success!!");
    } else {
        NSLog(@"Subscribe failed, errorCode %d, reason %@", errorInfo.errorCode, errorInfo.reason);
    }
}];
```
## Restrict access area

RTM supports the access region restriction feature to comply with the laws and regulations of different countries or regions. After enabling the access region restriction feature, regardless of where users are using your app, the SDK will only access Agora servers in the specified region. The implementation of access region restriction in `2.x` differs from `1.x`.

- Example code for `1.x`:

    ```objc
    AgoraRtmServiceContext* context = [[AgoraRtmServiceContext alloc] init];
    context.areaCode = AgoraAreaCodeGLOB;
    [AgoraRtmKit setRtmServiceContext:context];
    ```

- Example code for `2.x`:
    ```objc 
    AgoraRtmClientConfig* rtm_config = [[AgoraRtmClientConfig alloc] initWithAppId:_appID userId:_uid];
    rtm_config.areaCode = AgoraRtmAreaCodeGLOB;
    NSError* initError = nil;
    AgoraRtmClientKit* rtm = [[AgoraRtmClientKit alloc] initWithConfig:rtm_config delegate:self error:&initError];
    ```

## Other new features

In addition to the enhancements presented in this document, Signaling `2.x` introduces an array of additional features. Choose and implement features that fit the needs of your project. The following table outlines key new features of Signaling `2.x`:

| Feature          | Function                                          | API Interface                                                                                          |
|:-----------------:|:-------------------------------------------------:|:-------------------------------------------------------------------------------------------------------:|
| **Setup**         | Create Instance                                   | `initWithConfig:delegate:error`                                                                        |
|                   | Destroy Instance                                  | `[rtm destroy]`                                                                                        |
|                   | Token Configuration                               | `AgoraRtmClientConfig` with `token` parameter                                                          |
|                   | End-to-End Encryption                             | `AgoraRtmClientConfig` with `encryptionConfig` parameter                                               |
|                   | Presence Timeout Setting                          | `AgoraRtmClientConfig` with `presenceTimeout` parameter                                               |
|                   | Log Level Setting                                  | `AgoraRtmLogConfig` with `level` parameter                                                             |
|                   | Proxy Configuration                               | `AgoraRtmProxyConfig` with `proxyType`, `server`, `port`, `account`, `password` parameters             |
|                   | Event Listener                                    | - `[rtm addDelegate:delegate]`<br/> - `[rtm removeDelegate:delegate]`                                  |
|                   | Login Service                                     | `[rtm loginByToken:completion:]`                                                                      |
|                   | Logout Service                                    | `[rtm logout:completion]`                                                                              |
|                   | Unsubscribe Channel                               | `[rtm unsubscribeWithChannel:completion]`                                                             |
|                   | Create Stream Channel                             | `[rtm createStreamChannel:error]`                                                                     |
|                   | Join Stream Channel                               | `[streamChannel joinWithOption:completion]`                                                           |
|                   | Leave Stream Channel                              | `[streamChannel leave]`                                                                               |
| **Channel**       | Subscribe Channel                                 | `[rtm subscribeWithChannel:option:completion]`                                                         |
|                   | Unsubscribe Channel                               | `[rtm unsubscribeWithChannel:completion]`                                                             |
|                   | Create Stream Channel                             | `[rtm createStreamChannel:error]`                                                                     |
|                   | Join Stream Channel                               | `[streamChannel joinWithOption:completion]`                                                           |
|                   | Leave Stream Channel                              | `[streamChannel leave]`                                                                               |
|                   | Destroy Stream Channel                            | `[streamChannel destroy]`                                                                             |
| **Topic**         | Join Topic                                        | `[streamChannel joinTopic:withOption:completion]`                                                      |
|                   | Publish Topic Message                             | `[streamChannel publishTopicMessage:data:option:completion]`                                          |
|                   | Leave Topic                                       | `[streamChannel leaveTopic:completion]`                                                               |
|                   | Subscribe Topic                                   | `[streamChannel subscribeTopic:withOption:completion]`                                                 |
|                   | Unsubscribe Topic                                 | `[streamChannel unsubscribeTopic:withOption:completion]`                                               |
| **Message**       | Send Message                                      | `[rtm publish:message:option:completion]`                                                             |
| **Presence**      | Query Channel's Online Users                      | `[[rtm getPresence] whoNow:channelType:options:completion]`                                            |
|                   | Query User's Channel                              | `[[rtm getPresence] whereNow:completion]`                                                             |
|                   | Set User's Temporary State                        | `[[rtm getPresence] setState:channelType:items:completion]`                                           |
|                   | Query User Temporary State                        | `[[rtm getPresence] getState:channelType:userId:completion]`                                           |
|                   | Remove User Temporary State                       | `[[rtm getPresence] removeState:channelType:keys:completion]`                                          |
| **Storage**       | Set Channel Metadata                              | `[[rtm getStorage] setChannelMetadata:channelType:data:options:lock:completion]`                         |
|                   | Get Channel Metadata                              | `[[rtm getStorage] getChannelMetadata:channelType:completion]`                                          |
|                   | Remove Channel Metadata                           | `[[rtm getStorage] removeChannelMetadata:channelType:data:options:lock:completion]`                      |
|                   | Update Channel Metadata                           | `[[rtm getStorage] updateChannelMetadata:channelType:data:options:lock:completion]`                      |
|                   | Set User Attributes                               | `[[rtm getStorage] setUserMetadata:data:options:completion]`                                            |
|                   | Get User Attributes                               | `[[rtm getStorage] getUserMetadata:completion]`                                                         |
|                   | Remove User Attributes                            | `[[rtm getStorage] removeUserMetadata:data:options:completion]`                                         |
|                   | Update User Attributes                            | `[[rtm getStorage] updateChannelMetadata:data:options:completion]`                                       |
|                   | Subscribe User Attributes                         | `[[rtm getStorage] subscribeUserMetadata:completion]`                                                   |
|                   | Unsubscribe User Attributes                       | `[[rtm getStorage] unsubscribeUserMetadata:completion]`                                                 |
| **Lock**          | Set Lock                                          | `[[rtm getLock] setLock:channelType:lockName:ttl:completion]`                                           |
|                   | Acquire Lock                                      | `[[rtm getLock] acquireLock:channelType:lockName:retry:completion]`                                     |
|                   | Release Lock                                      | `[[rtm getLock] releaseLock:channelType:lockName:completion]`                                           |
|                   | Revoke Lock                                       | `[[rtm getLock] revokeLock:channelType:lockName:userId:completion]`                                     |
|                   | Query Lock                                        | `[[rtm getLock] getLocks:channelType:completion]`                                                       |
|                   | Remove Lock                                       | `[[rtm getLock] removeLock:channelType:lockName:completion]`                                            |

</PlatformWrapper>

