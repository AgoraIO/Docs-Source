<PlatformWrapper platform="unity">

1. **Import the required Agora libraries**

    ``` csharp
    using Agora.Rtc;
    using TMPro;
    using System.Runtime.InteropServices;
    using System;
    ```

1. **Use a probe test to check network health**

    ``` csharp
    public void StartProbeTest()
    {
        // Configure a LastmileProbeConfig instance.
        LastmileProbeConfig config = new LastmileProbeConfig();

        // Probe the uplink network quality.
        config.probeUplink = true;

        // Probe the downlink network quality.
        config.probeDownlink = true;

        // The expected uplink bitrate (bps). The value range is [100000,5000000].
        config.expectedUplinkBitrate = 100000;

        // The expected downlink bitrate (bps). The value range is [100000,5000000].
        config.expectedDownlinkBitrate = 100000;

        RtcEngine.StartLastmileProbeTest(config);
        Debug.Log("Running the last mile probe test ...");
    }
    ```

1. **Implement best practice for app initiation**

    Use the following <Vg k="VSDK" /> features when you set up an instance of the <Vg k="ENGINE" />:

    * _Enable and configure logging_: For optimization and debugging.
    * _Enable dual stream mode_: Required for multi-user scenarios.
    * _Set an audio profile and audio scenario_: Setting an audio profile is optional and only required if you have special requirements such as streaming  music.
    * _Set the video profile_: Setting a video profile is also optional. It is useful when you want to change one or more of `mirrorMode`, `frameRate`, `bitrate`, `dimensions`, `orientationMode`, `degradationPrefer` or `compressionPrefer` from the default setting to custom values.
      For more information, see  [video profile table](#video-profile-table).

    ``` csharp
    public override void SetupAgoraEngine()
    {
        base.SetupAgoraEngine();

        // Specify a path for the log file.
        RtcEngine.SetLogFile("/path/to/folder/agorasdk1.log");

        // Set the log file size.
        RtcEngine.SetLogFileSize(256); // Range 128-20480 Kb

        // Specify a log level.
        RtcEngine.SetLogLevel(LOG_LEVEL.LOG_LEVEL_WARN);

        // Enable the dual stream mode.
        RtcEngine.EnableDualStreamMode(true);

        // Set audio profile and audio scenario.
        RtcEngine.SetAudioProfile(AUDIO_PROFILE_TYPE.AUDIO_PROFILE_DEFAULT, AUDIO_SCENARIO_TYPE.AUDIO_SCENARIO_CHATROOM);

        // Set the video profile.
        VideoEncoderConfiguration videoConfig = new VideoEncoderConfiguration();

        // Set mirror mode.
        videoConfig.mirrorMode = VIDEO_MIRROR_MODE_TYPE.VIDEO_MIRROR_MODE_DISABLED;

        // Set framerate.
        videoConfig.frameRate = (int)FRAME_RATE.FRAME_RATE_FPS_15;

        // Set bitrate.
        videoConfig.bitrate = (int)BITRATE.STANDARD_BITRATE;

        // Set dimensions.
        videoConfig.dimensions = new VideoDimensions(640, 360);

        // Set orientation mode.
        videoConfig.orientationMode = ORIENTATION_MODE.ORIENTATION_MODE_ADAPTIVE;

        // Set degradation preference.
        videoConfig.degradationPreference = DEGRADATION_PREFERENCE.MAINTAIN_BALANCED;

        // Apply the configuration.
        RtcEngine.SetVideoEncoderConfiguration(videoConfig);
        
    }
    ```

1. **Test the audio/video devices**

    The test checks the selected audio and video devices using `IVideoDeviceManager` and `IAudioDeviceManager`.

    ``` csharp
    public void testAudioAndVideoDevice()
    {
        GameObject go = GameObject.Find("testDevicesBtn");
        if(!isTestRunning)
        {
            string selectedAudioDevice = audioDevicesDropdown.options[audioDevicesDropdown.value].text;
            string selectedVideoDevice = videoDevicesDropdown.options[videoDevicesDropdown.value].text;
            foreach (var device in _audioRecordingDeviceInfos)
            {
                if(selectedAudioDevice == device.deviceName)
                {
                    _audioDeviceManager.SetRecordingDevice(device.deviceId);
                }
            }
            _audioDeviceManager.StartAudioDeviceLoopbackTest(500);
            foreach (var device in _videoDeviceInfos)
            {
                if(selectedVideoDevice == device.deviceName)
                {
                    _videoDeviceManager.SetDevice(device.deviceId);
                }
            }
            hWnd = CreateWindowEx(
                0,
                "Static",
                "My Window",
                WS_OVERLAPPEDWINDOW | WS_VISIBLE,
                100,
                100,
                640,
                480,
                IntPtr.Zero,
                IntPtr.Zero,
                Marshal.GetHINSTANCE(typeof(EnsureCallQuality).Module),
                IntPtr.Zero);
                ShowWindow(hWnd, SW_SHOW);
                _videoDeviceManager.StartDeviceTest(hWnd);
                isTestRunning = true;
                go.GetComponentInChildren<TextMeshProUGUI>(true).text = "Stop test";
        }
        else
        {
            DestroyWindow(hWnd);
            isTestRunning = false;
            go.GetComponentInChildren<TextMeshProUGUI>(true).text = "Start device testing";
            _audioDeviceManager.StopAudioDeviceLoopbackTest();
            _videoDeviceManager.StopDeviceTest();
        }
    }
    private void GetAudioRecordingDevice()
    {
        _audioDeviceManager = RtcEngine.GetAudioDeviceManager();
        _audioRecordingDeviceInfos = _audioDeviceManager.EnumerateRecordingDevices();

        audioDevicesDropdown = GameObject.Find("audioDevicesDropdown").GetComponent<TMP_Dropdown>();
        List<string> options = new List<string>();

        for (var i = 0; i < _audioRecordingDeviceInfos.Length; i++)
        {
            Debug.Log(string.Format("AudioRecordingDevice device index: {0}, name: {1}, id: {2}", i,
                _audioRecordingDeviceInfos[i].deviceName, _audioRecordingDeviceInfos[i].deviceId));
            options.Add(_audioRecordingDeviceInfos[i].deviceName);
        }

        audioDevicesDropdown.ClearOptions();
        audioDevicesDropdown.AddOptions(options);
    }
    private void GetVideoDeviceManager()
    {
        _videoDeviceManager = RtcEngine.GetVideoDeviceManager();
        _videoDeviceInfos = _videoDeviceManager.EnumerateVideoDevices();

        videoDevicesDropdown = GameObject.Find("videoDevicesDropdown").GetComponent<TMP_Dropdown>();
        videoDevicesDropdown.transform.localPosition = new Vector2(-23, -172);

        Debug.Log(string.Format("VideoDeviceManager count: {0}", _videoDeviceInfos.Length));
        List<string> options = new List<string>();

        for (var i = 0; i < _videoDeviceInfos.Length; i++)
        {
            Debug.Log(string.Format("VideoDeviceManager device index: {0}, name: {1}, id: {2}", i,
                _videoDeviceInfos[i].deviceName, _videoDeviceInfos[i].deviceId));
            options.Add(_videoDeviceInfos[i].deviceName);
        }

        videoDevicesDropdown.ClearOptions();
        videoDevicesDropdown.AddOptions(options);
    }
    ```

1. **Listen to <Vg k="ENGINE" /> events to receive state change notifications and quality statistics**

    Use the following `IRtcEngineEventHandler` callbacks to monitor and ensure channel quality:

    ``` csharp
    internal class CallQualityEventHandler : UserEventHandler
    {
        private CallQualityManager callQuality;
        internal CallQualityEventHandler(CallQualityManager videoSample):base(videoSample) 
        {
            callQuality = videoSample;
        }
        public override void OnConnectionStateChanged(RtcConnection connection, CONNECTION_STATE_TYPE state, CONNECTION_CHANGED_REASON_TYPE reason) 
        {
            Debug.Log("Connection state changed"
             + "\n New state: " + state
             + "\n Reason: " + reason);
        }
        public override void OnLastmileQuality(int quality) 
        {
            callQuality.updateNetworkStatus(quality);
        }
        public override void OnLastmileProbeResult(LastmileProbeResult result) 
        {
            _videoSample.RtcEngine.StopLastmileProbeTest();
        Debug.Log("Probe test finished");
        // The result object contains the detailed test results that help you
        // manage call quality, for example, the downlink jitter.
        Debug.Log("Downlink jitter: " + result.downlinkReport.jitter);
    }
    public override void OnNetworkQuality(RtcConnection connection, uint remoteUid, int txQuality, int rxQuality) 
    {
        // Use downlink network quality to update the network status
        callQuality.updateNetworkStatus(rxQuality);
    }
    public override void OnRtcStats(RtcConnection connection, RtcStats rtcStats) 
    {
        string msg = "";
        msg = rtcStats.userCount + " user(s)";
        msg = "Packet loss rate: " + rtcStats.rxPacketLossRate;
        Debug.Log(msg);
    }
    public override void OnRemoteVideoStateChanged(RtcConnection connection, uint remoteUid, REMOTE_VIDEO_STATE state, REMOTE_VIDEO_STATE_REASON reason, int elapsed) 
    {
        string msg = "Remote video state changed: \n Uid =" + remoteUid
             + " \n NewState =" + state
             + " \n reason =" + reason
             + " \n elapsed =" + elapsed;
        Debug.Log(msg);
    }
    public override void OnRemoteVideoStats(RtcConnection connection, RemoteVideoStats stats) 
    {
        string msg = "Remote Video Stats: "
             + "\n User id =" + stats.uid
             + "\n Received bitrate =" + stats.receivedBitrate
             + "\n Total frozen time =" + stats.totalFrozenTime;
        Debug.Log(msg);
    }
    }
    ```

1. **Switch stream quality**

    Take advantage of dual-stream mode and switch remote video quality to high or low.

    ``` csharp
    public void setStreamQuality()
    {
        GameObject videoQualityBtn = GameObject.Find("videoQualityBtn");
        TMP_Text videoQualityBtnText = videoQualityBtn.GetComponentInChildren<TextMeshProUGUI>(true); // For changing the button text programmatically.
        if(remoteUid == 0)
        {
            Debug.Log("No remote user in the channel");
            return;
        }
        highQuality = !highQuality;
        if (highQuality) 
        {
            RtcEngine.SetRemoteVideoStreamType(remoteUid, VIDEO_STREAM_TYPE.VIDEO_STREAM_HIGH);
            videoQualityBtnText.text = "Low Video Quality";
            Debug.Log("Switching to high-quality video");
        } 
        else 
        {
            RtcEngine.SetRemoteVideoStreamType(remoteUid, VIDEO_STREAM_TYPE.VIDEO_STREAM_LOW);
            Debug.Log("Switching to low-quality video");
        }
    }
    ```

<ProductWrapper product={["interactive-live-streaming", "broadcast-streaming"]}>
7. **Set the latency level**

    For ultra low-latency applications, set the appropriate `audienceLatencyLevel` when joining a channel. Ultra-low latency is a feature of <Vg k="ILS" /> and its use is subject to special [pricing](../reference/pricing#unit-pricing).

    ``` csharp
    // Set the latency level
    options.audienceLatencyLevel= Constants.AUDIENCE_LATENCY_LEVEL_ULTRA_LOW_LATENCY;
    ```
</ProductWrapper>

</PlatformWrapper>
