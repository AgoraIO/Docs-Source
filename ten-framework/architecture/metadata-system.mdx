---
title: 'Metadata system'
sidebar_position: 7
platform_selector: false
description: >
  TEN framework metadata system.
---

The TEN framework uses a consistent metadata system across all package types:

- App
- Extension Group
- Extension
- Protocol
- System

## Metadata types

The TEN metadata system has two primary components:

### Manifest

The manifest is stored in `manifest.json` in the root directory of each TEN package and contains:

- Package name
- Package version (following semantic versioning)
- TEN schemas for property and message definitions
  - Property schema: Often defined in a separate `property.json` file
  - Message schema: Defines input/output message formats

<Admonition type="info">
The TEN schema in `manifest.json` is not a JSON schema. It describes TEN value metadata that are central to the TEN runtime, while JSON serves only as a representation format.
</Admonition>

### Property

Property values are typically stored in `property.json` in the root directory of the TEN package. These values are read-write during runtime, allowing modification while the TEN runtime executes.

Example `property.json`:

```json
{
  "Darth Vader": "I am your father"
}
```

## Manifest file structure

The `manifest.json` file defines the package's metadata, properties, and input/output messages.

Example `manifest.json`:

```json
{
  "type": "app",
  "name": "default_app_cpp",
  "version": "1.0.0",
  "dependencies": [
    {
      "type": "system",
      "name": "ten_runtime",
      "version": "1.0.0"
    }
  ],
  "api": {
    "property": {
      "exampleInt8": {
        "type": "int8"
      },
      "exampleString": {
        "type": "string"
      }
    },
    "cmd_in": [
      {
        "name": "cmd_foo",
        "property": {
          "foo": {
            "type": "int8"
          },
          "bar": {
            "type": "string"
          }
        },
        "result": {
          "property": {
            "detail": {
              "type": "string"
            },
            "aaa": {
              "type": "int8"
            },
            "bbb": {
              "type": "string"
            }
          }
        }
      }
    ],
    "cmd_out": [],
    "data_in": [
      {
        "name": "data_foo",
        "property": {
          "foo": {
            "type": "int8"
          },
          "bar": {
            "type": "string"
          }
        }
      }
    ],
    "data_out": [],
    "video_frame_in": [],
    "video_frame_out": [],
    "audio_frame_in": [],
    "audio_frame_out": []
  }
}
```

### TEN schema usage

The TEN schema in `manifest.json` provides metadata about the extension's external API, including:

1. **Property validation**: Validates properties when the runtime gets/sets them
2. **Data conversion**: Converts JSON to TEN package or message properties using the `from_json` API.
3. **Compatibility checks**: Verifies if messages can be routed between extensions according to the TEN schema.

## Property management

The TEN framework manages two property types:

1. **Message properties**: These properties are associated with the messages exchanged between extensions within the framework. Message properties define the specific data or parameters that are carried within a message, such as command parameters, data payloads, or metadata related to audio/video frames.

2. **TEN package properties**: These properties are associated with the TEN packages themselves, such as extensions. TEN package properties define the configuration or settings specific to a package. For example, an extension might have properties that configure its behavior, such as runtime settings, initialization parameters, or other configuration data.

![Property system](/images/ten-framework/property_system.png)

### Defining package properties

The `property.json` file defines TEN package properties:

```json
{
  "prop_1_name": 0,
  "prop_2_name": "prop_2_value",
  "prop_3_name": ["hello", "prop_3_sub_value"],
  "prop_4_name": {
    "prop_4_1_name": 1,
    "prop_4_2_name": "prop_4_sub_value"
  }
}
```

<Admonition type="info">
Each property name in the `property.json` file must be unique.
</Admonition>

### TEN schema for properties

You can define a TEN schema for properties in the `manifest.json` file, enabling the TEN runtime to handle these properties more effectively. If a property does not have a corresponding TEN schema, the runtime uses the default JSON handling method (e.g., treating all JSON numbers as float64). If a TEN schema is provided, the runtime uses it to validate and process the property accordingly.

| Property | TEN Schema | Effect                                                          |
| :------: | :--------: | --------------------------------------------------------------- |
| Yes      | Yes        | Runtime validates property values based on schema (type check)  |
| Yes      | No         | Runtime uses default handling (all JSON numbers as `float64`)   |

### Setting properties in the `start_graph` command

You can specify property values in the `start_graph` command. The TEN runtime processes these properties according to the TEN schema (if defined) and stores them within the corresponding TEN package instance.

```json
{
  "nodes": [
    {
      "type": "extension_group",
      "name": "foo_extension_group",
      "addon": "foo_extension_group_addon"
    },
    {
      "type": "extension",
      "name": "bar_extension",
      "extension_group": "foo_extension_group",
      "property": {
        "prop_1_name": 0,
        "prop_2_name": "prop_2_value",
        "prop_3_name": ["hello", "prop_3_sub_value"],
        "prop_4_name": {
          "prop_4_1_name": 1,
          "prop_4_2_name": "prop_4_sub_value"
        }
      }
    }
  ]
}
```